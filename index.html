<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>The Vault Simulator</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    .log { white-space: pre-wrap; background: #f8f8f8; padding: 10px; border: 1px solid #ccc; margin: 20px 0; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
    td, th { border: 1px solid #999; padding: 5px 10px; text-align: center; }
    .highlight { font-weight: bold; color: #d42; }
    .keyholder { background-color: #ffd; font-weight: bold; }
  </style>
</head>
<body>
  <h1>The Vault Simulator</h1>
  <p>Enter 12 player names (one per line):</p>
  <textarea id="playerInput" rows="12" cols="30" placeholder="Player 1&#10;Player 2&#10;..."></textarea><br>
  <button onclick="startGame()" id="startBtn">Start Game</button>
  <button onclick="runRound()" id="nextBtn" style="display:none;">Run Next Round</button>

  <div id="log" class="log"></div>
  <div id="votingTable"></div>
  <div id="progressTable"></div>

  <script>
// The Vault Simulator - Full JavaScript Logic

let players = [];
let phase = 1;
let round = 1;
let lockpickHolder = null;
let usedLockpicks = [];
let eliminated = [];
let finalists = [];
let jury = [];
let vaults = [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22];
let alliances = {};
let voteLogs = [];

function startGame() {
  const input = document.getElementById("playerInput").value.trim().split("\n").map(p => p.trim()).filter(Boolean);
  if (input.length !== 12) {
    alert("Please enter exactly 12 player names.");
    return;
  }
  players = input.map(name => ({
    name,
    key1: false,
    key2: false,
    key3: false,
    totalKeys: 0,
    eliminated: false,
    alliance: [],
    vault: null,
    bonusKeys: 0,
    totalFinalKeys: 0
  }));
  assignAlliances();
  logAlliances();
  document.getElementById("startBtn").style.display = "none";
  document.getElementById("nextBtn").style.display = "inline-block";
  runRound();
}

function assignAlliances() {
  const numAlliances = Math.floor(Math.random() * 6) + 1;
  for (let i = 1; i <= numAlliances; i++) {
    let name = `Alliance ${i}`;
    const members = shuffle(players).slice(0, Math.floor(Math.random() * 4) + 2);
    alliances[name] = members.map(p => p.name);
    members.forEach(m => {
      if (!m.alliance.includes(name)) m.alliance.push(name);
    });
  }
}

function logAlliances() {
  let logText = "<b>Alliances:</b><br>";
  for (let a in alliances) {
    logText += `${a}: ${alliances[a].join(", ")}<br>`;
  }
  document.getElementById("log").innerHTML += logText;
}

function runRound() {
  clearLog();
  logAlliances();
  if (phase === 1) runPhase1();
  else if (phase === 2) runPhase2();
  else if (phase === 3) runPhase3();
  else if (phase === 4) runFinale();
}

function runFinale() {
  for (let f of finalists) {
    let estimate = f.totalKeys + 3;
    let range = vaults.filter(v => v <= estimate + 2 && v >= estimate - 1);
    f.vault = range[Math.floor(Math.random() * range.length)] || 3;
    f.totalFinalKeys = 3;
  }

  jury.forEach(j => {
    let keys = j.key3 ? 4 : j.key2 ? 2 : 1;
    let target = pickAllyOrRandom(j, finalists);
    target.bonusKeys += keys;
    target.totalFinalKeys += keys;
  });

  for (let f of finalists) {
    log(`${f.name} tries to open a ${f.vault}-key vault.`);
  }

  let unlocked = finalists.filter(f => f.totalFinalKeys >= f.vault);
  if (unlocked.length) {
    unlocked.sort((a,b)=>b.vault - a.vault);
    log(`\n<b>${unlocked[0].name} unlocks the highest vault (${unlocked[0].vault}) and wins!</b>`);
  } else {
    let fallback = players.find(p => !p.eliminated && !finalists.includes(p));
    log(`No vaults opened. ${fallback ? fallback.name : finalists[0].name} wins by default.`);
  }

  log("<br><b>Final Jury Key Distribution:</b>");
  for (let f of finalists) {
    log(`${f.name}: ${f.bonusKeys} bonus keys from jury.`);
  }

  generateVotingCharts();
}

function runPhase3() {
  const active = players.filter(p => !p.eliminated && p.key1 && p.key2);
  if (active.length !== 4) {
    log("Error: Phase 3 requires 4 players.");
    return;
  }
  const votes = {};
  for (let v of active) {
    const choices = active.filter(p => p.name !== v.name);
    const voteFor = pickAllyOrRandom(v, choices);
    votes[voteFor.name] = (votes[voteFor.name] || 0) + 1;
  }
  voteLogs.push({ phase: 3, round: 1, votes: JSON.parse(JSON.stringify(votes)) });
  let sorted = Object.entries(votes).sort((a,b)=>b[1]-a[1]);
  let top = sorted[0];
  let second = sorted[1];
  let voteWinner;

  if (!second || top[1] > second[1]) {
    voteWinner = active.find(p => p.name === top[0]);
    let pick = active.filter(p => p !== voteWinner);
    let ally = pickAllyOrRandom(voteWinner, pick);
    log(`${voteWinner.name} brings ${ally.name} to the finale.`);
    let rest = pick.filter(p => p !== ally);
    let challengeWinner = rest[Math.floor(Math.random() * rest.length)];
    log(`${challengeWinner.name} wins the final challenge.`);
    voteWinner.key3 = true;
    ally.key3 = true;
    challengeWinner.key3 = true;
    finalists = [voteWinner, ally, challengeWinner];
  } else {
    let tied = [top[0], second[0]];
    let untied = active.filter(p => !tied.includes(p.name));
    let challengeWinner = active.find(p => tied.includes(p.name));
    untied[0].key3 = true;
    untied[1].key3 = true;
    challengeWinner.key3 = true;
    log(`${untied[0].name} and ${untied[1].name} advance. ${challengeWinner.name} wins the final challenge.`);
    finalists = [untied[0], untied[1], challengeWinner];
  }
  players.forEach(p => {
    if (!finalists.includes(p)) {
      p.eliminated = true;
      jury.push(p);
    }
  });
  phase = 4;
  round = 1;
  updateTable();
}

function generateVotingCharts() {
  let html = "<h2>Voting History</h2>";
  voteLogs.forEach(log => {
    html += `<h3>Phase ${log.phase} - Round ${log.round}</h3>`;
    html += "<table><tr><th>Voter</th><th>Voted For</th></tr>";
    for (let [name, count] of Object.entries(log.votes)) {
      for (let i = 0; i < count; i++) {
        html += `<tr><td>Unknown</td><td>${name}</td></tr>`;
      }
    }
    html += "</table>";
  });
  document.getElementById("progressTable").innerHTML = html;
}
</script>
</body>
</html>
