<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Vault — ALT Rules (13 Players, Full Features)</title>
<style>
  :root{
    --bg:#0f1115; --panel:#161a22; --panel2:#1c2130; --muted:#2a2f3a; --text:#e5e7eb; --sub:#aeb4c0;
    --good:#6ee7b7; --warn:#fbbf24; --bad:#f87171; --accent:#7aa2ff; --border:#2b3340;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  h1{margin:0;font-size:20px}
  h2{margin:0 0 10px;font-size:16px}
  h3{margin:0 0 6px;font-size:15px}
  textarea,button,input,select{width:100%;padding:12px;margin-top:8px;border-radius:10px;border:1px solid var(--border);background:var(--panel2);color:var(--text);font-size:16px}
  button{cursor:pointer} button:hover{background:#202739}
  .app{display:grid;grid-template-columns:280px 1fr;min-height:100vh}
  @media (max-width: 960px){ .app{grid-template-columns:1fr} }
  .sidebar{background:var(--panel);border-right:1px solid var(--border);padding:14px 12px;display:flex;flex-direction:column;gap:12px;position:sticky;top:0;height:100vh}
  @media (max-width:960px){ .sidebar{position:relative;height:auto} }
  .brand{display:flex;align-items:center;justify-content:space-between;gap:10px}
  .hamburger{display:none;font-size:18px;padding:8px 10px;border-radius:8px;background:var(--panel2)}
  @media (max-width:960px){ .hamburger{display:inline-block} .sidebar.collapsed .collapsible-area{display:none} }
  .navbox{background:var(--panel2);border:1px solid var(--border);border-radius:10px;padding:10px}
  .epList{flex:1;overflow:auto;border:1px solid var(--border);border-radius:10px}
  .epItem{padding:10px;border-bottom:1px solid var(--border);display:flex;gap:10px;align-items:center}
  .epItem:last-child{border-bottom:none}
  .thumb{width:36px;height:36px;border-radius:8px;background:var(--muted);display:flex;align-items:center;justify-content:center;font-size:12px}
  .main{padding:16px;display:grid;gap:14px}
  .box{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .col{flex:1 1 280px}
  pre{white-space:pre-wrap;background:#0b0d12;border:1px solid var(--border);border-radius:10px;padding:10px;min-height:180px;max-height:280px;overflow:auto}
  table{width:100%;border-collapse:collapse}
  th,td{border:1px solid var(--border);padding:6px;text-align:center;white-space:nowrap}
  th{background:#1b2130}
  .hint{font-size:13px;color:var(--sub)}
  .chip{display:flex;align-items:center;gap:8px;border:1px solid var(--border);padding:6px 8px;border-radius:10px;margin:6px 0}
  .avatar{width:22px;height:22px;border-radius:6px;object-fit:cover;background:var(--muted);display:inline-flex;align-items:center;justify-content:center;font-size:11px}
  .pill{display:inline-flex;align-items:center;padding:2px 8px;border:1px solid var(--border);border-radius:999px;font-size:12px;margin-right:6px}
  .toggle{display:flex;align-items:center;gap:8px;font-size:13px;color:var(--sub)}
  .toggle span{color:var(--text);font-weight:600}
</style>
</head>
<body>
<div class="app">
  <!-- Sidebar (Episodes + Spoiler toggle + Season controls) -->
  <aside class="sidebar collapsed" id="sidebar">
    <div class="brand">
      <h1>Vault — Alt S1</h1>
      <button class="hamburger" id="hamburger">☰</button>
    </div>
    <div class="collapsible-area">
      <div class="navbox">
        <label class="toggle"><input type="checkbox" id="spoilerToggle"/><span>Spoiler‑free nav</span></label>
      </div>

      <div class="box" id="seasonControls">
        <h2>Season Controls</h2>
        <label>Alliance Preset</label>
        <select id="alliancePreset">
          <option value="fluid">Fluid webs (default)</option>
          <option value="loyal">Loyal blocs</option>
          <option value="duos">Duo‑centric</option>
          <option value="loners">Loners thrive</option>
        </select>
        <hr style="border-color:var(--border);margin:12px 0">
        <label class="toggle"><input type="checkbox" id="tw_noLockpick"><span>No Lockpick</span></label>
        <label class="toggle"><input type="checkbox" id="tw_doubleDuel" disabled><span>Double Duel (P2) — not in Alt</span></label>
        <div class="hint">These lock & disappear when you press Start Season.</div>
      </div>

      <div class="epList" id="epList"></div>
    </div>
  </aside>

  <!-- Main -->
  <main class="main">

    <div class="box">
      <div class="row">
        <div class="col">
          <label><b>Enter 13 Players (one per line)</b></label>
          <textarea id="playerInput" rows="13" placeholder="Player 1&#10;Player 2&#10;..."></textarea>
          <div class="row">
            <button id="startBtn">Start Season</button>
            <button id="nextBtn" style="display:none;">Next Scene ▶</button>
          </div>
          <div class="hint">Alt Vault rules active: P1 (R1–R4 draw 6, R4 can be 7; R5 last‑chance vote). P2 (R1–R4 standard with tie logic; R5 last‑chance challenge). P3 bottom‑3 challenge. Finale fallback: Final‑3 challenge.</div>
        </div>
        <div class="col" id="castBox">
          <h2>Cast Photos & Colors</h2>
          <div id="castGrid"></div>
        </div>
      </div>
    </div>

    <div class="box" id="preseasonBox">
      <h2>Preseason: Stats & Relationships</h2>
      <div class="row">
        <div class="col">
          <h3>Player Stats</h3>
          <div id="statsTable"></div>
          <div class="row">
            <button id="presetBalanced">Balanced</button>
            <button id="presetSocial">Social‑heavy</button>
            <button id="presetChallenge">Challenge‑heavy</button>
            <button id="presetRandom">Randomize All</button>
            <button id="applyStats">Apply Stats</button>
          </div>
          <div class="hint">Range: 1–15 (default 8/8). Hidden once the game starts.</div>
        </div>
        <div class="col">
          <h3>Relationships (−5…+5)</h3>
          <div class="row" style="align-items:center">
            <label>Focus</label>
            <select id="relFocus"></select>
          </div>
          <div id="relEditor" style="margin-top:6px"></div>
          <div class="row" style="margin-top:6px">
            <button id="relSave">Save (All)</button>
            <button id="relRandFocus">Randomize Focus</button>
            <button id="relClearFocus">Clear Focus</button>
            <button id="relRandAll">Randomize All</button>
            <button id="relClearAll">Clear All</button>
          </div>
        </div>
      </div>
    </div>

    <div class="box">
      <h2>Round Events (Scene Feed)</h2>
      <pre id="sceneFeed">(Ready) Tap “Next Scene”.</pre>
    </div>

    <div class="row">
      <div class="box col">
        <h2>Alliances</h2>
        <div id="alliancesList"></div>
      </div>
      <div class="box col">
        <h2>Progress</h2>
        <div id="progressChart"></div>
      </div>
    </div>

    <div class="row">
      <div class="box col">
        <h2>Voting Matrix (Season)</h2>
        <div id="votingMatrix"></div>
        <div class="hint">Order: active → P3 elim → P2 elim → P1 elim. “LOCKPICK” appears if used.</div>
      </div>
      <div class="box col">
        <h2>Relationships (Live)</h2>
        <div id="relsLive"></div>
      </div>
    </div>

    <div class="box">
      <h2>Jury Key Distribution</h2>
      <div id="juryMatrix"></div>
    </div>

  </main>
</div>

<script>
/* ================= Tunables (carryover) ================= */
var SEASON = { preset:'fluid', noLockpick:false };
var ALPHA_SOCIAL=0.65, BETA_CHALLENGE=1.0, GAMMA_BEATABLE=1.2;
var LOGIT_K=0.7, WIN_CLAMP_LO=0.15, WIN_CLAMP_HI=0.85;
var VOTE_JITTER_MIN=0.8, VOTE_JITTER_MAX=1.2, ALLY_PREFERENCE_RATE=0.6;
var REL_SCALE=0.08, REL_MIN_FACTOR=0.3;

/* ================= Event Library (carryover) ================= */
const EVENT_LIBRARY = [
  {type:'bond',    text:(a,b)=>`${a} flips ${b}'s mattress back after a prank; they laugh it off. (+1)`, w:2},
  {type:'tension', text:(a,b)=>`${a} flips ${b}'s mattress during a nap. (-1)`, w:1},
  {type:'tension', text:(a,b)=>`${a} accidentally breaks ${b}'s mug. Tension rises. (-1)`, w:1},
  {type:'bond',    text:(a,b)=>`${a} replaces ${b}'s broken mug with a new one. (+1)`, w:1},
  {type:'tension', text:(a,b)=>`A plane flies overhead: “${b} is not to be trusted!” ${a} side‑eyes ${b}. (-1)`, w:1},
  {type:'bond',    text:(a,b)=>`${a} comforts ${b} after a rough day. (+1)`, w:2},
  {type:'tension', text:(a,b)=>`${a} spreads a rumor that ${b} has the Lockpick. (-1)`, w:1},
  {type:'bond',    text:(a,b)=>`${a} shares food with ${b}. (+1)`, w:2},
  {type:'tension', text:(a,b)=>`${a} hogs the shower and ${b} calls them out. (-1)`, w:1},
  {type:'bond',    text:(a,b)=>`${a} and ${b} stay up strategizing together. (+1)`, w:2},
  {type:'tension', text:(a,b)=>`${a} hides ${b}'s shoes before the draw. (-1)`, w:1},
  {type:'bond',    text:(a,b)=>`${a} teaches ${b} a challenge trick. (+1)`, w:2},
  {type:'tension', text:(a,b)=>`${a} refuses to throw a duel for ${b}. (-1)`, w:1}
];

/* ================= State ================= */
var players=[], initialOrder=[], phase=1, round=1;
var alliances={}, keys={}, jury=[], finalists=[], eliminated=[];
var lockpickHolder=null, lockpickUsed=false, lockpickFound=false;
var voteColumns=[], spoilerFree=false;
var stats={}, rel={}, cast={};
var wins={}, losses={}, keysEarned={}, votesGiven={}, votesReceived={}, juryKeysReceived={};

/* Episode system */
var episodes=[], currentEpisode=null, sceneQueue=[], sceneIndex=0;

/* Temps */
var p1_step=0, p1_drawn=[], p1_votePairs=[], p1_voteWinner=null, p1_tiedGroup=[];
var p2_step=0, p2_votePairs=[], p2_noP2=[], p2_tied=[], p2_voteWinner=null, p2_picks=[];
var p3_step=0, p3_duelists=[];
var finaleState=null;

/* ================= DOM ================= */
var sidebar=document.getElementById('sidebar');
document.getElementById('hamburger').onclick=function(){ sidebar.classList.toggle('collapsed'); };
document.getElementById('spoilerToggle').onchange=function(){ spoilerFree=this.checked; renderEpisodeNav(); };
document.getElementById('alliancePreset').onchange=function(){ SEASON.preset=this.value; };
document.getElementById('tw_noLockpick').onchange=function(){ SEASON.noLockpick=this.checked; };
var startBtn=document.getElementById('startBtn'), nextBtn=document.getElementById('nextBtn');
var sceneFeed=document.getElementById('sceneFeed'), epListDiv=document.getElementById('epList');

startBtn.onclick=startSeason;
nextBtn.onclick=function(){
  if (sceneQueue.length){ showLine(sceneQueue.shift()); currentEpisode.linesViewed++; renderEpisodeNav(); return; }
  const prevTotal=currentEpisode?.total||0; progressGame();
  if (sceneQueue.length && (currentEpisode?.total||0) > prevTotal){ showLine(sceneQueue.shift()); currentEpisode.linesViewed++; renderEpisodeNav(); }
};

/* ================= Utils ================= */
function shuffle(a){ return a.slice().sort(()=>Math.random()-0.5); }
function clamp(v,lo,hi){ return Math.max(lo,Math.min(hi,v)); }
function initials(n){ return (n.split(/\s+/).map(x=>x[0]).join('')||'?').slice(0,2).toUpperCase(); }
function inAlliance(a,b){ return Object.values(alliances).some(L=>L.includes(a)&&L.includes(b)); }
function getElimPhase(n){ const x=jury.find(j=>j.name===n); return x?x.phase:null; }
function setRel(a,b,val){ rel[a]=rel[a]||{}; rel[b]=rel[b]||{}; rel[a][b]=val; rel[b][a]=val; }
function getRel(a,b){ return rel[a]?.[b] ?? 0; }
function relFactor(voter,target){ return clamp(1+REL_SCALE*getRel(voter,target), REL_MIN_FACTOR, 2); }
function weighted(items, fn){ const w=items.map(fn); const s=w.reduce((a,b)=>a+b,0); let r=Math.random()*s; for(let i=0;i<items.length;i++){ r-=w[i]; if(r<=0) return items[i]; } return items[items.length-1]; }
function duelWinProb(a,b){ const da=stats[a]?.challenge||8, db=stats[b]?.challenge||8; const p=1/(1+Math.exp(-LOGIT_K*(da-db))); return clamp(p,WIN_CLAMP_LO,WIN_CLAMP_HI); }

/* Episodes */
function ensureEpisode(){ const tag=`Phase ${phase} R${round}`; if(!currentEpisode || currentEpisode._tag!==tag){ currentEpisode={title:`Episode ${episodes.length+1} — ${tag}`, _tag:tag, linesViewed:0, total:0}; episodes.push(currentEpisode); sceneQueue=[]; sceneIndex=0; renderEpisodeNav(); showLine('(Ready) Tap “Next Scene”.'); } }
function addScene(text){ sceneQueue.push(text); if(currentEpisode) currentEpisode.total++; }
function showLine(text){ sceneFeed.textContent=text; }
function renderEpisodeNav(){
  epListDiv.innerHTML=episodes.map((ep,i)=>`
    <div class="epItem">
      <div class="thumb">${i+1}</div>
      <div style="flex:1">
        <div>${ep.title}</div>
        <div><small>${ep.linesViewed} / ${ep.total} scenes</small></div>
      </div>
    </div>`).join('');
}

/* Preseason builders */
const castGrid=document.getElementById('castGrid'), statsTable=document.getElementById('statsTable');
function preNames(){ return document.getElementById('playerInput').value.trim().split('\n').map(s=>s.trim()).filter(Boolean); }
document.getElementById('playerInput').addEventListener('input', ()=>{ if(!gameStarted){ buildStatsTable(); buildRelFocusList(); buildCastGrid(); renderRelsLive(); }});

function buildCastGrid(){
  const names=preNames(); if(!names.length){ castGrid.innerHTML=''; return; }
  if(!Object.keys(cast).length){
    const pal=["#7aa2ff","#ffa07a","#a3e635","#f472b6","#facc15","#34d399","#60a5fa","#f59e0b","#22d3ee","#c084fc","#fb7185","#93c5fd","#38bdf8"];
    names.forEach((n,i)=> cast[n]={photo:'',color:pal[i%pal.length]});
  }
  castGrid.innerHTML=names.map(n=>{
    const c=cast[n]||{photo:'',color:'#7aa2ff'};
    return `<div class="chip">
      ${c.photo?`<img class="avatar" src="${c.photo}">`:`<div class="avatar" style="background:${c.color}">${initials(n)}</div>`}
      <div style="flex:1">${n}<input type="url" class="photoUrl" data-name="${n}" placeholder="Image URL" value="${c.photo}"></div>
      <input type="color" class="color" data-name="${n}" value="${c.color}">
    </div>`;
  }).join('');
  castGrid.querySelectorAll('.photoUrl').forEach(inp=> inp.oninput=()=>{ const n=inp.dataset.name; cast[n]=cast[n]||{photo:'',color:'#7aa2ff'}; cast[n].photo=inp.value.trim(); buildCastGrid(); });
  castGrid.querySelectorAll('.color').forEach(inp=> inp.oninput=()=>{ const n=inp.dataset.name; cast[n]=cast[n]||{photo:'',color:'#7aa2ff'}; cast[n].color=inp.value; buildCastGrid(); });
}
function buildStatsTable(){
  const names=preNames();
  statsTable.innerHTML = `<table><tr><th>Player</th><th>Social</th><th>Challenge</th></tr>${
    names.map(n=>{
      const s=stats[n]?.social??8, c=stats[n]?.challenge??8;
      return `<tr><td>${n}</td>
        <td><input type="number" class="st" data-name="${n}" data-field="social" min="1" max="15" value="${s}"></td>
        <td><input type="number" class="st" data-name="${n}" data-field="challenge" min="1" max="15" value="${c}"></td></tr>`;
    }).join('')
  }</table>`;
}
function applyStatsFromInputs(){
  statsTable.querySelectorAll('.st').forEach(inp=>{
    const n=inp.dataset.name, f=inp.dataset.field, v=clamp(parseInt(inp.value||'8',10),1,15);
    stats[n]=stats[n]||{social:8,challenge:8}; stats[n][f]=v;
  });
}
document.getElementById('applyStats').onclick=applyStatsFromInputs;
document.getElementById('presetBalanced').onclick=()=>presetStats('balanced');
document.getElementById('presetSocial').onclick=()=>presetStats('social');
document.getElementById('presetChallenge').onclick=()=>presetStats('challenge');
document.getElementById('presetRandom').onclick=()=>presetStats('random');
function presetStats(which){
  const names=preNames();
  names.forEach(n=>{
    stats[n]=stats[n]||{social:8,challenge:8};
    if(which==='balanced') stats[n]={social:8,challenge:8};
    if(which==='social')   stats[n]={social:12,challenge:8};
    if(which==='challenge')stats[n]={social:8,challenge:12};
    if(which==='random')   stats[n]={social:1+Math.floor(Math.random()*15),challenge:1+Math.floor(Math.random()*15)};
  });
  buildStatsTable();
}

/* Relationship editor */
var relFocusSel=document.getElementById('relFocus'), relEditorDiv=document.getElementById('relEditor');
function buildRelFocusList(){ const names=preNames(); relFocusSel.innerHTML=names.map(n=>`<option>${n}</option>`).join(''); if(names.length) renderRelEditorFor(names[0]); }
relFocusSel.onchange=()=> renderRelEditorFor(relFocusSel.value);
function renderRelEditorFor(focus){
  const names=preNames().filter(n=>n!==focus);
  relEditorDiv.innerHTML = `<table><tr><th>Player</th><th>Score</th></tr>${
    names.map(n=>`<tr><td>${n}</td><td><input type="number" class="relSpin" data-focus="${focus}" data-target="${n}" min="-5" max="5" step="1" value="${getRel(focus,n)}"></td></tr>`).join('')
  }</table>`;
  relEditorDiv.querySelectorAll('.relSpin').forEach(sp=> sp.oninput=()=>{ const f=sp.dataset.focus,t=sp.dataset.target; setRel(f,t,clamp(parseInt(sp.value||'0',10),-5,5)); renderRelsLive(); });
}
document.getElementById('relSave').onclick=()=>{
  relEditorDiv.querySelectorAll('.relSpin').forEach(sp=>{ const f=sp.dataset.focus,t=sp.dataset.target; setRel(f,t,clamp(parseInt(sp.value||'0',10),-5,5)); });
  const names=preNames(); names.forEach(a=>names.forEach(b=>{ if(a!==b) setRel(a,b,getRel(a,b)); }));
  addScene('Saved all preseason relationships.'); renderRelsLive();
};
document.getElementById('relRandFocus').onclick=()=>{
  const f=relFocusSel.value; relEditorDiv.querySelectorAll('.relSpin').forEach(sp=>{ const t=sp.dataset.target; const v=Math.floor(-2+Math.random()*5); setRel(f,t,v); sp.value=v; });
  addScene('Randomized focus relationships for '+f+'.'); renderRelsLive();
};
document.getElementById('relClearFocus').onclick=()=>{
  const f=relFocusSel.value; relEditorDiv.querySelectorAll('.relSpin').forEach(sp=>{ const t=sp.dataset.target; setRel(f,t,0); sp.value=0; });
  addScene('Cleared focus relationships for '+f+'.'); renderRelsLive();
};
document.getElementById('relRandAll').onclick=()=>{
  const names=preNames();
  for(let i=0;i<names.length;i++) for(let j=i+1;j<names.length;j++){
    const v = Math.floor(-2 + Math.random()*5);
    setRel(names[i], names[j], v);
  }
  renderRelEditorFor(relFocusSel.value || names[0]);
  addScene('Randomized relationships for all players.'); renderRelsLive();
};
document.getElementById('relClearAll').onclick=()=>{
  const names=preNames();
  for(let i=0;i<names.length;i++) for(let j=i+1;j<names.length;j++){ setRel(names[i], names[j], 0); }
  renderRelEditorFor(relFocusSel.value || names[0]);
  addScene('Cleared all relationships.'); renderRelsLive();
};

/* Displays */
function updateAlliances(){
  const box=document.getElementById('alliancesList');
  const labels = (SEASON.preset==='duos'? ['A','B','C','D','E','F'] : SEASON.preset==='loners'? ['A','B','C'] : ['A','B','C','D']);
  alliances={}; labels.forEach(k=>alliances[k]=[]);
  const sh=shuffle(players);
  if(SEASON.preset==='duos'){ for(let i=0;i<sh.length;i+=2){ alliances[labels[(i/2)%labels.length]].push(sh[i], sh[i+1]); } }
  else if(SEASON.preset==='loners'){ for(let i=0;i<sh.length;i++){ alliances[labels[i%labels.length]].push(sh[i]); } }
  else { for(let i=0;i<sh.length;i++){ alliances[labels[i%labels.length]].push(sh[i]); if(SEASON.preset==='fluid' && Math.random()<0.18){ const other=labels[Math.floor(Math.random()*labels.length)]; if(!alliances[other].includes(sh[i])) alliances[other].push(sh[i]); } } }
  box.innerHTML = Object.entries(alliances).map(([n,mem])=>`<div><b>${n}</b>: ${mem.join(', ')}</div>`).join('');
}
function updateProgress(){
  const chart=document.getElementById('progressChart');
  const everyone=players.concat(eliminated.filter(p=>!players.includes(p)));
  chart.innerHTML = `<table><tr><th>Player</th><th>P1</th><th>P2</th><th>Final</th><th>W</th><th>L</th></tr>${
    everyone.map(p=>{
      const p1=keys[p]?.includes('P1')?'✔':'—', p2=keys[p]?.includes('P2')?'✔':'—', pf=(finalists.includes(p)?'✔':'—');
      return `<tr><td>${p}</td><td>${p1}</td><td>${p2}</td><td>${pf}</td><td>${wins[p]||0}</td><td>${losses[p]||0}</td></tr>`;
    }).join('')
  }</table>`;
}
function renderRelsLive(){
  const wrap=document.getElementById('relsLive'); if(!players.length){ wrap.innerHTML=''; return; }
  const pairs=[], seen={};
  for(let i=0;i<players.length;i++)for(let j=0;j<players.length;j++){
    const a=players[i], b=players[j]; if(a===b) continue; const k=[a,b].sort().join('|'); if(seen[k]) continue; seen[k]=1;
    pairs.push({a,b,v:getRel(a,b)});
  }
  pairs.sort((x,y)=>Math.abs(y.v)-Math.abs(x.v));
  const bonds=pairs.filter(p=>p.v>0).slice(0,5), feuds=pairs.filter(p=>p.v<0).slice(0,5);
  wrap.innerHTML = `<div><strong>Bonds</strong><br/>${bonds.length?bonds.map(p=>`${p.a} ↔ ${p.b} (+${p.v})`).join('<br/>'):'<span class="hint">None</span>'}
    <hr style="border-color:var(--border)"><strong>Tensions</strong><br/>${feuds.length?feuds.map(p=>`${p.a} ↔ ${p.b} (${p.v})`).join('<br/>'):'<span class="hint">None</span>'}</div>`;
}

/* Voting Matrix */
function addVoteColumn(label, voters, pairs, result, lockUser){
  const values={}; voters.forEach(v=>values[v]='—'); eliminated.forEach(v=>{ if(values[v]==null) values[v]='—'; });
  pairs.forEach(([v,to])=> values[v]=to);
  if(lockUser) values[lockUser]='LOCKPICK';
  voteColumns.push({label,values,result});
  renderMasterVoteTable();
}
function renderMasterVoteTable(){
  const wrap=document.getElementById('votingMatrix');
  let html='<div style="overflow:auto"><table><thead><tr><th>Voter</th>';
  voteColumns.forEach(c=> html+=`<th>${c.label}</th>`); html+='</tr></thead><tbody>';
  const active=players.slice(), p3=eliminated.filter(n=>getElimPhase(n)===3), p2=eliminated.filter(n=>getElimPhase(n)===2), p1=eliminated.filter(n=>getElimPhase(n)===1);
  const row=(name)=>{ html+=`<tr><td>${name}</td>`; voteColumns.forEach(c=> html+=`<td>${c.values[name]||'—'}</td>`); html+='</tr>'; };
  active.forEach(row); p3.forEach(row); p2.forEach(row); p1.forEach(row);
  html+='<tr><th>Result</th>'; voteColumns.forEach(c=> html+=`<th>${c.result||''}</th>`); html+='</tr></tbody></table></div>';
  wrap.innerHTML=html;
}

/* Jury Matrix */
function displayJuryMatrix(matrix){
  const area=document.getElementById('juryMatrix');
  if(!finalists.length){ area.innerHTML='<div class="hint">No finalists yet.</div>'; return; }
  let html = `<div style="overflow:auto"><table><tr><th>Juror</th>`;
  finalists.forEach(f => html += `<th>${f}</th>`);
  html += `<th>Total</th></tr>`;
  for(const juror in matrix){
    html += `<tr><td>${juror}</td>`;
    let sum=0; finalists.forEach(f => { const v=matrix[juror][f]||0; html += `<td>${v}</td>`; sum+=v; });
    html += `<td>${sum}</td></tr>`;
  }
  html += `</table></div>`;
  area.innerHTML = html;
}

/* Voting & tally (with social + relationships) */
function simulateVote(voters, eligible){
  const out=[];
  voters.forEach(v=>{
    const choices=eligible.filter(p=>p!==v);
    const al=choices.filter(c=>inAlliance(v,c));
    const prioritize = al.length>0 && Math.random()<(ALLY_PREFERENCE_RATE + (SEASON.preset==='loyal'?0.2:(SEASON.preset==='fluid'?0.15:0)));
    const pool = prioritize? al : choices;
    const baseAlpha = prioritize? ALPHA_SOCIAL : 0.5*ALPHA_SOCIAL;
    const pick = weighted(pool, c=>{
      const s=(stats[c]?.social||8);
      const j=VOTE_JITTER_MIN + Math.random()*(VOTE_JITTER_MAX - VOTE_JITTER_MIN);
      return Math.pow(s,baseAlpha)*j*relFactor(v,c);
    });
    if(pick){ out.push([v,pick]); votesGiven[v]=(votesGiven[v]||0)+1; votesReceived[pick]=(votesReceived[pick]||0)+1; }
  });
  return out;
}
function tally(votePairs, eligible){
  const counts={}; eligible.forEach(p=>counts[p]=0);
  votePairs.forEach(([_,votee])=>{ if(counts[votee]!=null) counts[votee]++; });
  const max=Math.max(...Object.values(counts)); const tied=Object.keys(counts).filter(p=>counts[p]===max);
  return [tied[0], tied, counts];
}

/* Social Events */
function triggerSocialEvents(tag){
  if(!players.length) return;
  const num = Math.floor(Math.random()*3);
  for(let k=0;k<num;k++){
    const a = players[Math.floor(Math.random()*players.length)];
    let b = players[Math.floor(Math.random()*players.length)];
    if(a===b) continue;
    const ev = weighted(EVENT_LIBRARY, e=>e.w);
    const delta = (ev.type==='bond')? +1 : -1;
    setRel(a,b, clamp(getRel(a,b)+delta,-5,5));
    addScene(`Event • ${tag}: ${ev.text(a,b)}`);
  }
  renderRelsLive();
}

/* Relationship ripple helpers */
function postVoteRelChanges(winner, group, votePairs){
  const bumps=[], drops=[];
  const targetedBy = votePairs.filter(([_,to])=>to===winner).map(([v,_])=>v);
  targetedBy.forEach(v=>{ if(inAlliance(v,winner)){ setRel(v,winner, clamp(getRel(v,winner)+1,-5,5)); bumps.push(`${v}→${winner} +1 (alliance support)`); }});
  group.filter(p=>p!==winner).forEach(p=>{ if(!inAlliance(p,winner)){ setRel(p,winner, clamp(getRel(p,winner)-1,-5,5)); drops.push(`${p}→${winner} -1 (resentment)`); }});
  renderRelsLive();
  addScene((!bumps.length&&!drops.length)?'No noticeable post‑vote ripples.'
    :`Post‑vote ripples — Bonds: ${bumps.join(' • ')||'—'} | Tensions: ${drops.join(' • ')||'—'}`);
}
function postPickRelChanges(picker,picks,hadAllyOption){
  const bumps=[], drops=[];
  picks.forEach(o=>{
    if(inAlliance(picker,o)){ setRel(picker,o, clamp(getRel(picker,o)+1,-5,5)); bumps.push(`${picker}→${o} +1 (ally)`); }
    else { setRel(picker,o, clamp(getRel(picker,o)-1,-5,5)); drops.push(`${picker}→${o} -1 (target)`); }
  });
  if(hadAllyOption && picks.every(o=>!inAlliance(picker,o))){
    const allies = players.filter(p=>p!==picker && inAlliance(picker,p));
    allies.forEach(a=> setRel(picker,a, clamp(getRel(picker,a)-1,-5,5)));
    if(allies.length) drops.push(`${picker}→allies (${allies.join(', ')}) -1 (snub)`);
  }
  renderRelsLive();
  addScene((!bumps.length&&!drops.length)?'No noticeable post‑pick ripples.'
    :`Post‑pick ripples — Bonds: ${bumps.join(' • ')||'—'} | Tensions: ${drops.join(' • ')||'—'}`);
}

/* Jury Keys: concentrated but close */
function distributeJuryKeys(finalists, jury, finalistKeys){
  const jm={}; jury.forEach(j=>{ jm[j.name]={}; finalists.forEach(f=>jm[j.name][f]=0); });
  const softmax=(obj,t=1)=>{ const vals=finalists.map(f=>obj[f]/t); const m=Math.max(...vals);
    const exps=vals.map(v=>Math.exp(v-m)); const Z=exps.reduce((a,b)=>a+b,0); const p={}; finalists.forEach((f,i)=>p[f]=exps[i]/Z); return p; };

  jury.forEach(j=>{
    const cap = (j.phase===1?1:(j.phase===2?2:3)); // Alt: P3 losers give 3 each
    const base={}; finalists.forEach(f=>{
      const allianceBoost = 1.0; // could wire alliance/jury memory here
      const socialBoost = 0.12*(stats[f]?.social||8);
      const jitter=0.9+Math.random()*0.2;
      base[f]=allianceBoost*(1+socialBoost)*jitter;
    });
    const probs=softmax(base,1);
    const ranked=finalists.slice().sort((a,b)=>probs[b]-probs[a]);
    const top=ranked[0], second=ranked[1];

    let pAll = (j.phase===3 ? 0.72 : j.phase===2 ? 0.62 : 0.5); // more concentration late
    if (probs[second]>0 && (probs[top]/probs[second]) < 1.1) pAll -= 0.15; // close race → more splitting
    pAll = clamp(pAll, 0.25, 0.85);

    if(Math.random()<pAll){
      jm[j.name][top]+=cap; finalistKeys[top]+=cap;
    }else{
      for(let k=0;k<cap;k++){
        const pNow=softmax(base,1.05);
        const pick=weighted(finalists,f=>pNow[f]);
        jm[j.name][pick]+=1; finalistKeys[pick]+=1; base[pick]*=0.94;
      }
    }
  });
  return jm;
}

/* ================= Driver ================= */
function progressGame(){
  updateAlliances(); updateProgress(); renderRelsLive(); renderEpisodeNav();
  if(phase===1) return runPhase1();
  if(phase===2) return runPhase2();
  if(phase===3) return runPhase3();
  if(phase===4) return runFinale();
}

/* ===== Phase 1 (Alt) ===== */
let p1_lastChanceDone=false;
function runPhase1(){
  const p1Count=Object.values(keys).reduce((a,k)=>a+(k.includes?.('P1')?1:0),0);

  // After 8 P1 keys → do the last‑chance vote once, then proceed to P2
  if(p1Count>=8){
    if(!p1_lastChanceDone){
      ensureEpisode();
      const group = players.filter(p=>!keys[p].includes('P1'));
      const voters = group.slice(); // only these 5 vote & are targets
      addScene(`Phase 1 — Last Chance Vote among: ${group.join(', ')}`);
      const v1 = simulateVote(voters, group);
      let [w,tied] = tally(v1, group);
      addVoteColumn(`P1 R5 (vote)`, voters, v1, tied.length===1?w:('TIE:'+tied.join('=')), null);
      // With 5 voters, revote among tied (tied sit out) is odd → should break
      while(tied.length>1){
        const revVoters = voters.filter(v=>!tied.includes(v));
        const rev = simulateVote(revVoters, tied);
        [w,tied] = tally(rev, tied);
        addVoteColumn(`P1 R5 (revote)`, revVoters, rev, tied.length===1?w:('TIE:'+tied.join('=')), null);
        if(tied.length>1) break; // extremely rare; we’ll fall through
      }
      const winner = (tied.length===1? w : tied[Math.floor(Math.random()*tied.length)]);
      addScene(`${winner} survives and receives a Phase 1 key.`);
      keys[winner].push('P1'); keysEarned[winner].P1=(keysEarned[winner].P1||0)+1; wins[winner]=(wins[winner]||0)+1;
      const outs = group.filter(p=>p!==winner);
      outs.forEach(p=>{ eliminated.push(p); jury.push({name:p,phase:1}); });
      players = players.filter(p=>!outs.includes(p));
      p1_lastChanceDone=true; updateProgress(); return;
    } else {
      addScene('Phase 1 complete. Advancing: '+players.join(', '));
      phase=2; round=1; return;
    }
  }

  // R1–R4
  ensureEpisode();
  if(p1_step===0){
    const noKey=players.filter(p=>!keys[p].includes('P1'));
    p1_drawn = (round===4) ? (noKey.length>=7? noKey.slice(0,7) : shuffle(noKey).slice(0,Math.min(6,noKey.length)))
                           : shuffle(noKey).slice(0, Math.min(6, noKey.length));
    addScene(`Phase 1 — Round ${round}: Drawn → ${p1_drawn.join(', ')}`);

    triggerSocialEvents('around the draw');

    if(!SEASON.noLockpick && !lockpickFound && Math.random()<0.2 && p1_drawn.length){
      lockpickHolder=p1_drawn[Math.floor(Math.random()*p1_drawn.length)]; lockpickFound=true; addScene(`${lockpickHolder} discovers the LOCKPICK.`);
    }

    // All 13 vote among drawn
    p1_votePairs = simulateVote(players, p1_drawn);
    let [winner, tied] = tally(p1_votePairs, p1_drawn);

    let lockUser=null;
    if(!SEASON.noLockpick && lockpickHolder && !lockpickUsed && p1_drawn.includes(lockpickHolder)){
      if(Math.random()<0.18){ winner=lockpickHolder; lockUser=lockpickHolder; lockpickUsed=true; addScene(`${lockpickHolder} overrides with LOCKPICK!`); }
    }

    if(tied.length===1){
      // clear vote winner gets vote key and sits out of challenge
      p1_voteWinner=winner;
      addVoteColumn(`P1 R${round} (vote)`, players, p1_votePairs, winner, lockUser);
      addScene(`${winner} wins the Vote Key and sits out the challenge.`);
      keys[winner].push('P1'); keysEarned[winner].P1=(keysEarned[winner].P1||0)+1; wins[winner]=(wins[winner]||0)+1;

      // challenge among other drawn without P1
      const chall = p1_drawn.filter(p=>p!==winner && !keys[p].includes('P1'));
      if(chall.length){
        const cw=weighted(chall, x=>(stats[x]?.challenge||8)*(0.85+Math.random()*0.3));
        addScene(`Challenge: ${chall.join(', ')} → ${cw} wins the Challenge Key.`);
        keys[cw].push('P1'); keysEarned[cw].P1=(keysEarned[cw].P1||0)+1; wins[cw]=(wins[cw]||0)+1;
        chall.filter(x=>x!==cw).forEach(l=>losses[l]=(losses[l]||0)+1);
      } else addScene('No challenge key this round.');

      postVoteRelChanges(p1_voteWinner, p1_drawn, p1_votePairs);
      round++; updateProgress(); p1_step=0; return;
    } else {
      // tie → revote; tied do not vote
      p1_tiedGroup=tied.slice();
      const revVoters = players.filter(v=>!p1_tiedGroup.includes(v));
      const revote = simulateVote(revVoters, p1_tiedGroup);
      const [rw, tied2] = tally(revote, p1_tiedGroup);
      addVoteColumn(`P1 R${round} (vote)`, players, p1_votePairs, 'TIE:'+tied.join('='), null);
      addVoteColumn(`P1 R${round} (revote)`, revVoters, revote, tied2.length===1?rw:('TIE:'+tied2.join('=')), null);

      if(tied2.length===1){
        // revote breaks
        p1_voteWinner=rw; addScene(`Revote breaks: ${rw} takes the Vote Key and sits out.`);
        keys[rw].push('P1'); keysEarned[rw].P1=(keysEarned[rw].P1||0)+1; wins[rw]=(wins[rw]||0)+1;

        const chall = p1_drawn.filter(p=>p!==rw && !keys[p].includes('P1'));
        if(chall.length){
          const cw=weighted(chall, x=>(stats[x]?.challenge||8)*(0.85+Math.random()*0.3));
          addScene(`Challenge: ${chall.join(', ')} → ${cw} wins the Challenge Key.`);
          keys[cw].push('P1'); keysEarned[cw].P1=(keysEarned[cw].P1||0)+1; wins[cw]=(wins[cw]||0)+1;
          chall.filter(x=>x!==cw).forEach(l=>losses[l]=(losses[l]||0)+1);
        } else addScene('No challenge key this round.');

        postVoteRelChanges(p1_voteWinner, p1_drawn, p1_votePairs);
        round++; updateProgress(); p1_step=0; return;
      } else {
        // still tied → ALL drawn (6 or 7) run challenge; winner keeps challenge key AND must give vote key to someone from tied group (not themselves)
        const challengers = p1_drawn.slice();
        const cw=weighted(challengers, x=>(stats[x]?.challenge||8)*(0.85+Math.random()*0.3));
        addScene(`Revote still tied → Full challenge among ${challengers.length}. ${cw} wins Challenge Key and must assign Vote Key to one of [${p1_tiedGroup.join(', ')}].`);
        keys[cw].push('P1'); keysEarned[cw].P1=(keysEarned[cw].P1||0)+1; wins[cw]=(wins[cw]||0)+1;
        challengers.filter(x=>x!==cw).forEach(l=>losses[l]=(losses[l]||0)+1);

        let candidates = p1_tiedGroup.filter(x=>x!==cw);
        if(candidates.length===0) candidates = p1_tiedGroup.slice(); // rare edge if cw was only tied
        const give = weighted(candidates, c=> (stats[c]?.social||8) * (0.9+Math.random()*0.2) );
        keys[give].push('P1'); keysEarned[give].P1=(keysEarned[give].P1||0)+1; wins[give]=(wins[give]||0)+1;
        addScene(`${cw} awards the Vote Key to ${give}.`);

        postVoteRelChanges(give, p1_drawn, p1_votePairs);
        round++; updateProgress(); p1_step=0; return;
      }
    }
  }
}

/* ===== Phase 2 (Alt) ===== */
let p2_lastChanceDone=false;
function runPhase2(){
  const p2Count=Object.values(keys).reduce((a,k)=>a+(k.includes?.('P2')?1:0),0);
  if(p2Count>=4){
    if(!p2_lastChanceDone){
      ensureEpisode();
      const group = players.filter(p=>!keys[p].includes('P2'));
      addScene(`Phase 2 — Last Chance Challenge among: ${group.join(', ')}`);
      const w = weighted(group, x=>(stats[x]?.challenge||8)*(0.85+Math.random()*0.3));
      keys[w].push('P2'); keysEarned[w].P2=(keysEarned[w].P2||0)+1; wins[w]=(wins[w]||0)+1;
      group.filter(x=>x!==w).forEach(l=>{ eliminated.push(l); jury.push({name:l,phase:2}); losses[l]=(losses[l]||0)+1; });
      players = players.filter(p=>!group.includes(p) || p===w);
      addScene(`${w} secures the final Phase 2 key. Others join the jury (P2).`);
      p2_lastChanceDone=true; updateProgress(); return;
    } else {
      addScene('Phase 2 complete. Advancing: '+players.join(', '));
      phase=3; round=1; return;
    }
  }

  ensureEpisode();
  if(p2_step===0){
    addScene(`Phase 2 — Round ${round}`);
    p2_noP2 = players.filter(p=>!keys[p].includes('P2'));
    if(p2_noP2.length<2){ addScene('Not enough no‑P2 players; jumping to last‑chance.'); p2_lastChanceDone=false; return; }

    p2_votePairs = simulateVote(players, p2_noP2);
    let [vw, tied] = tally(p2_votePairs, p2_noP2);
    addVoteColumn(`P2 R${round} (vote)`, players, p2_votePairs, tied.length===1?vw:('TIE:'+tied.join('=')), null);

    if(tied.length===1){
      p2_voteWinner=vw; addScene(`${vw} wins the vote and must pick a no‑P2 opponent for the duel.`);
      const cand=p2_noP2.filter(p=>p!==vw);
      const opp = weighted(cand, c=> Math.pow(1/Math.max(1,(stats[c]?.challenge||8)),GAMMA_BEATABLE));
      addScene(`${vw} chooses ${opp} (beatable / key‑containment).`);
      const w = (Math.random()<duelWinProb(vw,opp))? vw : opp;
      const l = (w===vw?opp:vw);
      keys[w].push('P2'); keysEarned[w].P2=(keysEarned[w].P2||0)+1; wins[w]=(wins[w]||0)+1; losses[l]=(losses[l]||0)+1;
      addScene(`${w} wins the duel and earns a P2 key.`);
      round++; updateProgress(); return;
    }

    // Tie handling
    if(tied.length===2){
      const revVoters = players.filter(v=>!tied.includes(v));
      const rev = simulateVote(revVoters, tied);
      const [w2, tied2] = tally(rev, tied);
      addVoteColumn(`P2 R${round} (revote)`, revVoters, rev, tied2.length===1?w2:('TIE:'+tied2.join('=')), null);
      if(tied2.length===1){
        p2_voteWinner=w2; addScene(`Revote breaks: ${w2} must pick an opponent.`);
        const cand=p2_noP2.filter(p=>p!==w2);
        const opp = weighted(cand, c=> Math.pow(1/Math.max(1,(stats[c]?.challenge||8)),GAMMA_BEATABLE));
        const w = (Math.random()<duelWinProb(w2,opp))? w2 : opp;
        const l = (w===w2?opp:w2);
        keys[w].push('P2'); keysEarned[w].P2=(keysEarned[w].P2||0)+1; wins[w]=(wins[w]||0)+1; losses[l]=(losses[l]||0)+1;
        addScene(`${w} wins the duel and earns a P2 key.`);
        round++; updateProgress(); return;
      } else {
        // stalemate → duel between the two
        const a=tied[0], b=tied[1];
        const w = (Math.random()<duelWinProb(a,b))? a : b;
        const l = (w===a?b:a);
        keys[w].push('P2'); keysEarned[w].P2=(keysEarned[w].P2||0)+1; wins[w]=(wins[w]||0)+1; losses[l]=(losses[l]||0)+1;
        addScene(`Revote stalemate → Tiebreak duel: ${a} vs ${b} — ${w} earns the P2 key.`);
        round++; updateProgress(); return;
      }
    }

    if(tied.length===3){
      addScene(`3‑way tie → Triple Duel among ${tied.join(', ')}.`);
      const w = weighted(tied, x=>(stats[x]?.challenge||8)*(0.85+Math.random()*0.3));
      keys[w].push('P2'); keysEarned[w].P2=(keysEarned[w].P2||0)+1; wins[w]=(wins[w]||0)+1;
      tied.filter(x=>x!==w).forEach(l=>losses[l]=(losses[l]||0)+1);
      addScene(`${w} wins the triple duel and earns a P2 key.`);
      round++; updateProgress(); return;
    }

    if(tied.length===4){
      // breaker = the one person who didn’t vote for any of the four
      const tiedSet=new Set(tied);
      const nonVoters = players.filter(v=>{
        const pick = (p2_votePairs.find(([vv,_])=>vv===v)||[])[1];
        return !tiedSet.has(pick);
      });
      if(nonVoters.length){
        const breaker = weighted(nonVoters, c=> (stats[c]?.social||8)*(0.9+Math.random()*0.2));
        const pick = weighted(tied, c=> (stats[c]?.social||8)*(0.9+Math.random()*0.2));
        addScene(`4‑way tie → ${breaker} breaks the tie and selects ${pick}.`);
        // pick chooses opponent and duel
        const cand=p2_noP2.filter(p=>p!==pick);
        const opp = cand.length? weighted(cand, c=> Math.pow(1/Math.max(1,(stats[c]?.challenge||8)),GAMMA_BEATABLE)) : null;
        if(opp){
          const w = (Math.random()<duelWinProb(pick,opp))? pick : opp;
          const l = (w===pick?opp:pick);
          keys[w].push('P2'); keysEarned[w].P2=(keysEarned[w].P2||0)+1; wins[w]=(wins[w]||0)+1; losses[l]=(losses[l]||0)+1;
          addScene(`${w} wins the duel and earns a P2 key.`);
        } else { keys[pick].push('P2'); keysEarned[pick].P2=(keysEarned[pick].P2||0)+1; wins[pick]=(wins[pick]||0)+1; addScene(`${pick} receives P2 key (no opponent available).`); }
        round++; updateProgress(); return;
      } else {
        // fallback: multi-duel
        const w = weighted(tied, x=>(stats[x]?.challenge||8)*(0.85+Math.random()*0.3));
        keys[w].push('P2'); keysEarned[w].P2=(keysEarned[w].P2||0)+1; wins[w]=(wins[w]||0)+1;
        tied.filter(x=>x!==w).forEach(l=>losses[l]=(losses[l]||0)+1);
        addScene(`Edge case 4‑tie with no breaker → multi‑duel; ${w} wins P2 key.`);
        round++; updateProgress(); return;
      }
    }

    // large tie → multi-duel
    const w = weighted(tied, x=>(stats[x]?.challenge||8)*(0.85+Math.random()*0.3));
    keys[w].push('P2'); keysEarned[w].P2=(keysEarned[w].P2||0)+1; wins[w]=(wins[w]||0)+1;
    tied.filter(x=>x!==w).forEach(l=>losses[l]=(losses[l]||0)+1);
    addScene(`Large tie → multi‑duel; ${w} wins P2 key.`);
    round++; updateProgress(); return;
  }
}

/* ===== Phase 3 (Alt) ===== */
function runPhase3(){
  ensureEpisode();
  if(p3_step===0){
    addScene('Phase 3 — Final Cut vote.');
    const raw=simulateVote(players, players);
    const pairs=raw.map(([v,t])=> v===t? [v, weighted(players.filter(p=>p!==v), c=> (stats[c]?.social||8)*(0.9+Math.random()*0.2))] : [v,t]);
    let [vw, tied] = tally(pairs, players);
    addVoteColumn('P3 R1', players, pairs, tied.length===1?vw:('TIE:'+tied.join('=')), null);

    if(tied.length===1){
      const voteWinner=vw; addScene(`${voteWinner} wins and becomes a finalist.`);
      const avail = players.filter(p=>p!==voteWinner);
      const partner = weighted(avail, c=> (stats[c]?.social||8)*relFactor(voteWinner,c));
      addScene(`${voteWinner} selects ${partner} to join them in the finale.`);
      finalists=[voteWinner, partner];
      const bottom3 = players.filter(p=>!finalists.includes(p));
      const w = weighted(bottom3, x=>(stats[x]?.challenge||8)*(0.85+Math.random()*0.3));
      const outs = bottom3.filter(x=>x!==w);
      addScene(`Bottom‑3 challenge: ${bottom3.join(', ')} → ${w} advances; ${outs.join(', ')} join the jury (P3).`);
      finalists.push(w);
      outs.forEach(o=>{ eliminated.push(o); jury.push({name:o,phase:3}); losses[o]=(losses[o]||0)+1; });
      phase=4; round=1; updateProgress(); return;
    } else if(tied.length===2){
      const safe=tied.slice(); addScene(`P3 tie: ${safe.join(' & ')} are safe.`);
      // pick partner among the two safe
      const picker = weighted(safe, c=> (stats[c]?.social||8)*(0.9+Math.random()*0.2));
      const partner = safe.find(x=>x!==picker) || safe[0];
      finalists=[picker, partner];
      const bottom3 = players.filter(p=>!finalists.includes(p));
      const w = weighted(bottom3, x=>(stats[x]?.challenge||8)*(0.85+Math.random()*0.3));
      const outs = bottom3.filter(x=>x!==w);
      addScene(`Bottom‑3 challenge: ${bottom3.join(', ')} → ${w} advances; ${outs.join(', ')} join the jury (P3).`);
      finalists.push(w);
      outs.forEach(o=>{ eliminated.push(o); jury.push({name:o,phase:3}); losses[o]=(losses[o]||0)+1; });
      phase=4; round=1; updateProgress(); return;
    } else {
      // rare: take first two as safe
      const safe=tied.slice(0,2); finalists=safe.slice();
      const bottom3 = players.filter(p=>!finalists.includes(p));
      const w = weighted(bottom3, x=>(stats[x]?.challenge||8)*(0.85+Math.random()*0.3));
      const outs = bottom3.filter(x=>x!==w);
      addScene(`Rare multi‑tie: ${safe.join(' & ')} safe; bottom‑3 challenge → ${w} advances.`);
      finalists.push(w);
      outs.forEach(o=>{ eliminated.push(o); jury.push({name:o,phase:3}); losses[o]=(losses[o]||0)+1; });
      phase=4; round=1; updateProgress(); return;
    }
  }
}

/* ===== Finale (Alt) ===== */
function runFinale(){
  ensureEpisode();
  if(!finaleState){
    if(finalists.length!==3){ addScene('Finale error: not enough finalists.'); return; }
    const finalistKeys={}; finalists.forEach(f=> finalistKeys[f]=3); // 3 base keys
    // Distribute 27 jury keys (P1:1 each, P2:2, P3:3)
    const jm=distributeJuryKeys(finalists, jury, finalistKeys); displayJuryMatrix(jm);

    // Vault choices (unique) near each finalist's expected support
    const pool=[]; for(let i=3;i<=22;i++) pool.push(i);
    const expect={}; finalists.forEach(f=> expect[f]=Math.round(6 + (stats[f]?.social||8)*0.6));
    const chosen=pickVaults(expect, pool);
    finaleState={finalistKeys, juryMatrix:jm, chosenVaults:chosen, winner:null, step:0};
    addScene('Jury awards keys. Next: vault choices & reveal.');
    return;
  }

  if(finaleState.step===0){
    const line = finalists.map(f=> `${f}: vault ${finaleState.chosenVaults[f]} (has ${finaleState.finalistKeys[f]} keys)`).join(' | ');
    addScene(line);
    // Determine if anyone opens
    const sorted = finalists.map(n=>({name:n,keys:finaleState.finalistKeys[n],vault:finaleState.chosenVaults[n]})).sort((a,b)=>b.vault-a.vault);
    const opener = sorted.find(r=>r.keys>=r.vault) || null;
    finaleState.winner = opener? opener.name : null; finaleState.step=1; return;
  }

  if(finaleState.step===1){
    if(finaleState.winner){
      addScene(`${finaleState.winner} opens the ${finaleState.chosenVaults[finaleState.winner]}-key vault with ${finaleState.finalistKeys[finaleState.winner]} keys — Champion!`);
    } else {
      addScene('No vault opens → Final‑3 challenge for the season!');
      const w = weighted(finalists, x=>(stats[x]?.challenge||8)*(0.85+Math.random()*0.3));
      addScene(`${w} wins the final challenge and claims the 3‑key vault — Champion!`);
    }
    nextBtn.textContent='Simulate Again'; nextBtn.onclick=()=>location.reload();
    phase=5; // done
  }
}
function pickVaults(expect, pool){
  const avail=pool.slice(), picked={};
  Object.keys(expect).sort((a,b)=>expect[b]-expect[a]).forEach(f=>{
    let best=avail[0], bestDiff=1e9, idx=0;
    for(let i=0;i<avail.length;i++){ const v=avail[i], d=Math.abs(v-expect[f]); if(d<bestDiff){ bestDiff=d; best=v; idx=i; } }
    picked[f]=best; avail.splice(idx,1);
  });
  return picked;
}

/* ================= Start Season ================= */
function startSeason(){
  if(gameStarted) return;
  const input=document.getElementById('playerInput').value.trim().split('\n').map(s=>s.trim()).filter(Boolean);
  if(input.length!==13){ alert('Please enter exactly 13 players.'); return; }

  players=input.slice(); initialOrder=input.slice();
  players.forEach(p=>{
    keys[p]=[]; stats[p]=stats[p]||{social:8,challenge:8}; rel[p]=rel[p]||{};
    cast[p]=cast[p]||{photo:'',color:'#7aa2ff'};
    wins[p]=0; losses[p]=0; keysEarned[p]={P1:0,P2:0}; votesGiven[p]=0; votesReceived[p]=0; juryKeysReceived[p]=0;
  });

  gameStarted=true;
  startBtn.style.display='none'; nextBtn.style.display='inline-block';
  document.getElementById('seasonControls').style.display='none';
  document.getElementById('castBox').style.display='none';
  document.getElementById('preseasonBox').style.display='none';

  generateAlliancesPreset();
  phase=1; round=1;
  ensureEpisode();
  addScene('Season begins. Alt Vault rules in effect.');
  addScene('Alliances formed: '+Object.entries(alliances).map(([k,v])=>`${k}: ${v.join(', ')}`).join(' | '));
}

/* Alliances */
function generateAlliancesPreset(){
  const labels=(SEASON.preset==='duos'? ['A','B','C','D','E','F'] : SEASON.preset==='loners'? ['A','B','C'] : ['A','B','C','D']);
  alliances={}; labels.forEach(k=>alliances[k]=[]);
  const sh=shuffle(players);
  if(SEASON.preset==='duos'){ for(let i=0;i<sh.length;i+=2){ alliances[labels[(i/2)%labels.length]].push(sh[i], sh[i+1]); } }
  else if(SEASON.preset==='loners'){ for(let i=0;i<sh.length;i++){ alliances[labels[i%labels.length]].push(sh[i]); } }
  else { for(let i=0;i<sh.length;i++){ alliances[labels[i%labels.length]].push(sh[i]); if(SEASON.preset==='fluid' && Math.random()<0.18){ const other=labels[Math.floor(Math.random()*labels.length)]; if(!alliances[other].includes(sh[i])) alliances[other].push(sh[i]); } } }
  updateAlliances();
}

/* Init preseason UIs */
buildCastGrid(); buildStatsTable(); buildRelFocusList(); renderEpisodeNav();
</script>
</body>
</html>