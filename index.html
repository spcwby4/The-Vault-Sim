<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Vault Simulator</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      gap: 20px;
      padding: 20px;
    }
    #left, #right {
      width: 50%;
    }
    textarea {
      width: 100%;
      height: 150px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 10px;
    }
    th, td {
      border: 1px solid #999;
      padding: 5px;
      text-align: center;
    }
    .eliminated {
      background-color: #fdd;
    }
    #log {
      margin-top: 10px;
      background: #eee;
      padding: 10px;
      height: 300px;
      overflow-y: auto;
    }
    #alliancesBox {
      background: #eef;
      padding: 10px;
      margin-top: 10px;
    }
    details {
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 5px;
    }
    summary {
      cursor: pointer;
      font-weight: bold;
    }
    details[open] {
      background: #f9f9f9;
    }
  </style>
</head>
<body>
  <div id="left">
    <h2>The Vault Simulator</h2>
    <textarea id="playerInput" placeholder="Enter 12 players, one per line"></textarea><br>
    <button id="startBtn" onclick="startGame()">Start Game</button>
    <button id="nextBtn" onclick="runRound()" style="display:none;">Run Next Round</button>
    <div id="log"></div>
    <div id="votingChart"></div>
  </div>

  <div id="right">
    <div id="alliancesBox"></div>
    <div id="progressTable"></div>
  </div>

<script>
let players = [];
let round = 1;
let phase = 1;
let finalists = [];
let eliminated = [];
let jury = [];
let votingChart = [];
let lockpickHolder = null;
let lockpickUsed = false;
const vaults = [3, 5, 7, 9, 11, 13, 15, 17, 19, 20, 21, 22];

function startGame() {
  const input = document.getElementById("playerInput").value.trim().split("\n").map(s => s.trim()).filter(Boolean);
  if (input.length !== 12) return alert("Enter exactly 12 players.");
  players = input.map(name => ({
    name, alliance: [], key1: false, key2: false, key3: false, totalKeys: 0, totalFinalKeys: 0, bonusKeys: 0, eliminated: false
  }));
  assignAlliances();
  updateAlliancesBox();
  updateTable();
  log(`Game started with 12 players.`);
  document.getElementById("startBtn").style.display = "none";
  document.getElementById("nextBtn").style.display = "inline";
}

function runRound() {
  if (phase === 1) return runPhase1();
  if (phase === 2) return runPhase2();
  if (phase === 3) return runPhase3();
  if (phase === 4) return runFinale();
}

function runPhase1() {
  const eligible = players.filter(p => !p.key1 && !p.eliminated);
  if (round > 4) {
    players.forEach(p => {
      if (!p.key1) {
        p.eliminated = true;
        eliminated.push(p);
      }
    });
    phase = 2; round = 1;
    return runRound();
  }

  const drawn = shuffle(eligible).slice(0, 4);
  log(`Phase 1 – Round ${round}`);
  log(`Drawn players: ${drawn.map(p => p.name).join(", ")}`);

  // Lockpick discovery
  if (!lockpickHolder && !lockpickUsed && Math.random() < 0.33) {
    lockpickHolder = drawn[Math.floor(Math.random() * drawn.length)];
    log(`${lockpickHolder.name} found the Lockpick!`);
  }

  // All players vote for one of the 4 drawn
  const votingDetails = [];
  const voteTally = {};
  const voters = players.filter(p => !p.eliminated);
  for (let v of voters) {
    const voteFor = pickAllyOrRandom(v, drawn);
    votingDetails.push({ voter: v.name, votee: voteFor.name });
    voteTally[voteFor.name] = (voteTally[voteFor.name] || 0) + 1;
  }

  let winnerName = Object.entries(voteTally).sort((a, b) => b[1] - a[1])[0][0];
  let voteWinner = drawn.find(p => p.name === winnerName);

  if (lockpickHolder && drawn.includes(lockpickHolder)) {
    voteWinner = lockpickHolder;
    log(`${voteWinner.name} uses the Lockpick to win the vote key.`);
    lockpickHolder = null;
    lockpickUsed = true;
  } else {
    log(`${voteWinner.name} wins the vote key.`);
  }

  voteWinner.key1 = true;
  voteWinner.totalKeys++;

  const challengers = drawn.filter(p => p !== voteWinner);
  const challengeWinner = challengers[Math.floor(Math.random() * challengers.length)];
  challengeWinner.key1 = true;
  challengeWinner.totalKeys++;
  log(`${challengeWinner.name} wins the challenge key.`);

  recordVotes(round, votingDetails, voteWinner.name, "Phase 1");
  round++;
  updateTable();
}
function runPhase2() {
  const active = players.filter(p => !p.eliminated && !p.key2);
  const keyholders = players.filter(p => p.key2);

  if (round > 4 || active.length === 0) {
    players.forEach(p => {
      if (!p.key2 && !p.eliminated) {
        p.eliminated = true;
        eliminated.push(p);
      }
    });
    phase = 3;
    round = 1;
    return runRound();
  }

  log(`Phase 2 – Round ${round}`);

  // Lockpick redrop chance
  if (!lockpickHolder && !lockpickUsed && Math.random() < 0.33) {
    const pool = players.filter(p => !p.key2 && !p.eliminated);
    if (pool.length > 0) {
      lockpickHolder = pool[Math.floor(Math.random() * pool.length)];
      log(`${lockpickHolder.name} discovered the Lockpick!`);
    }
  }

  const votingDetails = [];
  const voteTally = {};
  const voters = players.filter(p => !p.eliminated);
  const voteTargets = active;

  let voteWinner;
  if (lockpickHolder && active.includes(lockpickHolder)) {
    voteWinner = lockpickHolder;
    log(`${voteWinner.name} uses the Lockpick to win the vote.`);
    lockpickHolder = null;
    lockpickUsed = true;
  } else {
    for (let v of voters) {
      const voteFor = pickAllyOrRandom(v, voteTargets);
      votingDetails.push({ voter: v.name, votee: voteFor.name });
      voteTally[voteFor.name] = (voteTally[voteFor.name] || 0) + 1;
    }
    const winnerName = Object.entries(voteTally).sort((a, b) => b[1] - a[1])[0][0];
    voteWinner = active.find(p => p.name === winnerName);
    log(`${voteWinner.name} wins the vote.`);
  }

  // Vote winner picks opponent
  const opponents = active.filter(p => p !== voteWinner);
  const chosenOpponent = pickAllyOrRandom(voteWinner, opponents);
  log(`${voteWinner.name} chooses to duel ${chosenOpponent.name}.`);

  const duelWinner = Math.random() < 0.5 ? voteWinner : chosenOpponent;
  duelWinner.key2 = true;
  duelWinner.totalKeys++;
  log(`${duelWinner.name} wins the duel and earns the key.`);

  recordVotes(round, votingDetails, voteWinner.name, "Phase 2");
  round++;
  updateTable();
}

function runPhase3() {
  const active = players.filter(p => !p.eliminated && p.key1 && p.key2);
  if (active.length !== 4) {
    log("Error: Phase 3 requires 4 players.");
    return;
  }

  const votes = {};
  const votingDetails = [];

  for (let v of active) {
    const choices = active.filter(p => p.name !== v.name);
    const voteFor = pickAllyOrRandom(v, choices);
    votingDetails.push({ voter: v.name, votee: voteFor.name });
    votes[voteFor.name] = (votes[voteFor.name] || 0) + 1;
  }

  const sorted = Object.entries(votes).sort((a,b)=>b[1]-a[1]);
  let voteWinner;
  let pick, rest;

  if (sorted.length < 2 || sorted[0][1] > sorted[1][1]) {
    voteWinner = active.find(p => p.name === sorted[0][0]);
    pick = active.filter(p => p !== voteWinner);
    const ally = pickAllyOrRandom(voteWinner, pick);
    rest = pick.filter(p => p !== ally);
    const challengeWinner = rest[Math.floor(Math.random() * rest.length)];
    finalists = [voteWinner, ally, challengeWinner];
    log(`${voteWinner.name} brings ${ally.name} to the finale.`);
    log(`${challengeWinner.name} wins the final challenge.`);
  } else {
    const tied = sorted.filter(e => e[1] === sorted[0][1]).map(e => e[0]);
    const duelists = active.filter(p => tied.includes(p.name));
    const untied = active.filter(p => !tied.includes(p.name));
    const challengeWinner = duelists[Math.floor(Math.random() * duelists.length)];
    finalists = [...untied, challengeWinner];
    log(`${untied.map(p => p.name).join(" and ")} advance. ${challengeWinner.name} wins the duel for the final spot.`);
  }

  players.forEach(p => {
    if (!finalists.includes(p)) {
      p.eliminated = true;
      jury.push(p);
    } else {
      p.key3 = true;
    }
  });

  recordVotes(round, votingDetails, sorted[0][0], "Phase 3");

  phase = 4;
  round = 1;
  updateTable();
}

function runFinale() {
  const vaultSelections = [];

  for (let f of finalists) {
    let estimate = f.totalKeys + 3;
    let range = vaults.filter(v => v <= estimate + 2 && v >= estimate - 1 && !vaultSelections.includes(v));
    f.vault = range[Math.floor(Math.random() * range.length)] || 3;
    vaultSelections.push(f.vault);
    f.totalFinalKeys = 3;
    log(`${f.name} chooses to open the vault requiring ${f.vault} keys.`);
  }

  const weights = jury.map(j => j.key3 ? 4 : j.key2 ? 2 : 1);
  let totalWeight = weights.reduce((a, b) => a + b, 0);
  let keysLeft = 16;

  for (let i = 0; i < jury.length; i++) {
    let share = Math.round((weights[i] / totalWeight) * 16);
    share = Math.min(share, keysLeft);
    keysLeft -= share;
    const juror = jury[i];
    while (share-- > 0) {
      const recipient = pickAllyOrRandom(juror, finalists);
      recipient.bonusKeys++;
      recipient.totalFinalKeys++;
    }
  }

  for (let f of finalists) {
    log(`${f.name} ended with ${f.totalFinalKeys} total keys.`);
  }

  const unlocked = finalists.filter(f => f.totalFinalKeys >= f.vault);
  if (unlocked.length) {
    unlocked.sort((a,b)=>b.vault - a.vault);
    log(`${unlocked[0].name} unlocks the highest vault and wins!`);
  } else {
    const fallback = players.find(p => !p.eliminated && !finalists.includes(p));
    log(`No vaults opened. ${fallback ? fallback.name : finalists[0].name} wins by default.`);
  }

  phase = 5;
  generateVotingChart();
  updateTable();
}
function updateTable() {
  let html = "<h3>Progress Table</h3><table><tr><th>Name</th><th>Key 1</th><th>Key 2</th><th>Key 3</th><th>Total Keys</th><th>Final Keys</th><th>Vault</th></tr>";
  for (let p of players) {
    html += `<tr${p.eliminated ? ' class="eliminated"' : ''}><td>${p.name}</td><td>${p.key1 ? "✅" : ""}</td><td>${p.key2 ? "✅" : ""}</td><td>${p.key3 ? "✅" : ""}</td><td>${p.totalKeys}</td><td>${p.totalFinalKeys || ""}</td><td>${p.vault || ""}</td></tr>`;
  }
  html += "</table>";
  document.getElementById("progressTable").innerHTML = html;
}

function log(text) {
  document.getElementById("log").innerHTML += text + "<br>";
  document.getElementById("log").scrollTop = 9999;
}

function assignAlliances() {
  const a1 = shuffle(players).slice(0, 5);
  const a2 = shuffle(players).slice(0, 5);
  const a3 = shuffle(players).slice(0, 5);
  for (let p of players) {
    p.alliance = [];
    if (a1.includes(p)) p.alliance.push("A");
    if (a2.includes(p)) p.alliance.push("B");
    if (a3.includes(p)) p.alliance.push("C");
  }
}

function updateAlliancesBox() {
  let html = "<h3>Alliances</h3><ul>";
  for (let p of players) {
    html += `<li>${p.name}: ${p.alliance.join(", ") || "None"}</li>`;
  }
  html += "</ul>";
  document.getElementById("alliancesBox").innerHTML = html;
}

function recordVotes(roundNum, details, selected, phaseName) {
  votingChart.push({ roundNum, details, selected, phase: phaseName });
}

function generateVotingChart() {
  let html = '<h3>Voting Chart</h3>';
  votingChart.forEach(vote => {
    const tally = {};
    vote.details.forEach(d => {
      tally[d.votee] = (tally[d.votee] || 0) + 1;
    });
    const winner = vote.selected;
    html += `<details>
      <summary>${vote.phase} – Round ${vote.roundNum} (Winner: ${winner} ✅)</summary>
      <table>
        <tr><th>Voter</th><th>Voted For</th></tr>`;
    vote.details.forEach(d => {
      html += `<tr><td>${d.voter}</td><td>${d.votee}</td></tr>`;
    });
    html += `</table>
      <div><strong>Vote Totals:</strong> `;
    html += Object.entries(tally).map(([name, count]) => `${name}: ${count}`).join(' · ');
    html += `</div></details>`;
  });
  document.getElementById("votingChart").innerHTML = html;
}

function pickAllyOrRandom(player, options) {
  const allies = options.filter(p => p !== player && p.alliance.some(a => player.alliance.includes(a)));
  return allies.length ? allies[Math.floor(Math.random() * allies.length)] : options[Math.floor(Math.random() * options.length)];
}

function shuffle(arr) {
  return arr.map(a => [Math.random(), a]).sort().map(a => a[1]);
}
</script>
</body>
</html>