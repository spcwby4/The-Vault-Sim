<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Vault — ALT (13 Players, Full)</title>
<style>
  :root{--bg:#0f1115;--panel:#161a22;--panel2:#1c2130;--text:#e5e7eb;--sub:#aeb4c0;--border:#2b3340;--muted:#232836;--accent:#7aa2ff;--good:#6ee7b7;--warn:#fbbf24;--bad:#f87171}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  h1{margin:0;font-size:20px} h2{margin:0 0 8px;font-size:16px} h3{margin:0 0 6px;font-size:15px}
  textarea,button,input,select{width:100%;padding:12px;margin-top:8px;border-radius:10px;border:1px solid var(--border);background:var(--panel2);color:var(--text);font-size:16px}
  button{cursor:pointer} button:disabled{opacity:.6;cursor:not-allowed}
  .app{display:grid;grid-template-columns:1fr;gap:12px;padding:12px}
  @media(min-width:960px){.app{grid-template-columns:320px 1fr}}
  .box{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  pre{white-space:pre-wrap;background:#0b0d12;border:1px solid var(--border);border-radius:10px;padding:10px;min-height:180px;max-height:320px;overflow:auto}
  table{width:100%;border-collapse:collapse;font-size:14px}
  th,td{border:1px solid var(--border);padding:6px;text-align:center;white-space:nowrap}
  th{background:#1b2130}
  .chip{display:flex;align-items:center;gap:8px;border:1px solid var(--border);padding:6px 8px;border-radius:10px;margin:6px 0}
  .avatar{width:22px;height:22px;border-radius:6px;object-fit:cover;background:#2a3040;display:inline-flex;align-items:center;justify-content:center;font-size:11px}
  .hint{font-size:13px;color:var(--sub)}
  .count{font-size:13px;color:var(--sub);margin-top:4px}
</style>
</head>
<body>
<div class="app">
  <!-- Left / Controls -->
  <div class="box">
    <h1>ALT VAULT (13P) — Season Setup</h1>
    <label><b>Enter 13 Players (one per line)</b></label>
    <textarea id="playerInput" rows="13"></textarea>
    <div class="count" id="nameCount">0 / 13</div>
    <div class="row">
      <button id="startBtn" disabled>Start Season</button>
      <button id="nextBtn" style="display:none;">Next Scene ▶</button>
    </div>
    <div class="hint">Alt rules active: P1 (R1–R4 draw 6; R4 can be 7 from no‑key pool; R5 last‑chance vote). P2 (R1–R4 voting/duel with tie rules; R5 last‑chance challenge). P3 bottom‑3 challenge. Finale fallback: Final‑3 challenge.</div>
  </div>

  <!-- Right / Main -->
  <div class="box">
    <h2>Round Events (Scene Feed)</h2>
    <pre id="sceneFeed">(Ready) Fill names (or use defaults), then Start Season → Next Scene.</pre>
  </div>

  <div class="row">
    <div class="box" style="flex:1 1 320px">
      <h2>Cast Photos & Colors</h2>
      <div id="castGrid"></div>
    </div>
    <div class="box" style="flex:2 1 420px">
      <h2>Preseason: Stats & Relationships</h2>
      <div class="row">
        <div style="flex:1 1 260px">
          <h3>Player Stats</h3>
          <div id="statsTable"></div>
          <div class="row">
            <button id="presetBalanced">Balanced</button>
            <button id="presetSocial">Social‑heavy</button>
            <button id="presetChallenge">Challenge‑heavy</button>
            <button id="presetRandom">Randomize All</button>
            <button id="applyStats">Apply Stats</button>
          </div>
          <div class="hint">Range 1–15 (default 8/8). Hidden after Start.</div>
        </div>
        <div style="flex:1 1 260px">
          <h3>Relationships (−5…+5)</h3>
          <div class="row" style="align-items:center">
            <label>Focus</label>
            <select id="relFocus"></select>
          </div>
          <div id="relEditor" style="margin-top:6px"></div>
          <div class="row" style="margin-top:6px">
            <button id="relSave">Save (All)</button>
            <button id="relRandFocus">Randomize Focus</button>
            <button id="relClearFocus">Clear Focus</button>
            <button id="relRandAll">Randomize All</button>
            <button id="relClearAll">Clear All</button>
          </div>
          <div class="hint">Symmetric: setting A→B also sets B→A. Hidden after Start.</div>
        </div>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="box" style="flex:1 1 320px">
      <h2>Alliances</h2>
      <div id="alliancesList"></div>
    </div>
    <div class="box" style="flex:1 1 320px">
      <h2>Progress</h2>
      <div id="progressChart"></div>
    </div>
  </div>

  <div class="row">
    <div class="box" style="flex:1 1 320px">
      <h2>Voting Matrix</h2>
      <div id="votingMatrix"></div>
      <div class="hint">Order: Active → P3 elim → P2 elim → P1 elim.</div>
    </div>
    <div class="box" style="flex:1 1 320px">
      <h2>Relationships (Live)</h2>
      <div id="relsLive"></div>
    </div>
  </div>

  <div class="box">
    <h2>Jury Key Distribution</h2>
    <div id="juryMatrix"></div>
  </div>
</div>

<script>
/* ===================== State ===================== */
let players=[], initialOrder=[], phase=1, round=1, gameStarted=false;
let alliances={}, keys={}, jury=[], finalists=[], eliminated=[];
let stats={}, rel={}, cast={};
let voteColumns=[], wins={}, losses={}, keysEarned={}, votesGiven={}, votesReceived={}, juryKeysReceived={};
let lockpickFound=false, lockpickUsed=false, lockpickHolder=null;
let episodes=[], currentEpisode=null, sceneQueue=[];

/* ===================== Tunables ===================== */
const ALPHA_SOCIAL=0.65, VOTE_JITTER_MIN=0.8, VOTE_JITTER_MAX=1.2, ALLY_PREFERENCE_RATE=0.6;
const REL_SCALE=0.08, REL_MIN_FACTOR=0.3, LOGIT_K=0.7, WIN_CLAMP_LO=0.15, WIN_CLAMP_HI=0.85;

/* ===================== Helpers ===================== */
const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
const shuffle=a=>a.slice().sort(()=>Math.random()-0.5);
const initials=n=>(n.split(/\s+/).map(x=>x[0]).join('')||'?').slice(0,2).toUpperCase();
const getRel=(a,b)=> (rel[a]?.[b] ?? 0);
const setRel=(a,b,v)=>{ rel[a]=rel[a]||{}; rel[b]=rel[b]||{}; rel[a][b]=v; rel[b][a]=v; };
const inAlliance=(a,b)=> Object.values(alliances).some(L=>L.includes(a)&&L.includes(b));
const relFactor=(voter,target)=> clamp(1+REL_SCALE*getRel(voter,target), REL_MIN_FACTOR, 2);
function weighted(arr, wfn){ const w=arr.map(wfn), sum=w.reduce((a,b)=>a+b,0); let r=Math.random()*sum; for(let i=0;i<arr.length;i++){ r-=w[i]; if(r<=0) return arr[i]; } return arr[arr.length-1]; }
function duelWinProb(a,b){ const da=stats[a]?.challenge||8, db=stats[b]?.challenge||8; const p=1/(1+Math.exp(-LOGIT_K*(da-db))); return clamp(p,WIN_CLAMP_LO,WIN_CLAMP_HI); }

/* ===================== DOM refs ===================== */
const playerInput=document.getElementById('playerInput');
const nameCount=document.getElementById('nameCount');
const startBtn=document.getElementById('startBtn');
const nextBtn=document.getElementById('nextBtn');
const sceneFeed=document.getElementById('sceneFeed');
const castGrid=document.getElementById('castGrid');
const statsTable=document.getElementById('statsTable');
const relFocusSel=document.getElementById('relFocus');
const relEditorDiv=document.getElementById('relEditor');

/* ===================== Live name parsing ===================== */
function parseNames(){
  const raw = playerInput.value.split('\n').map(s=>s.trim()).filter(Boolean);
  const seen=new Set(), out=[]; raw.forEach(n=>{ if(!seen.has(n)){ seen.add(n); out.push(n); }});
  nameCount.textContent = `${out.length} / 13`;
  startBtn.disabled = (out.length!==13) || gameStarted;
  return out;
}

/* ===================== Preseason builders ===================== */
function buildCastGrid(names){
  if(!names.length){ castGrid.innerHTML=''; return; }
  if(!Object.keys(cast).length){
    const pal=["#7aa2ff","#ffa07a","#a3e635","#f472b6","#facc15","#34d399","#60a5fa","#f59e0b","#22d3ee","#c084fc","#fb7185","#93c5fd","#38bdf8"];
    names.forEach((n,i)=> cast[n]={photo:'',color:pal[i%pal.length]});
  } else { names.forEach((n)=>{ if(!cast[n]) cast[n]={photo:'',color:'#7aa2ff'}; }); }
  castGrid.innerHTML = names.map(n=>{
    const c=cast[n]; return `<div class="chip">
      ${c.photo?`<img class="avatar" src="${c.photo}">`:`<div class="avatar" style="background:${c.color}">${initials(n)}</div>`}
      <div style="flex:1">${n}<input type="url" class="photoUrl" data-name="${n}" placeholder="Image URL" value="${c.photo}"></div>
      <input type="color" class="color" data-name="${n}" value="${c.color}">
    </div>`;
  }).join('');
  castGrid.querySelectorAll('.photoUrl').forEach(inp=> inp.oninput=()=>{ cast[inp.dataset.name].photo=inp.value.trim(); buildCastGrid(names); });
  castGrid.querySelectorAll('.color').forEach(inp=> inp.oninput=()=>{ cast[inp.dataset.name].color=inp.value; buildCastGrid(names); });
}
function buildStatsTable(names){
  names.forEach(n=>{ stats[n]=stats[n]||{social:8,challenge:8}; });
  statsTable.innerHTML = `<table><tr><th>Player</th><th>Social</th><th>Challenge</th></tr>${
    names.map(n=>{
      const s=stats[n].social, c=stats[n].challenge;
      return `<tr><td>${n}</td>
        <td><input type="number" class="st" data-name="${n}" data-field="social" min="1" max="15" value="${s}"></td>
        <td><input type="number" class="st" data-name="${n}" data-field="challenge" min="1" max="15" value="${c}"></td></tr>`;
    }).join('')
  }</table>`;
}
function applyStatsFromInputs(){
  statsTable.querySelectorAll('.st').forEach(inp=>{
    const n=inp.dataset.name, f=inp.dataset.field, v=clamp(parseInt(inp.value||'8',10),1,15);
    stats[n][f]=v;
  });
}
document.getElementById('applyStats').onclick=applyStatsFromInputs;
document.getElementById('presetBalanced').onclick=()=>presetStats('balanced');
document.getElementById('presetSocial').onclick=()=>presetStats('social');
document.getElementById('presetChallenge').onclick=()=>presetStats('challenge');
document.getElementById('presetRandom').onclick=()=>presetStats('random');
function presetStats(which){
  const names=parseNames();
  names.forEach(n=>{
    if(which==='balanced') stats[n]={social:8,challenge:8};
    if(which==='social')   stats[n]={social:12,challenge:8};
    if(which==='challenge')stats[n]={social:8,challenge:12};
    if(which==='random')   stats[n]={social:1+Math.floor(Math.random()*15),challenge:1+Math.floor(Math.random()*15)};
  });
  buildStatsTable(names);
}
function buildRelFocusList(names){
  relFocusSel.innerHTML = names.map(n=>`<option>${n}</option>`).join('');
  if(names.length) renderRelEditorFor(names[0], names);
}
relFocusSel.onchange=()=> renderRelEditorFor(relFocusSel.value, parseNames());
function renderRelEditorFor(focus, names){
  const others = names.filter(n=>n!==focus);
  relEditorDiv.innerHTML = `<table><tr><th>Player</th><th>Score</th></tr>${
    others.map(n=>`<tr><td>${n}</td><td><input type="number" class="relSpin" data-focus="${focus}" data-target="${n}" min="-5" max="5" step="1" value="${getRel(focus,n)}"></td></tr>`).join('')
  }</table>`;
  relEditorDiv.querySelectorAll('.relSpin').forEach(sp=> sp.oninput=()=>{ const f=sp.dataset.focus,t=sp.dataset.target; setRel(f,t,clamp(parseInt(sp.value||'0',10),-5,5)); renderRelsLive(); });
}

/* Live relationships */
function renderRelsLive(){
  const names=parseNames(); if(!names.length){ document.getElementById('relsLive').innerHTML=''; return; }
  const pairs=[], seen={};
  names.forEach(a=>names.forEach(b=>{ if(a===b) return; const k=[a,b].sort().join('|'); if(seen[k]) return; seen[k]=1; pairs.push({a,b,v:getRel(a,b)}); }));
  pairs.sort((x,y)=>Math.abs(y.v)-Math.abs(x.v));
  const bonds=pairs.filter(p=>p.v>0).slice(0,6), feuds=pairs.filter(p=>p.v<0).slice(0,6);
  document.getElementById('relsLive').innerHTML=
    `<div><strong>Bonds</strong><br/>${bonds.length?bonds.map(p=>`${p.a} ↔ ${p.b} (+${p.v})`).join('<br/>'):'<span class="hint">None</span>'}
    <hr style="border-color:var(--border)"><strong>Tensions</strong><br/>${feuds.length?feuds.map(p=>`${p.a} ↔ ${p.b} (${p.v})`).join('<br/>'):'<span class="hint">None</span>'}</div>`;
}

/* ===================== Episode / Scene ===================== */
function ensureEpisode(){ const tag=`Phase ${phase} R${round}`; if(!currentEpisode || currentEpisode._tag!==tag){ currentEpisode={title:tag,_tag:tag,linesViewed:0,total:0}; episodes.push(currentEpisode); sceneQueue.length=0; showLine('(Ready) Tap “Next Scene”.'); } }
function addScene(line){ sceneQueue.push(line); currentEpisode && currentEpisode.total++; }
function showLine(text){ sceneFeed.textContent=text; }

/* ===================== Voting / Tally ===================== */
function simulateVote(voters, eligible){
  const out=[];
  voters.forEach(v=>{
    const choices=eligible.filter(p=>p!==v);
    const al=choices.filter(c=>inAlliance(v,c));
    const prefer = al.length>0 && Math.random()<ALLY_PREFERENCE_RATE;
    const pool = prefer? al : choices;
    const baseAlpha = prefer? ALPHA_SOCIAL : 0.5*ALPHA_SOCIAL;
    const pick = pool.length? weighted(pool, c=>{
      const s=(stats[c]?.social||8);
      const j=VOTE_JITTER_MIN + Math.random()*(VOTE_JITTER_MAX - VOTE_JITTER_MIN);
      return Math.pow(s,baseAlpha)*j*relFactor(v,c);
    }):null;
    if(pick){ out.push([v,pick]); votesGiven[v]=(votesGiven[v]||0)+1; votesReceived[pick]=(votesReceived[pick]||0)+1; }
  });
  return out;
}
function tally(votePairs, eligible){
  const counts={}; eligible.forEach(p=>counts[p]=0);
  votePairs.forEach(([_,to])=>{ if(counts[to]!=null) counts[to]++; });
  const max=Math.max(...Object.values(counts)); const tied=Object.keys(counts).filter(p=>counts[p]===max);
  return [tied[0], tied, counts];
}
function addVoteColumn(label, voters, pairs, result){
  const values={}; voters.forEach(v=>values[v]='—'); eliminated.forEach(v=>{ if(values[v]==null) values[v]='—'; });
  pairs.forEach(([v,to])=> values[v]=to);
  voteColumns.push({label,values,result}); renderVoteMatrix();
}
function renderVoteMatrix(){
  const wrap=document.getElementById('votingMatrix');
  let html='<div style="overflow:auto"><table><thead><tr><th>Voter</th>';
  voteColumns.forEach(c=> html+=`<th>${c.label}</th>`); html+='</tr></thead><tbody>';
  const order=[...players, ...eliminated.filter(p=>!players.includes(p)).sort((a,b)=> (elimPhase(b)-elimPhase(a)))];
  function elimPhase(n){ const x=jury.find(j=>j.name===n); return x?x.phase:99; }
  order.forEach(v=>{ html+=`<tr><td>${v}</td>`; voteColumns.forEach(c=> html+=`<td>${c.values[v]||'—'}</td>`); html+='</tr>'; });
  html+='<tr><th>Result</th>'; voteColumns.forEach(c=> html+=`<th>${c.result||''}</th>`); html+='</tr></tbody></table></div>';
  wrap.innerHTML=html;
}

/* ===================== Alliances & Progress ===================== */
function generateAlliances(){
  alliances={A:[],B:[],C:[],D:[]};
  const sh=shuffle(players);
  sh.forEach((p,i)=> alliances[['A','B','C','D'][i%4]].push(p));
  const box=document.getElementById('alliancesList');
  box.innerHTML = Object.entries(alliances).map(([k,v])=>`<div><b>${k}</b>: ${v.join(', ')}</div>`).join('');
}
function updateProgress(){
  const chart=document.getElementById('progressChart');
  const everyone=players.concat(eliminated.filter(p=>!players.includes(p)));
  chart.innerHTML = `<table><tr><th>Player</th><th>P1</th><th>P2</th><th>Final</th><th>W</th><th>L</th></tr>${
    everyone.map(p=>{
      const p1=(keys[p]||[]).includes('P1')?'✔':'—', p2=(keys[p]||[]).includes('P2')?'✔':'—', fin=(finalists.includes(p)?'✔':'—');
      return `<tr><td>${p}</td><td>${p1}</td><td>${p2}</td><td>${fin}</td><td>${wins[p]||0}</td><td>${losses[p]||0}</td></tr>`;
    }).join('')
  }</table>`;
}

/* ===================== Social Events ===================== */
const EVENT_LIBRARY = [
  {type:'bond',    text:(a,b)=>`${a} flips ${b}'s mattress back after a prank; they laugh it off. (+1)`, w:2},
  {type:'tension', text:(a,b)=>`${a} flips ${b}'s mattress during a nap. (-1)`, w:1},
  {type:'tension', text:(a,b)=>`${a} accidentally breaks ${b}'s mug. Tension rises. (-1)`, w:1},
  {type:'bond',    text:(a,b)=>`${a} replaces ${b}'s broken mug with a new one. (+1)`, w:1},
  {type:'tension', text:(a,b)=>`A plane flies overhead: “${b} is not to be trusted!” ${a} side‑eyes ${b}. (-1)`, w:1},
  {type:'bond',    text:(a,b)=>`${a} comforts ${b} after a rough day. (+1)`, w:2},
  {type:'tension', text:(a,b)=>`${a} spreads a rumor that ${b} has the Lockpick. (-1)`, w:1},
  {type:'bond',    text:(a,b)=>`${a} shares food with ${b}. (+1)`, w:2},
  {type:'tension', text:(a,b)=>`${a} hogs the shower and ${b} calls them out. (-1)`, w:1},
  {type:'bond',    text:(a,b)=>`${a} and ${b} stay up strategizing together. (+1)`, w:2},
  {type:'tension', text:(a,b)=>`${a} hides ${b}'s shoes before the draw. (-1)`, w:1},
  {type:'bond',    text:(a,b)=>`${a} teaches ${b} a challenge trick. (+1)`, w:2},
  {type:'tension', text:(a,b)=>`${a} refuses to throw a duel for ${b}. (-1)`, w:1}
];
function triggerEvents(tag){
  const num = Math.floor(Math.random()*3);
  for(let k=0;k<num;k++){
    const a = players[Math.floor(Math.random()*players.length)];
    let b = players[Math.floor(Math.random()*players.length)];
    if(!a||!b||a===b) continue;
    const ev = weighted(EVENT_LIBRARY, e=>e.w);
    const delta = (ev.type==='bond')? +1 : -1;
    setRel(a,b, clamp(getRel(a,b)+delta,-5,5));
    addScene(`Event • ${tag}: ${ev.text(a,b)}`);
  }
  renderRelsLive();
}

/* ===================== Relationship ripples ===================== */
function postVoteRelChanges(winner, group, votePairs){
  const bumps=[], drops=[];
  const targetedBy = votePairs.filter(([_,to])=>to===winner).map(([v,_])=>v);
  targetedBy.forEach(v=>{ if(inAlliance(v,winner)){ setRel(v,winner, clamp(getRel(v,winner)+1,-5,5)); bumps.push(`${v}→${winner} +1`); }});
  group.filter(p=>p!==winner).forEach(p=>{ if(!inAlliance(p,winner)){ setRel(p,winner, clamp(getRel(p,winner)-1,-5,5)); drops.push(`${p}→${winner} -1`); }});
  renderRelsLive();
  addScene((!bumps.length&&!drops.length)?'No noticeable post‑vote ripples.'
    :`Post‑vote ripples — Bonds: ${bumps.join(' • ')||'—'} | Tensions: ${drops.join(' • ')||'—'}`);
}
function postPickRelChanges(picker,picks,hadAllyOption){
  const bumps=[], drops=[];
  picks.forEach(o=>{
    if(inAlliance(picker,o)){ setRel(picker,o, clamp(getRel(picker,o)+1,-5,5)); bumps.push(`${picker}→${o} +1 (ally)`);
    } else { setRel(picker,o, clamp(getRel(picker,o)-1,-5,5)); drops.push(`${picker}→${o} -1 (target)`); }
  });
  if(hadAllyOption && picks.every(o=>!inAlliance(picker,o))){
    const allies = players.filter(p=>p!==picker && inAlliance(picker,p));
    allies.forEach(a=> setRel(picker,a, clamp(getRel(picker,a)-1,-5,5)));
    if(allies.length) drops.push(`${picker}→allies (${allies.join(', ')}) -1 (snub)`);
  }
  renderRelsLive();
  addScene((!bumps.length&&!drops.length)?'No noticeable post‑pick ripples.'
    :`Post‑pick ripples — Bonds: ${bumps.join(' • ')||'—'} | Tensions: ${drops.join(' • ')||'—'}`);
}

/* ===================== Jury Keys ===================== */
function distributeJuryKeys(finalists, jury, finalistKeys){
  const jm={}; jury.forEach(j=>{ jm[j.name]={}; finalists.forEach(f=>jm[j.name][f]=0); });
  const softmax=(obj,t=1)=>{ const vals=finalists.map(f=>obj[f]/t); const m=Math.max(...vals);
    const exps=vals.map(v=>Math.exp(v-m)); const Z=exps.reduce((a,b)=>a+b,0); const p={}; finalists.forEach((f,i)=>p[f]=exps[i]/Z); return p; };

  jury.forEach(j=>{
    const cap = (j.phase===1?1:(j.phase===2?2:3));
    const base={}; finalists.forEach(f=>{
      const socialBoost = 0.12*(stats[f]?.social||8);
      const jitter=0.9+Math.random()*0.2;
      base[f]=(1+socialBoost)*jitter;
    });
    const probs=softmax(base,1);
    const ranked=finalists.slice().sort((a,b)=>probs[b]-probs[a]);
    const top=ranked[0], second=ranked[1];

    let pAll = (j.phase===3 ? 0.72 : j.phase===2 ? 0.62 : 0.5);
    if((probs[top]/probs[second])<1.1) pAll-=0.15;
    pAll = clamp(pAll, 0.25, 0.85);

    if(Math.random()<pAll){
      jm[j.name][top]+=cap; finalistKeys[top]+=cap;
    }else{
      for(let k=0;k<cap;k++){
        const pNow=softmax(base,1.05);
        const pick=weighted(finalists,f=>pNow[f]);
        jm[j.name][pick]+=1; finalistKeys[pick]+=1; base[pick]*=0.94;
      }
    }
  });
  return jm;
}
function displayJuryMatrix(matrix){
  const area=document.getElementById('juryMatrix');
  if(!finalists.length){ area.innerHTML='<div class="hint">No finalists yet.</div>'; return; }
  let html = `<div style="overflow:auto"><table><tr><th>Juror</th>`;
  finalists.forEach(f => html += `<th>${f}</th>`); html += `<th>Total</th></tr>`;
  for(const juror in matrix){
    html += `<tr><td>${juror}</td>`;
    let sum=0; finalists.forEach(f => { const v=matrix[juror][f]||0; html += `<td>${v}</td>`; sum+=v; });
    html += `<td>${sum}</td></tr>`;
  }
  html += `</table></div>`;
  area.innerHTML = html;
}

/* ===================== Game driver ===================== */
function updateEverything(){ updateProgress(); renderVoteMatrix(); renderRelsLive(); }
function progressGame(){
  updateEverything();
  if(phase===1) return runPhase1();
  if(phase===2) return runPhase2();
  if(phase===3) return runPhase3();
  if(phase===4) return runFinale();
}

/* ===================== Phase 1 (Alt) ===================== */
let p1_lastChanceDone=false;
function runPhase1(){
  const p1Count=Object.values(keys).reduce((a,k)=>a+((k||[]).includes('P1')?1:0),0);
  if(p1Count>=8){
    if(!p1_lastChanceDone){
      ensureEpisode();
      const group = players.filter(p=>!(keys[p]||[]).includes('P1')); // 5
      const voters = group.slice();
      addScene(`P1 Last Chance Vote among: ${group.join(', ')} (only they vote)`);
      const v1=simulateVote(voters, group); let [w,tied]=tally(v1, group);
      addVoteColumn('P1 R5 (vote)', voters, v1, tied.length===1?w:('TIE:'+tied.join('=')));
      // Revote among tied (tied sit); odd number → should break
      if(tied.length>1){
        const rv=voters.filter(v=>!tied.includes(v));
        const v2=simulateVote(rv, tied); let [w2,t2]=tally(v2, tied);
        addVoteColumn('P1 R5 (revote)', rv, v2, t2.length===1?w2:('TIE:'+t2.join('=')));
        w = (t2.length===1? w2 : tied[Math.floor(Math.random()*tied.length)]);
      }
      addScene(`${w} survives and receives a P1 key.`);
      keys[w]=keys[w]||[]; keys[w].push('P1'); wins[w]=(wins[w]||0)+1;
      const outs=group.filter(p=>p!==w); outs.forEach(p=>{ eliminated.push(p); jury.push({name:p,phase:1}); });
      players=players.filter(p=>!outs.includes(p)); p1_lastChanceDone=true; updateEverything(); return;
    } else { addScene('Phase 1 complete. Advancing: '+players.join(', ')); phase=2; round=1; return; }
  }

  ensureEpisode();
  const noKey=players.filter(p=>!(keys[p]||[]).includes('P1'));
  const drawn = (round===4)? (noKey.length>=7? noKey.slice(0,7): shuffle(noKey).slice(0,Math.min(6,noKey.length)))
                           : shuffle(noKey).slice(0,Math.min(6,noKey.length));
  addScene(`P1 R${round}: Drawn → ${drawn.join(', ')}`);

  triggerEvents('around the draw');

  // All 13 vote among drawn
  const pairs = simulateVote(players, drawn);
  let [winner,tied] = tally(pairs, drawn);
  addVoteColumn(`P1 R${round} (vote)`, players, pairs, tied.length===1?winner:('TIE:'+tied.join('=')));

  if(tied.length===1){
    // vote key to winner
    keys[winner]=keys[winner]||[]; keys[winner].push('P1'); wins[winner]=(wins[winner]||0)+1;
    addScene(`${winner} wins the Vote Key and sits out the challenge.`);
    // challenge among remaining drawn without P1
    const chall = drawn.filter(p=>p!==winner && !((keys[p]||[]).includes('P1')));
    if(chall.length){
      const cw = weighted(chall, n=>(stats[n]?.challenge||8)*(0.85+Math.random()*0.3));
      keys[cw]=keys[cw]||[]; keys[cw].push('P1'); wins[cw]=(wins[cw]||0)+1;
      addScene(`Challenge: ${chall.join(', ')} → ${cw} wins the Challenge Key.`);
      chall.filter(x=>x!==cw).forEach(l=>losses[l]=(losses[l]||0)+1);
    }
    postVoteRelChanges(winner, drawn, pairs);
  } else {
    // revote among tied (tied don’t vote)
    const rv = players.filter(v=>!tied.includes(v));
    const revPairs = simulateVote(rv, tied);
    const [rvw, tied2] = tally(revPairs, tied);
    addVoteColumn(`P1 R${round} (revote)`, rv, revPairs, tied2.length===1?rvw:('TIE:'+tied2.join('=')));

    if(tied2.length===1){
      // revote breaks
      keys[rvw]=keys[rvw]||[]; keys[rvw].push('P1'); wins[rvw]=(wins[rvw]||0)+1;
      addScene(`Revote breaks: ${rvw} takes the Vote Key and sits out.`);
      const chall = drawn.filter(p=>p!==rvw && !((keys[p]||[]).includes('P1')));
      if(chall.length){
        const cw=weighted(chall, n=>(stats[n]?.challenge||8)*(0.85+Math.random()*0.3));
        keys[cw]=keys[cw]||[]; keys[cw].push('P1'); wins[cw]=(wins[cw]||0)+1;
        addScene(`Challenge: ${chall.join(', ')} → ${cw} wins the Challenge Key.`);
        chall.filter(x=>x!==cw).forEach(l=>losses[l]=(losses[l]||0)+1);
      }
      postVoteRelChanges(rvw, drawn, pairs);
    } else {
      // still tied → ALL drawn run challenge; winner keeps challenge key AND must give vote key to someone in tie (not themselves)
      const cw = weighted(drawn, n=>(stats[n]?.challenge||8)*(0.85+Math.random()*0.3));
      keys[cw]=keys[cw]||[]; keys[cw].push('P1'); wins[cw]=(wins[cw]||0)+1;
      const candidates=tied.filter(x=>x!==cw).length? tied.filter(x=>x!==cw):tied.slice();
      const give = weighted(candidates, n=> (stats[n]?.social||8)*(0.9+Math.random()*0.2));
      keys[give]=keys[give]||[]; keys[give].push('P1'); wins[give]=(wins[give]||0)+1;
      addScene(`Revote still tied → Challenge winner ${cw} keeps Challenge Key and awards Vote Key to ${give}.`);
      drawn.filter(x=>x!==cw).forEach(l=>losses[l]=(losses[l]||0)+1);
      postVoteRelChanges(give, drawn, pairs);
    }
  }
  round++; updateEverything();
}

/* ===================== Phase 2 (Alt) ===================== */
let p2_lastChanceDone=false;
function runPhase2(){
  const p2Count=Object.values(keys).reduce((a,k)=>a+((k||[]).includes('P2')?1:0),0);
  if(p2Count>=4){
    if(!p2_lastChanceDone){
      ensureEpisode();
      const group = players.filter(p=>!((keys[p]||[]).includes('P2')));
      addScene(`Phase 2 — Last Chance Challenge among: ${group.join(', ')}`);
      const w = weighted(group, n=>(stats[n]?.challenge||8)*(0.85+Math.random()*0.3));
      keys[w]=keys[w]||[]; keys[w].push('P2'); wins[w]=(wins[w]||0)+1;
      group.filter(x=>x!==w).forEach(l=>{ eliminated.push(l); jury.push({name:l,phase:2}); losses[l]=(losses[l]||0)+1; });
      players = players.filter(p=>!group.includes(p) || p===w);
      addScene(`${w} secures the final Phase 2 key. Others join the jury (P2).`);
      p2_lastChanceDone=true; updateEverything(); return;
    } else { addScene('Phase 2 complete. Advancing: '+players.join(', ')); phase=3; round=1; return; }
  }

  ensureEpisode();
  addScene(`Phase 2 — Round ${round}`);
  const noP2 = players.filter(p=>!((keys[p]||[]).includes('P2')));
  if(noP2.length<2){ addScene('Not enough no‑P2 players; jumping to last‑chance.'); p2_lastChanceDone=false; return; }

  const votePairs = simulateVote(players, noP2);
  let [vw, tied] = tally(votePairs, noP2);
  addVoteColumn(`P2 R${round} (vote)`, players, votePairs, tied.length===1?vw:('TIE:'+tied.join('=')));

  if(tied.length===1){
    const winner=vw; addScene(`${winner} wins the vote and must pick a no‑P2 opponent for the duel.`);
    const cand=noP2.filter(p=>p!==winner);
    const opp = weighted(cand, c=> Math.pow(1/Math.max(1,(stats[c]?.challenge||8)), 1.2)); // beatable bias
    addScene(`${winner} chooses ${opp} (beatable / alliance retention).`);
    const w = (Math.random()<duelWinProb(winner,opp))? winner : opp;
    const l = (w===winner?opp:winner);
    keys[w]=keys[w]||[]; keys[w].push('P2'); wins[w]=(wins[w]||0)+1; losses[l]=(losses[l]||0)+1;
    addScene(`${w} wins the duel and earns a P2 key.`);
    round++; updateEverything(); return;
  }

  // Tie handling
  if(tied.length===2){
    const revVoters = players.filter(v=>!tied.includes(v));
    const rev = simulateVote(revVoters, tied);
    const [w2, tied2] = tally(rev, tied);
    addVoteColumn(`P2 R${round} (revote)`, revVoters, rev, tied2.length===1?w2:('TIE:'+tied2.join('=')));
    if(tied2.length===1){
      const winner=w2; addScene(`Revote breaks: ${winner} must pick an opponent.`);
      const cand=noP2.filter(p=>p!==winner);
      const opp = weighted(cand, c=> Math.pow(1/Math.max(1,(stats[c]?.challenge||8)), 1.2));
      const w = (Math.random()<duelWinProb(winner,opp))? winner : opp;
      const l = (w===winner?opp:winner);
      keys[w]=keys[w]||[]; keys[w].push('P2'); wins[w]=(wins[w]||0)+1; losses[l]=(losses[l]||0)+1;
      addScene(`${w} wins the duel and earns a P2 key.`);
      round++; updateEverything(); return;
    } else {
      // stalemate → duel between the two
      const a=tied[0], b=tied[1];
      const w = (Math.random()<duelWinProb(a,b))? a : b;
      const l = (w===a?b:a);
      keys[w]=keys[w]||[]; keys[w].push('P2'); wins[w]=(wins[w]||0)+1; losses[l]=(losses[l]||0)+1;
      addScene(`Revote stalemate → Tiebreak duel: ${a} vs ${b} — ${w} earns the P2 key.`);
      round++; updateEverything(); return;
    }
  }

  if(tied.length===3){
    addScene(`3‑way tie → Triple Duel among ${tied.join(', ')}.`);
    const w = weighted(tied, n=>(stats[n]?.challenge||8)*(0.85+Math.random()*0.3));
    keys[w]=keys[w]||[]; keys[w].push('P2'); wins[w]=(wins[w]||0)+1;
    tied.filter(x=>x!==w).forEach(l=>losses[l]=(losses[l]||0)+1);
    addScene(`${w} wins the triple duel and earns a P2 key.`);
    round++; updateEverything(); return;
  }

  if(tied.length===4){
    // 4‑way tie → the one person who didn’t vote for any of the four breaks it
    const tiedSet=new Set(tied);
    const nonVoters = players.filter(v=>{
      const pick = (votePairs.find(([vv,_])=>vv===v)||[])[1];
      return !tiedSet.has(pick);
    });
    if(nonVoters.length){
      const breaker = weighted(nonVoters, c=> (stats[c]?.social||8)*(0.9+Math.random()*0.2));
      const pick = weighted(tied, c=> (stats[c]?.social||8)*(0.9+Math.random()*0.2));
      addScene(`4‑way tie → ${breaker} breaks the tie and selects ${pick}.`);
      const cand=noP2.filter(p=>p!==pick);
      const opp = cand.length? weighted(cand, c=> Math.pow(1/Math.max(1,(stats[c]?.challenge||8)), 1.2)) : null;
      if(opp){
        const w = (Math.random()<duelWinProb(pick,opp))? pick : opp;
        const l = (w===pick?opp:pick);
        keys[w]=keys[w]||[]; keys[w].push('P2'); wins[w]=(wins[w]||0)+1; losses[l]=(losses[l]||0)+1;
        addScene(`${w} wins the duel and earns a P2 key.`);
      } else { keys[pick]=keys[pick]||[]; keys[pick].push('P2'); wins[pick]=(wins[pick]||0)+1; addScene(`${pick} receives P2 key (no opponent available).`); }
      round++; updateEverything(); return;
    } else {
      // fallback: multi-duel among tied
      const w = weighted(tied, n=>(stats[n]?.challenge||8)*(0.85+Math.random()*0.3));
      keys[w]=keys[w]||[]; keys[w].push('P2'); wins[w]=(wins[w]||0)+1;
      tied.filter(x=>x!==w).forEach(l=>losses[l]=(losses[l]||0)+1);
      addScene(`Edge case 4‑tie with no breaker → multi‑duel; ${w} wins P2 key.`);
      round++; updateEverything(); return;
    }
  }

  // Larger ties → multi‑duel
  const w = weighted(tied, n=>(stats[n]?.challenge||8)*(0.85+Math.random()*0.3));
  keys[w]=keys[w]||[]; keys[w].push('P2'); wins[w]=(wins[w]||0)+1;
  tied.filter(x=>x!==w).forEach(l=>losses[l]=(losses[l]||0)+1);
  addScene(`Large tie → multi‑duel; ${w} wins P2 key.`);
  round++; updateEverything();
}

/* ===================== Phase 3 (Alt) ===================== */
function runPhase3(){
  ensureEpisode();
  addScene('Phase 3 — Final Cut vote.');
  const raw=simulateVote(players, players);
  const pairs=raw.map(([v,t])=> v===t? [v, weighted(players.filter(p=>p!==v), c=> (stats[c]?.social||8)*(0.9+Math.random()*0.2))] : [v,t]);
  let [vw, tied] = tally(pairs, players);
  addVoteColumn('P3 R1', players, pairs, tied.length===1?vw:('TIE:'+tied.join('=')));

  if(tied.length===1){
    const voteWinner=vw; addScene(`${voteWinner} wins and becomes a finalist.`);
    const avail = players.filter(p=>p!==voteWinner);
    const partner = weighted(avail, c=> (stats[c]?.social||8)*relFactor(voteWinner,c));
    addScene(`${voteWinner} selects ${partner} to join them in the finale.`);
    finalists=[voteWinner, partner];
    const bottom3 = players.filter(p=>!finalists.includes(p));
    const w = weighted(bottom3, n=>(stats[n]?.challenge||8)*(0.85+Math.random()*0.3));
    const outs = bottom3.filter(x=>x!==w);
    addScene(`Bottom‑3 challenge: ${bottom3.join(', ')} → ${w} advances; ${outs.join(', ')} join the jury (P3).`);
    finalists.push(w);
    outs.forEach(o=>{ eliminated.push(o); jury.push({name:o,phase:3}); losses[o]=(losses[o]||0)+1; });
    phase=4; round=1; updateEverything(); return;
  } else if(tied.length===2){
    const safe=tied.slice(); addScene(`P3 tie: ${safe.join(' & ')} are safe.`);
    const picker = weighted(safe, c=> (stats[c]?.social||8)*(0.9+Math.random()*0.2));
    const partner = safe.find(x=>x!==picker) || safe[0];
    finalists=[picker, partner];
    const bottom3 = players.filter(p=>!finalists.includes(p));
    const w = weighted(bottom3, n=>(stats[n]?.challenge||8)*(0.85+Math.random()*0.3));
    const outs = bottom3.filter(x=>x!==w);
    addScene(`Bottom‑3 challenge: ${bottom3.join(', ')} → ${w} advances; ${outs.join(', ')} join the jury (P3).`);
    finalists.push(w);
    outs.forEach(o=>{ eliminated.push(o); jury.push({name:o,phase:3}); losses[o]=(losses[o]||0)+1; });
    phase=4; round=1; updateEverything(); return;
  } else {
    // rare: first two safe, rest bottom‑3
    const safe=tied.slice(0,2); finalists=safe.slice();
    const bottom3 = players.filter(p=>!finalists.includes(p));
    const w = weighted(bottom3, n=>(stats[n]?.challenge||8)*(0.85+Math.random()*0.3));
    const outs = bottom3.filter(x=>x!==w);
    addScene(`Rare multi‑tie: ${safe.join(' & ')} safe; bottom‑3 challenge → ${w} advances.`);
    finalists.push(w);
    outs.forEach(o=>{ eliminated.push(o); jury.push({name:o,phase:3}); losses[o]=(losses[o]||0)+1; });
    phase=4; round=1; updateEverything(); return;
  }
}

/* ===================== Finale (Alt) ===================== */
let finaleState=null;
function runFinale(){
  ensureEpisode();
  if(!finaleState){
    if(finalists.length!==3){ addScene('Finale error: not enough finalists.'); return; }
    const finalistKeys={}; finalists.forEach(f=> finalistKeys[f]=3); // 3 base keys
    const jm=distributeJuryKeys(finalists, jury, finalistKeys);
    displayJuryMatrix(jm);

    // Vault choices (unique) around expected support
    const pool=[]; for(let i=3;i<=22;i++) pool.push(i);
    const expect={}; finalists.forEach(f=> expect[f]=Math.round(6 + (stats[f]?.social||8)*0.6));
    const chosen=pickVaults(expect, pool);
    finaleState={finalistKeys, juryMatrix:jm, chosenVaults:chosen, winner:null, step:0};
    addScene('Jury awards keys. Next: vault choices & reveal.');
    return;
  }

  if(finaleState.step===0){
    const line = finalists.map(f=> `${f}: vault ${finaleState.chosenVaults[f]} (has ${finaleState.finalistKeys[f]} keys)`).join(' | ');
    addScene(line);
    // Determine if anyone opens. Winner is the opener with highest vault.
    const sorted = finalists.map(n=>({name:n,keys:finaleState.finalistKeys[n],vault:finaleState.chosenVaults[n]})).sort((a,b)=>b.vault-a.vault);
    const opener = sorted.find(r=>r.keys>=r.vault) || null;
    finaleState.winner = opener? opener.name : null; finaleState.step=1; return;
  }

  if(finaleState.step===1){
    if(finaleState.winner){
      addScene(`${finaleState.winner} opens the ${finaleState.chosenVaults[finaleState.winner]}-key vault with ${finaleState.finalistKeys[finaleState.winner]} keys — Champion!`);
    } else {
      addScene('No vault opens → Final‑3 challenge for the season!');
      const w = weighted(finalists, n=>(stats[n]?.challenge||8)*(0.85+Math.random()*0.3));
      addScene(`${w} wins the final challenge and claims the 3‑key vault — Champion!`);
    }
    nextBtn.textContent='Simulate Again'; nextBtn.onclick=()=>location.reload();
    phase=5;
  }
}
function pickVaults(expect, pool){
  const avail=pool.slice(), picked={};
  Object.keys(expect).sort((a,b)=>expect[b]-expect[a]).forEach(f=>{
    let best=avail[0], bestDiff=1e9, idx=0;
    for(let i=0;i<avail.length;i++){ const v=avail[i], d=Math.abs(v-expect[f]); if(d<bestDiff){ bestDiff=d; best=v; idx=i; } }
    picked[f]=best; avail.splice(idx,1);
  });
  return picked;
}

/* ===================== Start Season & UI glue ===================== */
function ensureKeyBag(){ players.forEach(p=>{ keys[p]=keys[p]||[]; wins[p]=wins[p]||0; losses[p]=losses[p]||0; keysEarned[p]=keysEarned[p]||{P1:0,P2:0}; }); }
function startSeason(){
  if(gameStarted) return;
  const names=parseNames();
  if(names.length!==13){ alert('Please enter exactly 13 players.'); return; }
  players=names.slice(); initialOrder=names.slice();
  ensureKeyBag();
  generateAlliances();
  castGrid.style.display='none';
  // Hide preseason stats + relationships container
  statsTable.parentElement.parentElement.parentElement.style.display='none';
  startBtn.style.display='none'; nextBtn.style.display='inline-block';
  gameStarted=true;
  phase=1; round=1; ensureEpisode(); addScene('Season begins — Alt Vault rules in effect. Tap Next Scene.');
  updateEverything();
}

/* ===================== Wire buttons ===================== */
startBtn.addEventListener('click', startSeason);
nextBtn.addEventListener('click', ()=>{
  if(sceneQueue.length){ showLine(sceneQueue.shift()); return; }
  progressGame();
  if(sceneQueue.length){ showLine(sceneQueue.shift()); }
});
playerInput.addEventListener('input', refreshPreseason);

function refreshPreseason(){
  const names=parseNames();
  names.forEach(n=>{ stats[n]=stats[n]||{social:8,challenge:8}; rel[n]=rel[n]||{}; cast[n]=cast[n]||{photo:'',color:'#7aa2ff'}; });
  buildCastGrid(names);
  buildStatsTable(names);
  buildRelFocusList(names);
  renderRelsLive();
}

/* ===================== Init with defaults so UI shows ===================== */
(function init(){
  const defaults = Array.from({length:13},(_,i)=>`Player ${i+1}`).join('\n');
  playerInput.value = defaults;
  refreshPreseason();
})();
</script>
</body>
</html>