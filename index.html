<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Vault Simulator — Alt Rules (v6.0)</title>
<meta http-equiv="Content-Security-Policy" content="img-src 'self' https: data:;">
<style>
  :root { --bg:#f6f7fb; --card:#fff; --line:#e5e7eb; --muted:#6b7280; --text:#0f172a; --btn:#111827; --btntext:#fff; --shade:#fafafa; }
  [data-theme="dark"]{ --bg:#0b0f14; --card:#11161d; --line:#203040; --muted:#93a3b5; --text:#e6eef6; --btn:#e6eef6; --btntext:#0b0f14; --shade:#0e141b; }
  *{box-sizing:border-box} body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text)}
  header{background:var(--card);border-bottom:1px solid var(--line);padding:14px 18px;display:flex;justify-content:space-between;align-items:center}
  h1{margin:0;font-size:18px}
  main{max-width:1200px;margin:16px auto;padding:0 12px;display:grid;grid-template-columns:1fr 360px;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;box-shadow:0 1px 2px rgba(0,0,0,.03)}
  .card h2{margin:0;padding:10px 12px;border-bottom:1px solid var(--line);font-size:15px}
  .card .content{padding:12px}
  textarea{width:100%;min-height:120px;border:1px solid var(--line);border-radius:8px;padding:10px;background:var(--shade);color:var(--text)}
  input,select,button{font-size:14px}
  button{background:var(--btn);color:var(--btntext);border:1px solid var(--btn);border-radius:8px;padding:8px 12px;cursor:pointer}
  button.secondary{background:transparent;color:var(--text);border:1px solid var(--line)}
  .row{display:flex;gap:8px;align-items:flex-start;flex-wrap:wrap}
  .muted{color:var(--muted);font-size:12px}
  .pill{display:inline-block;border:1px solid var(--line);border-radius:999px;padding:3px 8px;margin:3px 3px 0 0;font-size:12px}
  .hidden{display:none!important}

  /* Round Events */
  #events .event{padding:10px 12px;border:1px solid var(--line);border-radius:10px;background:var(--card);margin:8px 0}
  #events .evt-text{margin-bottom:8px;font-size:14px}
  #events .evt-images{display:flex;flex-wrap:wrap;gap:8px}
  #events .evt-images img{width:96px;height:96px;object-fit:cover;border-radius:6px}

  table{width:100%;border-collapse:collapse}
  .vm th,.vm td{border-bottom:1px solid var(--line);padding:6px 8px;font-size:13px;text-align:left;vertical-align:top}
  .vm th{background:var(--shade);font-weight:600}
  .avatar{width:22px;height:22px;border-radius:4px;object-fit:cover;vertical-align:middle}

  /* Modal */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:flex;align-items:center;justify-content:center;z-index:9999}
  .modal .panel{max-width:1000px;width:95%;max-height:90vh;overflow:auto}
  .tabs{display:flex;gap:8px;margin-bottom:8px}
  .tabs button{border-radius:999px;padding:6px 12px}
  .grid{display:grid;gap:8px}
  .rel-editor{display:flex;gap:12px;align-items:flex-end;flex-wrap:wrap;margin-bottom:8px}
  .rel-table input{width:56px;padding:6px;border:1px solid var(--line);border-radius:6px;background:var(--shade);color:var(--text);text-align:center}
  .attr-input{width:70px;padding:6px;border:1px solid var(--line);border-radius:6px;background:var(--shade);color:var(--text)}
  @media(max-width:960px){main{grid-template-columns:1fr}}
</style>
</head>
<body>
<header>
  <h1>The Vault Simulator — Alt Rules</h1>
  <div class="row">
    <button id="themeBtn" class="secondary">Toggle Dark</button>
  </div>
</header>

<main>
  <!-- LEFT -->
  <section class="card">
    <h2>Player Setup</h2>
    <div class="content">
      <div class="row">
        <div style="flex:1">
          <label class="muted">Enter 13 players, one per line</label>
          <textarea id="playersInput" placeholder="Enter 13 names, one per line"></textarea>
        </div>
        <div style="flex:1">
          <label class="muted">Optional photo links (one per line, same order). Imgur gallery links like <code>.../gallery/abc#ImageId</code> are fine.</label>
          <textarea id="photosInput" placeholder="Optional: one image link per player"></textarea>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="preBtn" class="secondary">Pre‑Season (Attributes & Relationships)</button>
        <button id="startBtn">Start Game</button>
        <button id="resetBtn" class="secondary">Reset</button>
        <span id="phaseLabel" class="muted"></span>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>Controls</h2>
    <div class="content">
      <div id="controls" class="row">
        <button id="nextBtn" class="hidden">Next</button>
        <button id="againBtn" class="hidden">Simulate Again</button>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>Round Events</h2>
    <div class="content"><div id="events"></div></div>
  </section>

  <section class="card">
    <h2>Vote History (season)</h2>
    <div class="content">
      <div class="muted" style="margin-bottom:8px">Voters on the left; each round adds a new column to the right. Revotes appear as their own columns.</div>
      <div id="voteChart"></div>
    </div>
  </section>

  <!-- RIGHT -->
  <section class="card">
    <h2>Alliances</h2>
    <div id="alliancesBox" class="content"><div class="muted">Generated at start and may evolve. Alliances influence votes and duel picks.</div></div>
  </section>

  <section class="card">
    <h2>Progress</h2>
    <div class="content">
      <table class="vm" id="progress">
        <thead>
          <tr>
            <th>Player</th>
            <th colspan="5">P1 R1–R5</th>
            <th colspan="5">P2 R1–R5</th>
            <th>P3</th>
          </tr>
          <tr class="muted">
            <th></th>
            <th>R1</th><th>R2</th><th>R3</th><th>R4</th><th>R5</th>
            <th>R1</th><th>R2</th><th>R3</th><th>R4</th><th>R5</th>
            <th>Final Cut</th>
          </tr>
        </thead>
        <tbody id="progressBody"></tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Jury Key Matrix</h2>
    <div class="content">
      <div class="muted">Budgets: P1 juror=1, P2 juror=2, P3 juror=3. Matrix shows exact per‑juror allocations. Total jury keys = 18.</div>
      <div id="juryMatrixWrap"></div>
    </div>
  </section>
</main>

<!-- Image helpers -->
<script>
function toDirectImgur(url){
  if(!url) return '';
  let m=url.match(/^https?:\/\/i\.imgur\.com\/([A-Za-z0-9]+)\.(?:jpg|jpeg|png|gif|webp|avif|gifv)$/i);
  if(m) return `https://i.imgur.com/${m[1]}.jpg`;
  m=url.match(/^https?:\/\/imgur\.com\/(?:gallery|a)\/[A-Za-z0-9]+#([A-Za-z0-9]+)$/i);
  if(m) return `https://i.imgur.com/${m[1]}.jpg`;
  m=url.match(/^https?:\/\/imgur\.com\/([A-Za-z0-9]+)(?:[#?].*)?$/i);
  if(m) return `https://i.imgur.com/${m[1]}.jpg`;
  m=url.match(/^https?:\/\/i\.imgur\.com\/([A-Za-z0-9]+)\.[A-Za-z0-9]+/i);
  if(m) return `https://i.imgur.com/${m[1]}.jpg`;
  return url;
}
const __PH__ =
  'data:image/svg+xml;utf8,' +
  encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="96" height="96" viewBox="0 0 96 96">
    <rect width="96" height="96" fill="#e5e7eb"/><circle cx="48" cy="36" r="18" fill="#9ca3af"/>
    <rect x="18" y="60" width="60" height="24" rx="12" fill="#9ca3af"/></svg>`);
function setImageSrc(img,raw,alt='Image'){
  const u=toDirectImgur(raw||'');
  img.setAttribute('referrerpolicy','no-referrer');
  img.alt=alt;
  img.src=u||__PH__;
  let tried=false;
  img.onerror=()=>{ if(!tried && /\.jpg$/i.test(img.src)){ tried=true; img.src=img.src.replace(/\.jpg$/i,'.png'); } else img.src=__PH__; };
}
function logEventWithImages(text,urls=[]){
  const feed=document.getElementById('events');
  const box=document.createElement('div'); box.className='event';
  const p=document.createElement('div'); p.className='evt-text'; p.textContent=text; box.appendChild(p);
  if(urls.length){
    const strip=document.createElement('div'); strip.className='evt-images';
    urls.forEach(u=>{ const im=document.createElement('img'); setImageSrc(im,u); strip.appendChild(im); });
    box.appendChild(strip);
  }
  feed.appendChild(box);
}
</script>

<script>
/* =========================
   ALT VAULT — ENGINE v6.0
   ========================= */
const UI = {
  playersInput: document.getElementById('playersInput'),
  photosInput:  document.getElementById('photosInput'),
  preBtn:       document.getElementById('preBtn'),
  startBtn:     document.getElementById('startBtn'),
  resetBtn:     document.getElementById('resetBtn'),
  nextBtn:      document.getElementById('nextBtn'),
  againBtn:     document.getElementById('againBtn'),
  phaseLabel:   document.getElementById('phaseLabel'),
  events:       document.getElementById('events'),
  voteChart:    document.getElementById('voteChart'),
  alliancesBox: document.getElementById('alliancesBox'),
  progressBody: document.getElementById('progressBody'),
  juryWrap:     document.getElementById('juryMatrixWrap'),
  themeBtn:     document.getElementById('themeBtn'),
};

const S = {
  phase: 0, round: 0,
  roster: [],             // {name,img,p1[5],p2[5],p3,alive,attr:{soc,comp,strat(1–10)},rel:{name->1..10}}
  alliances: [],
  p1Jurors: [], p2Jurors: [], p3Jurors: [],
  finalists: [],
  p1Drawn: {},            // rIndex -> [names]
  // Lockpick
  lockpickHolder: null,
  lockpickClueHolder: null, // +50% find boost while hidden
  // Showmances
  showmances: new Set(),     // "A|B"
  // Voting viz
  voteCols: [],
  voteData: {},
  // Round biases
  avoidVoteTargets: new Set(),
  targetVoteBoost: null,     // set when a real rally forms
  lastAvoidTarget: null,
  // Event cooldown per player -> event key
  evtCooldown: new Map(),
  // Phase intro
  pendingIntro: null,
};

/* ---------- Theme ---------- */
(function(){
  const saved = localStorage.getItem('vault_theme') || 'light';
  document.documentElement.setAttribute('data-theme', saved);
  UI.themeBtn.addEventListener('click', ()=>{
    const cur = document.documentElement.getAttribute('data-theme');
    const next = cur==='dark' ? 'light' : 'dark';
    document.documentElement.setAttribute('data-theme', next);
    localStorage.setItem('vault_theme', next);
  });
})();

/* ---------- Helpers ---------- */
function alive(){ return S.roster.filter(p=>p.alive); }
function byName(n){ return S.roster.find(p=>p.name===n); }
function r(a,b){ return a+Math.floor(Math.random()*(b-a+1)); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function choice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
function weightPick(items, wfn){ let sum=0; items.forEach(it=>sum+=Math.max(1,wfn(it))); let rr=Math.random()*sum; for(const it of items){ const w=Math.max(1,wfn(it)); if(rr<w) return it; rr-=w; } return items[items.length-1]; }

/* Eligible voting pool per round (for smart events & rally checks) */
function eligibleVotePoolForRound(){
  if (S.phase === 1){
    const rIndex=(S.round||1)-1;
    const names=S.p1Drawn[rIndex]||[];
    return names.map(byName).filter(Boolean);
  }
  if (S.phase === 2){
    return alive().filter(p=>!p.p2.includes('K')); // only players without a P2 key
  }
  if (S.phase === 3){
    return alive(); // 5 remain
  }
  return [];
}

/* ---------- Preseason (1–10 Attributes + 1–10 Relationships) ---------- */
UI.preBtn.addEventListener('click', buildPreseason);
function buildPreseason(){
  const names = UI.playersInput.value.split('\n').map(s=>s.trim()).filter(Boolean);
  if(names.length!==13){ alert('Enter exactly 13 players first.'); return; }
  const photos = UI.photosInput.value.split('\n').map(s=>s.trim());
  if(!S.roster.length){
    S.roster = names.map((n,i)=>({
      name:n, img:photos[i]||'', p1:Array(5).fill(''), p2:Array(5).fill(''), p3:false, alive:true,
      attr:{soc:5,comp:5,strat:5}, rel:{} }));
  }
  // init relationships at 5 (neutral)
  S.roster.forEach(a=> S.roster.forEach(b=>{ if(a.name!==b.name && typeof a.rel[b.name]!=='number') a.rel[b.name]=5; }));

  // Modal
  const modal=document.createElement('div'); modal.className='modal';
  const panel=document.createElement('section'); panel.className='card panel';
  panel.innerHTML='<h2>Pre‑Season Editor</h2>';
  const content=document.createElement('div'); content.className='content';
  modal.addEventListener('click', (e)=>{ if(e.target===modal) document.body.removeChild(modal); });
  panel.addEventListener('click', (e)=> e.stopPropagation());
  panel.appendChild(content); modal.appendChild(panel); document.body.appendChild(modal);

  // Tabs
  const tabs=document.createElement('div'); tabs.className='tabs';
  const tAttr=document.createElement('button'); tAttr.textContent='Attributes'; tAttr.className='secondary';
  const tRel=document.createElement('button'); tRel.textContent='Relationships'; tRel.className='secondary';
  tabs.appendChild(tAttr); tabs.appendChild(tRel);

  // ATTRIBUTES
  const wrapAttr=document.createElement('div');
  const randAttr=document.createElement('button'); randAttr.textContent='Randomize All Attributes (1–10)'; randAttr.className='secondary';
  wrapAttr.appendChild(randAttr);
  const grid=document.createElement('div'); grid.className='grid'; grid.style.gridTemplateColumns='1fr';
  S.roster.forEach(p=>{
    const row=document.createElement('div'); row.className='row';
    row.innerHTML=`<div style="min-width:180px"><strong>${p.name}</strong></div>
      <label class="muted">Social</label><input class="attr-input" type="number" min="1" max="10" value="${p.attr.soc}" data-n="${p.name}" data-k="soc">
      <label class="muted">Comp</label><input class="attr-input" type="number" min="1" max="10" value="${p.attr.comp}" data-n="${p.name}" data-k="comp">
      <label class="muted">Strategy</label><input class="attr-input" type="number" min="1" max="10" value="${p.attr.strat}" data-n="${p.name}" data-k="strat">
      <label class="muted">Photo</label><input type="text" value="${p.img}" style="flex:1" data-n="${p.name}" data-k="img">`;
    grid.appendChild(row);
  });
  wrapAttr.appendChild(grid);

  // RELATIONSHIPS (focal editor)
  const wrapRel=document.createElement('div');
  const editorBar=document.createElement('div'); editorBar.className='rel-editor';
  const focalSel=document.createElement('select'); focalSel.id='relFocal';
  S.roster.forEach(p=>{ const o=document.createElement('option'); o.value=p.name; o.textContent=p.name; focalSel.appendChild(o); });
  const mutualLbl=document.createElement('label'); mutualLbl.className='muted';
  const mutualChk=document.createElement('input'); mutualChk.type='checkbox'; mutualChk.checked=true;
  mutualLbl.appendChild(mutualChk); mutualLbl.appendChild(document.createTextNode(' Make edits mutual'));
  const randRelAll=document.createElement('button'); randRelAll.textContent='Randomize All Relationships (1–10)'; randRelAll.className='secondary';
  editorBar.appendChild(document.createTextNode('Edit: '));
  editorBar.appendChild(focalSel);
  editorBar.appendChild(mutualLbl);
  editorBar.appendChild(randRelAll);
  wrapRel.appendChild(editorBar);

  const relTbl=document.createElement('table'); relTbl.className='vm';
  const relHead=document.createElement('thead');
  const hr=document.createElement('tr'); hr.innerHTML='<th>Target</th><th>Score (1–10)</th>';
  relHead.appendChild(hr); relTbl.appendChild(relHead);
  const relBody=document.createElement('tbody'); relTbl.appendChild(relBody);
  wrapRel.appendChild(relTbl);

  function renderRelRows(){
    relBody.innerHTML='';
    const focal=byName(focalSel.value);
    S.roster.forEach(t=>{
      if(t.name===focal.name) return;
      const tr=document.createElement('tr');
      const td1=document.createElement('td'); td1.textContent=t.name; tr.appendChild(td1);
      const td2=document.createElement('td');
      const inp=document.createElement('input'); inp.type='number'; inp.min=1; inp.max=10; inp.value=focal.rel[t.name]??5;
      inp.addEventListener('input',()=>{
        let v=clamp(Number(inp.value)||5,1,10);
        focal.rel[t.name]=v;
        if(mutualChk.checked){ t.rel[focal.name]=v; }
      });
      td2.appendChild(inp); tr.appendChild(td2);
      relBody.appendChild(tr);
    });
  }
  focalSel.addEventListener('change', renderRelRows);
  randRelAll.addEventListener('click', ()=>{
    S.roster.forEach(a=>S.roster.forEach(b=>{ if(a.name!==b.name) a.rel[b.name]=r(2,9); }));
    renderRelRows();
  });
  renderRelRows();

  // Buttons
  const buttons=document.createElement('div'); buttons.className='row'; buttons.style.marginTop='8px';
  const save=document.createElement('button'); save.textContent='Save & Close';
  const cancel=document.createElement('button'); cancel.textContent='Cancel'; cancel.className='secondary';
  buttons.appendChild(save); buttons.appendChild(cancel);

  content.appendChild(tabs); content.appendChild(wrapAttr); content.appendChild(wrapRel); content.appendChild(buttons);

  function show(tab){ wrapAttr.style.display=(tab==='attr')?'block':'none'; wrapRel.style.display=(tab==='rel')?'block':'none';
    tAttr.classList.toggle('secondary', tab!=='attr'); tRel.classList.toggle('secondary', tab!=='rel'); }
  show('attr'); tAttr.onclick=()=>show('attr'); tRel.onclick=()=>show('rel');

  content.addEventListener('input',(e)=>{
    const t=e.target; const n=t.getAttribute('data-n'); const k=t.getAttribute('data-k');
    if(!n||!k) return;
    const pl=S.roster.find(x=>x.name===n);
    if(k==='img') pl.img=t.value.trim();
    else { pl.attr[k]=clamp(Number(t.value)||1,1,10); }
  });
  randAttr.onclick=()=>{ S.roster.forEach(p=>{ p.attr.soc=r(3,9); p.attr.comp=r(3,9); p.attr.strat=r(3,9); }); refreshAttrInputs(); };
  function refreshAttrInputs(){ content.querySelectorAll('.attr-input').forEach(inp=>{
    const n=inp.getAttribute('data-n'), k=inp.getAttribute('data-k'); const p=S.roster.find(x=>x.name===n); inp.value=p.attr[k];
  });}

  save.onclick=()=>{ document.body.removeChild(modal); syncInputsFromRoster(); };
  cancel.onclick=()=>{ document.body.removeChild(modal); };
}

/* ---------- Alliances ---------- */
function genAlliances(){
  const names=S.roster.map(p=>p.name);
  const A=[];
  for(let i=1;i<=3;i++){
    const shuf=[...names].sort(()=>Math.random()-0.5);
    A.push({name:`Alliance ${i}`, members:new Set(shuf.slice(0,5))});
  }
  S.alliances=A; renderAlliances();
}
function renderAlliances(){
  UI.alliancesBox.innerHTML='';
  S.alliances.forEach(a=>{
    const box=document.createElement('div');
    box.innerHTML=`<div><strong>${a.name}</strong></div>`;
    const wrap=document.createElement('div');
    a.members.forEach(n=>{ const s=document.createElement('span'); s.className='pill'; s.textContent=n; wrap.appendChild(s); });
    box.appendChild(wrap); UI.alliancesBox.appendChild(box);
  });
}

/* ---------- Voting (uses 1–10 relationship scale) ---------- */
function voteAmong(voters, targets, forbidSelf=true, tilt='neutral'){
  const avoid = S.avoidVoteTargets || new Set();
  const map={};
  voters.forEach(v=>{
    const a=S.alliances.find(x=>x.members.has(v.name));
    let opts=targets.map(t=>t.name);
    if(forbidSelf) opts=opts.filter(n=>n!==v.name);
    const scored=opts.map(n=>{
      const t=byName(n);
      let base = 50 + ((t?.attr.strat??5)-5)*4;     // strategic pressure
      const rel = v.rel?.[t?.name] ?? 5;            // 1–10 (5 neutral)
      base += (5 - rel) * 6;                        // dislike -> higher vote weight
      if(tilt==='ally' && a){ base = a.members.has(t.name)? 20: 80; }
      if(tilt==='outside' && a){ base = a.members.has(t.name)? 80: 20; }
      if(avoid.has(t.name)) base *= 0.1;            // ICE-OUT bias
      if(S.targetVoteBoost === t.name) base *= 1.6; // FOCUS rally bias
      return {name:n, w:Math.max(1,base)};
    });
    map[v.name]=weightPick(scored, s=>s.w).name;
  });
  return map;
}

/* ---------- Progress Table ---------- */
function renderProgress(){
  UI.progressBody.innerHTML='';
  S.roster.forEach(p=>{
    const tr=document.createElement('tr');
    const p1=p.p1.map(c=>`<td>${c||''}</td>`).join('');
    const p2=p.p2.map(c=>`<td>${c||''}</td>`).join('');
    tr.innerHTML=`<td>${p.name}</td>${p1}${p2}<td>${p.p3?'✓':''}</td>`;
    UI.progressBody.appendChild(tr);
  });
}

/* ---------- Vote chart ---------- */
function addVoteColumn(label, map, votersList){
  if(!S.voteCols.includes(label)) S.voteCols.push(label);
  votersList.forEach(v=>{
    if(!S.voteData[v.name]) S.voteData[v.name]={};
    S.voteData[v.name][label] = map[v.name] || '';
  });
  renderVoteChart();
}
function renderVoteChart(){
  const container=UI.voteChart; container.innerHTML='';
  const table=document.createElement('table'); table.className='vm';
  const thead=document.createElement('thead'); const trh=document.createElement('tr');
  trh.appendChild(th('Voter'));
  S.voteCols.forEach(c=>trh.appendChild(th(c)));
  thead.appendChild(trh); table.appendChild(thead);
  const tb=document.createElement('tbody');
  S.roster.forEach(v=>{
    const tr=document.createElement('tr');
    tr.appendChild(td(v.name));
    S.voteCols.forEach(c=>{
      const t=S.voteData[v.name]?.[c] || '—';
      tr.appendChild(td(t));
    });
    tb.appendChild(tr);
  });
  table.appendChild(tb);
  container.appendChild(table);
  function th(t){ const el=document.createElement('th'); el.textContent=t; return el; }
  function td(t){ const el=document.createElement('td'); el.textContent=t; return el; }
}

/* ---------- Expanded House Events ---------- */

// utility
function pairKey(a,b){ return a<b ? `${a}|${b}` : `${b}|${a}`; }
function inAlliance(a,b){ return S.alliances.some(al=>al.members.has(a) && al.members.has(b)); }

function pushCooldown(name, key){ S.evtCooldown.set(name, key); }
function onCooldown(name, key){ return S.evtCooldown.get(name) === key; }

function smartRallyTarget(elig, voters){
  // Is there a plausible rally FOR someone? majority of voters like them (avgRel>=6) or share alliances?
  const scored = elig.map(t=>{
    let relSum=0,c=0, allyHits=0;
    voters.forEach(v=>{
      if(v.name===t.name) return;
      const rv = v.rel?.[t.name]; if(typeof rv==='number'){ relSum+=rv; c++; }
      if(inAlliance(v.name,t.name)) allyHits++;
    });
    const avgRel = c? relSum/c : 5;
    const support = avgRel*1.5 + allyHits; // simple blend
    return {t, support, avgRel, allyHits};
  }).sort((a,b)=>b.support-a.support);
  const top = scored[0];
  const majorityNeeded = Math.ceil(voters.length/2);
  if(!top) return null;
  // majority if at least half have rel >=6 OR allyHits covers half
  const sufficientAllies = top.allyHits >= majorityNeeded/2;
  const sufficientRel = top.avgRel >= 6;
  return (sufficientAllies || sufficientRel) ? top.t : null;
}

function houseEvents(tag){
  S.avoidVoteTargets.clear();
  S.targetVoteBoost = null;

  const pool = alive();
  const elig = eligibleVotePoolForRound();
  if (!pool.length || !elig.length) return;

  const voters = (S.phase === 1) ? S.roster : alive();

  // Up to 3 events
  const count = r(2,3);
  for(let i=0;i<count;i++){
    const roll = Math.random();

    if (roll < 0.18){
      // Social snack share
      const a=choice(pool), b=choice(pool.filter(x=>x!==a));
      a.rel[b.name]=clamp((a.rel[b.name]??5)+r(1,3),1,10);
      b.rel[a.name]=clamp((b.rel[a.name]??5)+r(1,3),1,10);
      logEventWithImages(`${tag}: ${a.name} and ${b.name} secretly share snacks and bond.`, [a.img||'', b.img||'']);

    } else if (roll < 0.32){
      // Muffin theft (conflict)
      const a=choice(pool), b=choice(pool.filter(x=>x!==a));
      if(!onCooldown(b.name,'muffin')){
        b.rel[a.name]=clamp((b.rel[a.name]??5)-r(2,4),1,10);
        logEventWithImages(`${tag}: ${a.name} eats ${b.name}'s muffin. ${b.name} is fuming.`, [a.img||'', b.img||'']);
        pushCooldown(b.name,'muffin');
      }

    } else if (roll < 0.42){
      // Mattress flip (prank/conflict)
      const a=choice(pool), b=choice(pool.filter(x=>x!==a));
      if(!onCooldown(b.name,'mattress')){
        b.rel[a.name]=clamp((b.rel[a.name]??5)-r(2,4),1,10);
        logEventWithImages(`${tag}: ${a.name} flips ${b.name}'s mattress as a prank. Trust drops.`, [a.img||'', b.img||'']);
        pushCooldown(b.name,'mattress');
      }

    } else if (roll < 0.52){
      // Alliance recruit/expel
      if(S.alliances.length){
        const pick=choice(S.alliances);
        if(Math.random()<0.5 && pick.members.size>2){
          const leaver=choice([...pick.members]); pick.members.delete(leaver);
          logEventWithImages(`${tag}: ${leaver} is quietly pushed out of ${pick.name}.`, [byName(leaver).img||'']);
        } else {
          const opts=pool.map(p=>p.name).filter(n=>!pick.members.has(n));
          if(opts.length){ const joiner=choice(opts); pick.members.add(joiner); logEventWithImages(`${tag}: ${joiner} is recruited into ${pick.name}.`, [byName(joiner).img||'']); }
        }
        renderAlliances();
      }

    } else if (roll < 0.60){
      // Final-2 deal
      const a=choice(pool), b=choice(pool.filter(x=>x!==a));
      a.rel[b.name]=clamp((a.rel[b.name]??5)+r(1,2),1,10);
      b.rel[a.name]=clamp((b.rel[a.name]??5)+r(1,2),1,10);
      logEventWithImages(`${tag}: ${a.name} and ${b.name} make a secret Final‑2 promise.`, [a.img||'', b.img||'']);

    } else if (roll < 0.68){
      // Vote leak
      const a=choice(pool), b=choice(pool.filter(x=>x!==a));
      a.rel[b.name]=clamp((a.rel[b.name]??5)-r(2,3),1,10);
      logEventWithImages(`${tag}: ${a.name} leaks ${b.name}'s vote. Trust erodes.`, [a.img||'', b.img||'']);

    } else if (roll < 0.76){
      // Public apology
      const a=choice(pool), b=choice(pool.filter(x=>x!==a));
      a.rel[b.name]=clamp((a.rel[b.name]??5)+r(1,3),1,10);
      b.rel[a.name]=clamp((b.rel[a.name]??5)+r(1,3),1,10);
      logEventWithImages(`${tag}: ${a.name} publicly apologizes to ${b.name}. Tension eases.`, [a.img||'', b.img||'']);

    } else if (roll < 0.82){
      // Move beds (disrupt duo)
      const a=choice(pool), b=choice(pool.filter(x=>x!==a));
      a.rel[b.name]=clamp((a.rel[b.name]??5)-1,1,10);
      b.rel[a.name]=clamp((b.rel[a.name]??5)-1,1,10);
      logEventWithImages(`${tag}: Beds are shuffled to separate ${a.name} and ${b.name}'s late‑night talks.`, [a.img||'', b.img||'']);

    } else if (roll < 0.88){
      // Showmance start/end rules
      const a=choice(pool), b=choice(pool.filter(x=>x!==a));
      const key=pairKey(a.name,b.name);
      if(!S.showmances.has(key) && (a.rel[b.name]+b.rel[a.name])>=17 && Math.random()<0.3){
        S.showmances.add(key);
        logEventWithImages(`${tag}: A showmance starts between ${a.name} and ${b.name}.`, [a.img||'', b.img||'']);
      } else if(S.showmances.has(key) && Math.random()<0.3){
        S.showmances.delete(key);
        logEventWithImages(`${tag}: The showmance between ${a.name} and ${b.name} ends.`, [a.img||'', b.img||'']);
      }

    } else if (roll < 0.94){
      // Party / milestone
      pool.forEach(p=>{ p.attr.soc = clamp(p.attr.soc + (Math.random()<0.4?1:0),1,10); });
      logEventWithImages(`${tag}: House throws a themed party. Social vibes rise.`, []);

    } else {
      // Strategic meta: ICE-OUT or genuine FOCUS rally
      // Compute "problem" weights for ICE-OUT
      const scored = elig.map(t=>{
        let sum=0,c=0, allyHits=0;
        voters.forEach(v=>{
          if(v.name===t.name) return;
          const rv=v.rel?.[t.name]; if(typeof rv==='number'){ sum+=rv; c++; }
          if(inAlliance(v.name,t.name)) allyHits++;
        });
        const avgRel = c? (sum/c) : 5;
        const threat = (t.attr.comp-5)*1.2 + (t.attr.strat-5)*1.0;
        const cover = allyHits;
        let w = (6 - avgRel)*10 + threat*6 - cover*3;
        if(S.lastAvoidTarget===t.name) w *= 0.5;
        return {t,w:Math.max(1,Math.round(w))};
      });

      // 50/50: genuine FOCUS rally (if exists) else ICE-OUT
      if(Math.random()<0.5){
        const rally = smartRallyTarget(elig, voters);
        if(rally){
          S.targetVoteBoost = rally.name;
          const msg = (S.phase===2)
            ? `${tag}: A real rally forms to push ${rally.name} forward among the no‑key players.`
            : (S.phase===1
              ? `${tag}: A majority whispers to push ${rally.name} forward from the drawn group.`
              : `${tag}: The house coalesces around backing ${rally.name}.`);
          logEventWithImages(msg, [rally.img||'']);
          continue;
        }
      }
      const avoidPick = weightPick(scored, s=>s.w).t;
      S.avoidVoteTargets.add(avoidPick.name);
      S.lastAvoidTarget = avoidPick.name;
      const msg = (S.phase===2)
        ? `${tag}: Talk spreads to avoid voting for ${avoidPick.name} among the no‑key players.`
        : (S.phase===1
          ? `${tag}: The house quietly agrees to avoid voting for ${avoidPick.name} from the drawn group.`
          : `${tag}: The house leans away from voting ${avoidPick.name}.`);
      logEventWithImages(msg, [avoidPick.img||'']);
    }
  }
}

/* ---------- Lockpick (find + P2 ally/keep logic) ---------- */
function tryFindLockpick(phase, round){
  if(!((phase===1 && round<=4)||(phase===2 && round<=4))) return;
  if(S.lockpickHolder) return;
  const boost = S.lockpickClueHolder ? 1.5 : 1.0;
  if(Math.random()<0.33*boost){
    const finder=choice(alive());
    S.lockpickHolder=finder.name;
    S.lockpickClueHolder=null;
    logEventWithImages(`${finder.name} finds a Lockpick. It can be used before votes are read to take control. (Not allowed in Last Chance rounds.)`, [finder.img||'']);
  }
}

/* ======================
   PHASE 1 — 5 ROUNDS
   ====================== */
function phase1Round(){
  UI.events.innerHTML='';
  const rIndex=(S.round||1)-1;

  if(S.round<=4){
    // draw (cached)
    let drawn;
    if(!S.p1Drawn[rIndex]){
      const noKey = alive().filter(p=>!p.p1.includes('V') && !p.p1.includes('C'));
      drawn = (S.round===4) ? noKey : shuffle(noKey).slice(0,6);
      S.p1Drawn[rIndex]=drawn.map(p=>p.name);
    } else drawn = S.p1Drawn[rIndex].map(byName);

    logEventWithImages(
      (S.round===4)
        ? `P1 R${S.round}: Round 4 exception — all without a P1 key are drawn.`
        : `P1 R${S.round}: Drawn for vote and challenge: ${drawn.map(p=>p.name).join(', ')}`,
      drawn.map(p=>p.img||'')
    );

    // House events (influence this round)
    houseEvents(`P1 R${S.round} house event`);

    // Lockpick (vote key secure only if holder is drawn)
    tryFindLockpick(1,S.round);
    let forcedVoteKeyWinner=null;
    if(S.lockpickHolder && S.round<=4){
      const holder=byName(S.lockpickHolder);
      if(holder && drawn.some(p=>p.name===holder.name)){
        logEventWithImages(`${holder.name} uses the Lockpick before votes are read and secures the vote key.`, [holder.img||'']);
        forcedVoteKeyWinner=holder; S.lockpickHolder=null;
      }
    }

    // Vote
    const voters=S.roster;
    const map = voteAmong(voters, drawn, true, 'neutral');
    addVoteColumn(`P1R${S.round}`, map, voters);

    // Resolve
    let voteKeyWinner=null, challengeWinner=null;

    if(forcedVoteKeyWinner){
      voteKeyWinner=forcedVoteKeyWinner;
    } else {
      const tallyObj={}; Object.values(map).forEach(n=>tallyObj[n]=(tallyObj[n]||0)+1);
      const top=Math.max(...Object.values(tallyObj)); const tied=Object.keys(tallyObj).filter(n=>tallyObj[n]===top);
      if(tied.length===1){
        voteKeyWinner=byName(tied[0]);
      } else {
        logEventWithImages(`Tie among: ${tied.join(', ')}. Automatic revote.`, tied.map(n=>byName(n).img||''));
        const map2=voteAmong(voters, tied.map(byName), true, 'neutral');
        addVoteColumn(`P1R${S.round} (revote)`, map2, voters);
        const t2={}; Object.values(map2).forEach(n=>t2[n]=(t2[n]||0)+1);
        const max2=Math.max(...Object.values(t2)); const tied2=Object.keys(t2).filter(n=>t2[n]===max2);
        if(tied2.length===1){
          voteKeyWinner=byName(tied2[0]);
        } else {
          logEventWithImages(`Revote ties again. All drawn compete; winner will award the vote key to one of the tied players.`, drawn.map(p=>p.img||''));
          challengeWinner = weightPick(drawn, p=>Math.max(1,p.attr.comp));
          const tiedPrefer = tied2.map(byName).filter(p=>!p.p1.includes('V') && !p.p1.includes('C'));
          voteKeyWinner = tiedPrefer.length ? choice(tiedPrefer) : byName(choice(tied2));
          logEventWithImages(`${challengeWinner.name} wins the challenge key.`, [challengeWinner.img||'']);
          logEventWithImages(`${challengeWinner.name} awards the vote key to ${voteKeyWinner.name}.`, [challengeWinner.img||'', voteKeyWinner.img||'']);
        }
      }
    }

    if(!challengeWinner){
      const remain = drawn.filter(p=>p.name!==(voteKeyWinner?.name||'') && !p.p1.includes('V') && !p.p1.includes('C'));
      const pool = remain.length ? remain : drawn.filter(p=>p.name!==(voteKeyWinner?.name||''));
      challengeWinner = pool.length ? weightPick(pool, p=>Math.max(1,p.attr.comp)) : voteKeyWinner;
      logEventWithImages(`${voteKeyWinner.name} wins the vote and will receive the vote key.`, [voteKeyWinner.img||'']);
      logEventWithImages(`${challengeWinner.name} wins the challenge key.`, [challengeWinner.img||'']);
    }

    // Commit AFTER round
    const idx=rIndex;
    if(voteKeyWinner) voteKeyWinner.p1[idx]='V';
    if(challengeWinner) challengeWinner.p1[idx]='C';
    renderProgress();

    S.round++; UI.phaseLabel.textContent=`Phase 1 — Round ${Math.min(S.round,5)} of 5`;
    if(S.round===5){
      S.pendingIntro = {phase:1, text:'P1 R5 — Last Chance Vote: only the 5 without keys vote; winner gets a key, others become P1 jury.'};
    }

  } else if (S.round===5){
    UI.events.innerHTML='';
    if(S.pendingIntro){ logEventWithImages(S.pendingIntro.text, []); S.pendingIntro=null; return; }

    const noKey = alive().filter(p=>!p.p1.includes('V') && !p.p1.includes('C'));
    if(noKey.length){
      const map=voteAmong(noKey, noKey, true, 'neutral');
      addVoteColumn('P1R5 (LCV)', map, noKey);
      const tallyObj={}; Object.values(map).forEach(n=>tallyObj[n]=(tallyObj[n]||0)+1);
      const top=Math.max(...Object.values(tallyObj)); const tied=Object.keys(tallyObj).filter(n=>tallyObj[n]===top);
      const winner=byName(choice(tied));
      winner.p1[4]='V';
      logEventWithImages(`${winner.name} receives the Last Chance vote key.`, [winner.img||'']);
      const elim = alive().filter(p=>!p.p1.includes('V') && !p.p1.includes('C'));
      elim.forEach(p=>{ p.alive=false; S.p1Jurors.push(p.name); });
      if(elim.length) logEventWithImages(`Phase 1 eliminations: ${elim.map(p=>p.name).join(', ')}`, elim.map(p=>p.img||''));
    } else {
      logEventWithImages(`No players without a P1 key. Skipping Last Chance Vote.`,[]);
    }
    renderProgress();

    // Normalize to 9 alive for P2
    while(alive().length>9){ const p=choice(alive()); p.alive=false; S.p1Jurors.push(p.name); }
    while(alive().length<9){ const dead=S.roster.filter(p=>!p.alive && (p.p1.includes('V')||p.p1.includes('C'))); const p=choice(dead); if(p){ p.alive=true; const i=S.p1Jurors.indexOf(p.name); if(i>-1) S.p1Jurors.splice(i,1);} else break; }
    S.phase=2; S.round=1; UI.phaseLabel.textContent='Phase 2 — Round 1 of 5';
    S.pendingIntro = {phase:2, text:'Phase 2 begins. R1–R4: house votes a controller who chooses a duel (or lockpick grants control). R5: Last Chance Challenge.'};
  }
}

/* ======================
   PHASE 2 — 5 ROUNDS
   ====================== */
function phase2Round(){
  UI.events.innerHTML='';
  const rIndex=(S.round||1)-1;

  if(S.round<=4){
    // Phase intro page?
    if(S.pendingIntro){ logEventWithImages(S.pendingIntro.text, []); S.pendingIntro=null; return; }

    // House events BEFORE vote
    houseEvents(`P2 R${S.round} house event`);

    // Lockpick (ally/keep logic)
    tryFindLockpick(2,S.round);
    let controller=null;
    if(S.lockpickHolder && S.round<=4){
      const holder=byName(S.lockpickHolder);
      const players=alive();
      const elig=players.filter(p=>!p.p2.includes('K'));

      if(!holder.p2.includes('K')){
        controller=holder;
        logEventWithImages(`${holder.name} uses the Lockpick before votes are read and takes control to set the duel.`, [holder.img||'']);
        S.lockpickHolder=null; // consumed
      } else {
        // give to ally if possible, else keep
        const isAlly=(n)=>S.alliances.some(a=>a.members.has(holder.name)&&a.members.has(n));
        const allyOpts=elig.filter(p=>isAlly(p.name));
        if(allyOpts.length && Math.random()<0.8){
          // best ally by holder's relationship & lower strat
          let best=allyOpts[0], score=-1;
          allyOpts.forEach(p=>{
            const rel=holder.rel?.[p.name]??5;
            const s = rel*2 + (10 - p.attr.strat);
            if(s>score){best=p; score=s;}
          });
          controller=best;
          logEventWithImages(`${holder.name} uses the Lockpick on ally ${best.name}, giving them control to set the duel.`, [holder.img||'', best.img||'']);
          S.lockpickHolder=null; // consumed
        } else {
          logEventWithImages(`${holder.name} decides to keep the Lockpick for a later round.`, [holder.img||'']);
          // Do not clear holder (kept)
        }
      }
    }

    const players=alive(); const elig=players.filter(p=>!p.p2.includes('K'));
    const voters=players;

    let voteWinner=null;
    if(controller){
      voteWinner=controller; // sets duel, no free key
    } else {
      const map=voteAmong(voters, elig, true, 'outside');
      addVoteColumn(`P2R${S.round}`, map, voters);
      const t={}; Object.values(map).forEach(n=>t[n]=(t[n]||0)+1);
      const max=Math.max(...Object.values(t)); const tied=Object.keys(t).filter(n=>t[n]===max);
      if(tied.length===1){
        voteWinner=byName(tied[0]);
      } else if (tied.length===2){
        logEventWithImages(`Two-way tie between ${tied.join(' & ')}. Revote between tied only.`, tied.map(n=>byName(n).img||''));
        const map2=voteAmong(voters, tied.map(byName), true, 'neutral');
        addVoteColumn(`P2R${S.round} (revote)`, map2, voters);
        const t2={}; Object.values(map2).forEach(n=>t2[n]=(t2[n]||0)+1);
        const m2=Math.max(...Object.values(t2)); const tied2=Object.keys(t2).filter(n=>t2[n]===m2);
        voteWinner=byName(choice(tied2));
      } else if (tied.length===3){
        logEventWithImages(`Three-way tie among ${tied.join(', ')}. Triple duel!`, tied.map(n=>byName(n).img||''));
        const duelWinner=weightPick(tied.map(byName), p=>Math.max(1,p.attr.comp));
        if(!duelWinner.p2.includes('K')) duelWinner.p2[rIndex]='K';
        logEventWithImages(`${duelWinner.name} wins the triple duel and the Phase 2 key.`, [duelWinner.img||'']);
        renderProgress();
        S.round++; UI.phaseLabel.textContent=`Phase 2 — Round ${Math.min(S.round,5)} of 5`;
        if(S.round===5) S.pendingIntro={phase:2,text:'P2 R5 — Last Chance Challenge: the 5 without P2 keys compete.'};
        return;
      } else {
        const tiedSet=new Set(tied);
        const breakers=voters.filter(v=>!tiedSet.has(map[v.name]));
        if(breakers.length){
          const breaker=choice(breakers);
          voteWinner=byName(choice(tied));
          logEventWithImages(`Multi-way tie. ${breaker.name} (didn’t vote tied) breaks → ${voteWinner.name} sets the duel.`, [breaker.img||'', voteWinner.img||'']);
        } else {
          voteWinner=byName(choice(tied));
          logEventWithImages(`Multi-way tie with no breaker. Randomly choosing ${voteWinner.name} to set the duel.`, [voteWinner.img||'']);
        }
      }
    }

    logEventWithImages(`House selects ${voteWinner.name} to set the duel.`, [voteWinner.img||'']);

    const options=elig.filter(p=>p.name!==voteWinner.name);
    const ally=S.alliances.find(a=>a.members.has(voteWinner.name));
    const opponent = ally ? (choice(options.filter(p=>!ally.members.has(p.name)) || options)) : choice(options);
    logEventWithImages(`${voteWinner.name} chooses to duel ${opponent.name}.`, [voteWinner.img||'', opponent.img||'']);

    const duelWinner=weightPick([voteWinner,opponent], p=>Math.max(1,p.attr.comp + (p.attr.strat-5)*1.5));
    if(!duelWinner.p2.includes('K')) duelWinner.p2[rIndex]='K';
    logEventWithImages(`${duelWinner.name} wins the duel and the Phase 2 key.`, [duelWinner.img||'']);

    renderProgress();

    S.round++; UI.phaseLabel.textContent=`Phase 2 — Round ${Math.min(S.round,5)} of 5`;
    if(S.round===5) S.pendingIntro={phase:2,text:'P2 R5 — Last Chance Challenge: the 5 without P2 keys compete.'};
  } else if (S.round===5){
    UI.events.innerHTML='';
    if(S.pendingIntro){ logEventWithImages(S.pendingIntro.text, []); S.pendingIntro=null; return; }

    const noP2=alive().filter(p=>!p.p2.includes('K'));
    const pool = noP2.length>5 ? shuffle(noP2).slice(0,5) : noP2;
    logEventWithImages(`Last Chance Challenge among: ${pool.map(p=>p.name).join(', ')}`, pool.map(p=>p.img||''));
    const w=weightPick(pool, p=>Math.max(1,p.attr.comp));
    if(!w.p2.includes('K')) w.p2[4]='K';
    logEventWithImages(`${w.name} wins the last Phase 2 key.`, [w.img||'']);

    const losers = alive().filter(p=>!p.p2.includes('K'));
    losers.forEach(p=>{ p.alive=false; S.p2Jurors.push(p.name); });
    if(losers.length) logEventWithImages(`Phase 2 eliminations: ${losers.map(p=>p.name).join(', ')}`, losers.map(p=>p.img||''));
    renderProgress();

    while(alive().length>5){ const p=choice(alive()); p.alive=false; S.p2Jurors.push(p.name); }
    while(alive().length<5){ const dead=S.roster.filter(p=>!p.alive && (p.p1.some(x=>x)&&p.p2.some(x=>x))); const p=choice(dead); if(p){ p.alive=true; const i=S.p2Jurors.indexOf(p.name); if(i>-1) S.p2Jurors.splice(i,1);} else break; }
    S.phase=3; S.round=1; UI.phaseLabel.textContent='Phase 3 — Final Cut';
    S.pendingIntro={phase:3,text:'Phase 3 — Final Cut. House vote picks one finalist (who brings one); remaining three compete for the last spot.'};
  }
}

/* ======================
   PHASE 3 — FINAL CUT
   ====================== */
function phase3Run(){
  UI.events.innerHTML='';
  if(S.pendingIntro){ logEventWithImages(S.pendingIntro.text, []); S.pendingIntro=null; return; }

  const five=alive();
  // One last events pass
  houseEvents(`P3 house event`);

  // House vote for vote winner
  const map=(function(){ const res={}; five.forEach(v=>{
    const choices=five.filter(p=>p!==v);
    const scores=choices.map(t=>{
      const rel=v.rel?.[t.name]??5;
      const s = 50 + (rel-5)*6 + (t.attr.soc-5)*5;
      return {t,w:Math.max(1,s)};
    });
    res[v.name]=weightPick(scores, s=>s.w).t.name;
  }); return res;})();
  addVoteColumn('P3 (Final Cut vote)', map, five);

  const voteTallies={}; Object.values(map).forEach(n=>voteTallies[n]=(voteTallies[n]||0)+1);
  const top=Math.max(...Object.values(voteTallies));
  const voteWinner=byName(choice(Object.keys(voteTallies).filter(n=>voteTallies[n]===top)));
  const others=five.filter(p=>p!==voteWinner);
  const pick=weightPick(others, p=>Math.max(1,(voteWinner.rel?.[p.name]??5)*6 + (p.attr.soc-5)*5));
  const rest=others.filter(p=>p!==pick);

  voteWinner.p3=true; pick.p3=true;
  logEventWithImages(`${voteWinner.name} wins the vote and advances, choosing ${pick.name}. The remaining three compete for the last spot.`, [voteWinner.img||'', pick.img||'']);
  const duelWinner=weightPick(rest, p=>Math.max(1,p.attr.comp + (p.attr.strat-5)*4)); duelWinner.p3=true;
  const losers=rest.filter(p=>p!==duelWinner);
  losers.forEach(p=>{ p.alive=false; S.p3Jurors.push(p.name); });
  logEventWithImages(`${duelWinner.name} wins the final challenge and reaches the finale. Eliminated: ${losers.map(p=>p.name).join(' & ')}.`, [duelWinner.img||''].concat(losers.map(p=>p.img||'')));
  renderProgress();

  S.finalists=[voteWinner,pick,duelWinner];
  S.phase=4; S.round=1; UI.phaseLabel.textContent='Finale — The Vault';
  runFinale();
}

/* ======================
   FINALE — VAULT (1–10 rel scale)
   ====================== */
function runFinale(){
  const F=S.finalists;

  // Jury budgets sum to 18
  const budgets=new Map();
  S.p1Jurors.forEach(n=>budgets.set(n,(budgets.get(n)||0)+1));
  S.p2Jurors.forEach(n=>budgets.set(n,(budgets.get(n)||0)+2));
  S.p3Jurors.forEach(n=>budgets.set(n,(budgets.get(n)||0)+3));
  let total=0; budgets.forEach(v=>total+=v);
  if(total!==18){
    const jurors=[...budgets.keys()];
    let acc=0; const scaled=new Map();
    jurors.forEach((name,i)=>{ let v=Math.round((budgets.get(name)||0)*18/Math.max(1,total)); if(i===jurors.length-1) v=Math.max(0,18-acc); scaled.set(name,v); acc+=v; });
    budgets.clear(); scaled.forEach((v,k)=>budgets.set(k,v));
  }

  // Ground truth allocations
  const perJuror = new Map();
  const finalistTotals = new Map(F.map(x=>[x.name,0]));
  budgets.forEach((b,name)=>{
    const dist={ [F[0].name]:0,[F[1].name]:0,[F[2].name]:0 };
    for(let i=0;i<b;i++){
      const juror=byName(name);
      const prefs=F.map(f=>{
        const rel = juror ? (juror.rel?.[f.name]??5) : 5;
        const w = 50 + (rel-5)*6 + (f.attr.strat-5)*5;
        return {f,w:Math.max(1,w)};
      });
      const pick=weightPick(prefs, x=>x.w).f;
      dist[pick.name]++; finalistTotals.set(pick.name, finalistTotals.get(pick.name)+1);
    }
    perJuror.set(name, dist);
  });

  renderJuryMatrix(perJuror, budgets, F, finalistTotals);

  // Perception model
  function estimateJuryKeysFor(f){
    let exp=0, relAvg=0, count=0;
    budgets.forEach((b,jName)=>{
      const juror=byName(jName);
      const rel = juror ? (juror.rel?.[f.name]??5) : 5; relAvg+=rel*b; count+=b;
      const score = 0.8*(rel-5)/5 + 0.1*(f.attr.soc-5)/5 + 0.1*(f.attr.strat-5)/5;
      const p = clamp(0.5 + 0.4*score, 0.05, 0.95);
      exp += b * p;
    });
    const avgRel = count? (relAvg/count) : 5;
    let risk = 0;
    if(avgRel < 4.5) risk -= 1;
    if(f.attr.strat >= 8 && avgRel >= 5.5) risk += 1;
    const noiseRange = (f.attr.strat>=8)? 1.5 : 2.5;
    const noise = (Math.random()*2*noiseRange - noiseRange);
    return { estimate: exp + noise, avgRel, risk };
  }

  const vaults=[3,4,5,6,7,8,9,10,11,12,14,16,18,20,22];
  const taken=new Set(); const pickMap=new Map(); const reveal=[];
  F.forEach(f=>{
    const {estimate, avgRel, risk} = estimateJuryKeysFor(f);
    const estKeys = Math.max(0, estimate);
    let target = 3 + estKeys;
    if(risk<0) target -= 1;
    if(risk>0) target += 0.5;
    let choiceV=3;
    for(const v of vaults){ if(!taken.has(v) && v<=target+1e-6) choiceV=v; }
    if(taken.has(choiceV)) choiceV = vaults.find(v=>!taken.has(v))||3;
    taken.add(choiceV); pickMap.set(f.name, choiceV);
    reveal.push({name:f.name, est:(3+estKeys).toFixed(1), risk:(risk<0?'safe':risk>0?'bold':'normal'), avgRel:avgRel.toFixed(1), need:choiceV});
  });

  reveal.forEach(r=>{
    logEventWithImages(`${r.name} estimates ~${r.est} keys (${r.risk}, jury sentiment ~${r.avgRel}). Chooses ${r.need}-key vault.`, [byName(r.name).img||'']);
  });

  const results=[];
  F.forEach(f=>{
    const totalKeys=3+finalistTotals.get(f.name);
    const need=pickMap.get(f.name); const opens=totalKeys>=need;
    results.push({name:f.name,total:totalKeys,need,opens});
    logEventWithImages(`${f.name} stands at a ${need}-key vault with ${totalKeys} real keys. ${opens?'It opens.':'It does not open.'}`, [f.img||'']);
  });

  const openers=results.filter(r=>r.opens).sort((a,b)=>b.need-a.need);
  let winner;
  if(openers.length){
    winner=openers[0].name;
    logEventWithImages(`Winner: ${winner} — opened the highest vault among finalists.`, [byName(winner).img||'']);
  } else {
    const champ=choice(F);
    logEventWithImages(`No vault opens. Final three compete in a last challenge. ${champ.name} wins and claims the 3‑key vault.`, [champ.img||'']);
    winner=champ.name;
  }

  UI.nextBtn.classList.add('hidden'); UI.againBtn.classList.remove('hidden');
}
function renderJuryMatrix(perJuror, budgets, finalists, finalistTotals){
  UI.juryWrap.innerHTML='';
  const table=document.createElement('table'); table.className='vm';
  const thead=document.createElement('thead'); const hr=document.createElement('tr');
  hr.appendChild(th('Juror')); hr.appendChild(th('Budget'));
  finalists.forEach(f=>hr.appendChild(th(f.name)));
  hr.appendChild(th('Row Total'));
  thead.appendChild(hr); table.appendChild(thead);
  const tb=document.createElement('tbody');
  let grand=0;
  perJuror.forEach((dist, jurorName)=>{
    const tr=document.createElement('tr');
    tr.appendChild(td(jurorName));
    tr.appendChild(td(String(budgets.get(jurorName)||0)));
    let rowSum=0; finalists.forEach(f=>{ const c=dist[f.name]||0; rowSum+=c; tr.appendChild(td(String(c))); });
    tr.appendChild(td(String(rowSum))); grand+=rowSum; tb.appendChild(tr);
  });
  const foot=document.createElement('tr'); foot.style.fontWeight='600';
  foot.appendChild(td('Totals')); foot.appendChild(td('—'));
  finalists.forEach(f=>foot.appendChild(td(String(finalistTotals.get(f.name)||0))));
  foot.appendChild(td(String(grand)));
  tb.appendChild(foot); table.appendChild(tb);
  UI.juryWrap.appendChild(table);
  const note=document.createElement('div'); note.className='muted';
  note.textContent='Grand total is 18 (jury). Finalists have base 3 each → total 27.';
  UI.juryWrap.appendChild(note);
  function th(t){ const el=document.createElement('th'); el.textContent=t; return el; }
  function td(t){ const el=document.createElement('td'); el.textContent=t; return el; }
}

/* ---------- Wiring ---------- */
function resetAll(){
  S.phase=0; S.round=0; S.roster=[]; S.alliances=[]; S.p1Jurors=[]; S.p2Jurors=[]; S.p3Jurors=[]; S.finalists=[]; S.p1Drawn={};
  S.lockpickHolder=null; S.lockpickClueHolder=null; S.showmances=new Set();
  S.voteCols=[]; S.voteData={}; S.avoidVoteTargets.clear(); S.targetVoteBoost=null; S.lastAvoidTarget=null;
  S.evtCooldown.clear(); S.pendingIntro=null;
  UI.events.innerHTML=''; UI.juryWrap.innerHTML=''; UI.progressBody.innerHTML=''; UI.phaseLabel.textContent='';
  UI.voteChart.innerHTML='';
  UI.nextBtn.classList.add('hidden'); UI.againBtn.classList.add('hidden');
  UI.alliancesBox.innerHTML='<div class="muted">Generated at start and may evolve. Alliances influence votes and duel picks.</div>';
}
function startGame(){
  if(S.phase){ if(!confirm('A season is in progress. Start a new one?')) return; }
  const names=UI.playersInput.value.split('\n').map(s=>s.trim()).filter(Boolean);
  if(names.length!==13){ alert('Enter exactly 13 players.'); return; }
  const photos=UI.photosInput.value.split('\n').map(s=>s.trim());
  if(!S.roster.length){
    S.roster=names.map((n,i)=>({
      name:n, img:photos[i]||'', p1:Array(5).fill(''), p2:Array(5).fill(''), p3:false, alive:true,
      attr:{soc:5,comp:5,strat:5}, rel:{} }));
    S.roster.forEach(a=>S.roster.forEach(b=>{ if(a.name!==b.name) a.rel[b.name]=5; }));
  }
  genAlliances(); renderAlliances(); renderProgress();
  S.phase=1; S.round=1; UI.phaseLabel.textContent='Phase 1 — Round 1 of 5';
  UI.nextBtn.classList.remove('hidden'); UI.againBtn.classList.add('hidden');
  UI.events.innerHTML='';
  logEventWithImages('Phase 1 begins. R1–R4: draw 6, vote, challenge. R5: Last Chance Vote.',[]);
}
function nextStep(){
  if(S.phase===1){
    if(S.pendingIntro){ logEventWithImages(S.pendingIntro.text, []); S.pendingIntro=null; return; }
    return phase1Round();
  }
  if(S.phase===2){
    if(S.pendingIntro){ logEventWithImages(S.pendingIntro.text, []); S.pendingIntro=null; return; }
    return phase2Round();
  }
  if(S.phase===3){
    if(S.pendingIntro){ logEventWithImages(S.pendingIntro.text, []); S.pendingIntro=null; return; }
    return phase3Run();
  }
}
function simulateAgain(){
  const names=S.roster.map(p=>p.name), imgs=S.roster.map(p=>p.img);
  UI.playersInput.value=names.join('\n'); UI.photosInput.value=imgs.join('\n');
  resetAll(); startGame();
}
UI.startBtn.addEventListener('click', startGame);
UI.resetBtn.addEventListener('click', resetAll);
UI.nextBtn.addEventListener('click', nextStep);
UI.againBtn.addEventListener('click', simulateAgain);

/* Utilities used above */
function syncInputsFromRoster(){
  UI.playersInput.value=S.roster.map(p=>p.name).join('\n');
  UI.photosInput.value=S.roster.map(p=>p.img).join('\n');
}
</script>
</body>
</html>