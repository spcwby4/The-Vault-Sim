<!DOCTYPE html>
<html>
<head>
  <title>The Vault Simulator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: row;
      gap: 20px;
    }
    #leftColumn {
      flex: 3;
    }
    #rightColumn {
      flex: 1;
    }
    textarea {
      width: 100%;
      height: 100px;
    }
    button {
      margin-top: 10px;
      padding: 10px 15px;
    }
    table, th, td {
      border: 1px solid #000;
      border-collapse: collapse;
      padding: 5px;
      text-align: center;
    }
    th {
      background-color: #eee;
    }
    .eliminated {
      background-color: #ccc;
      text-decoration: line-through;
    }
    #log {
      height: 200px;
      overflow-y: scroll;
      border: 1px solid #ccc;
      padding: 10px;
      background: #fdfdfd;
      margin-top: 10px;
    }
    #log div {
      margin-bottom: 5px;
    }
    summary {
      font-weight: bold;
      cursor: pointer;
    }
    h3 {
      margin-top: 25px;
      margin-bottom: 5px;
    }
    ul {
      padding-left: 20px;
    }
  </style>
</head>
<body>

<div id="leftColumn">
  <h1>The Vault Simulator</h1>
  <textarea id="playerInput" placeholder="Enter 12 players, one per line..."></textarea>
  <br>
  <button id="startBtn" onclick="startGame()">Start Game</button>
  <button id="nextBtn" onclick="runRound()" style="display:none;">Next Round</button>

  <div id="log"></div>
  <div id="liveVotingMatrix"></div>
  <div id="progressTable"></div>
  <div id="votingChart"></div>
</div>

<div id="rightColumn">
  <details open>
    <summary>Alliances</summary>
    <div id="alliancesBox"></div>
  </details>
</div>

<script>
let players = [];
let round = 1;
let phase = 1;
let phase3Step = 0;
let finalists = [];
let eliminated = [];
let jury = [];
let lockpickHolder = null;
let lockpickUsed = false;
let vaults = [3, 5, 7, 9, 11, 13, 15, 17, 19, 20, 21, 22];

function startGame() {
  const input = document.getElementById("playerInput").value.trim().split("\n").map(s => s.trim()).filter(Boolean);
  if (input.length !== 12) return alert("Enter exactly 12 players.");
  players = input.map(name => ({
    name,
    alliance: [],
    key1: false,
    key2: false,
    key3: false,
    totalKeys: 0,
    totalFinalKeys: 0,
    eliminated: false
  }));
  assignAlliances();
  updateAlliancesBox();
  updateTable();
  clearLog();
  log(`Game started with 12 players.`);
  document.getElementById("startBtn").style.display = "none";
  document.getElementById("nextBtn").style.display = "inline";
}

function assignAlliances() {
  const a1 = shuffle(players).slice(0, 5);
  const a2 = shuffle(players).slice(0, 5);
  const a3 = shuffle(players).slice(0, 5);
  for (let p of players) {
    p.alliance = [];
    if (a1.includes(p)) p.alliance.push("A");
    if (a2.includes(p)) p.alliance.push("B");
    if (a3.includes(p)) p.alliance.push("C");
  }
}

function updateAlliancesBox() {
  const groups = { A: [], B: [], C: [] };
  players.forEach(p => {
    p.alliance.forEach(a => {
      if (!groups[a]) groups[a] = [];
      if (!groups[a].includes(p.name)) groups[a].push(p.name);
    });
  });
  let html = "";
  for (const a of ["A", "B", "C"]) {
    html += `<strong>Alliance ${a}</strong><ul>`;
    groups[a].forEach(name => html += `<li>${name}</li>`);
    html += "</ul>";
  }
  document.getElementById("alliancesBox").innerHTML = html;
}

function runRound() {
  clearLog();
  if (phase === 1) return runPhase1();
  if (phase === 2) return runPhase2();
  if (phase === 3) return phase3Step === 0 ? runPhase3Vote() : runPhase3Challenge();
  if (phase === 4) return runFinale();
}

function runPhase1() {
  const eligible = players.filter(p => !p.key1 && !p.eliminated);
  if (round > 4) {
    players.forEach(p => {
      if (!p.key1) {
        p.eliminated = true;
        eliminated.push(p);
      }
    });
    phase = 2;
    round = 1;
    return runRound();
  }

  const drawn = shuffle(eligible).slice(0, 4);
  log(`Phase 1 – Round ${round}`);
  log(`Drawn players: ${drawn.map(p => p.name).join(", ")}`);

  if (!lockpickHolder && !lockpickUsed && Math.random() < 0.33) {
    lockpickHolder = drawn[Math.floor(Math.random() * drawn.length)];
    log(`${lockpickHolder.name} found the Lockpick!`);
  }

  const voters = players.filter(p => !p.eliminated);
  const votingDetails = [];
  const voteTally = {};
  let voteWinner;

  if (lockpickHolder && drawn.includes(lockpickHolder)) {
    voteWinner = lockpickHolder;
    log(`${voteWinner.name} uses the Lockpick to override the vote.`);
    lockpickHolder = null;
    lockpickUsed = true;
  } else {
    for (let v of voters) {
      const voteFor = pickAllyOrRandom(v, drawn);
      votingDetails.push({ voter: v.name, votee: voteFor.name });
      voteTally[voteFor.name] = (voteTally[voteFor.name] || 0) + 1;
    }
    const sorted = Object.entries(voteTally).sort((a, b) => b[1] - a[1]);
    const topVotes = sorted.filter(e => e[1] === sorted[0][1]);
    const winnerName = topVotes.length === 1
      ? topVotes[0][0]
      : topVotes[Math.floor(Math.random() * topVotes.length)][0];
    voteWinner = drawn.find(p => p.name === winnerName);
    log(`${voteWinner.name} wins the vote key.`);
  }

  voteWinner.key1 = true;
  voteWinner.totalKeys++;

  const challengers = drawn.filter(p => p !== voteWinner);
  const challengeWinner = challengers[Math.floor(Math.random() * challengers.length)];
  challengeWinner.key1 = true;
  challengeWinner.totalKeys++;
  log(`${challengeWinner.name} wins the challenge key.`);

  displayVotingMatrix(round, votingDetails, voteWinner.name, "Phase 1");
  round++;
  updateTable();
}
function runPhase2() {
  const noKey = players.filter(p => !p.key2 && !p.eliminated);
  const keyholders = players.filter(p => p.key2 && !p.eliminated);
  const allVoters = players.filter(p => !p.eliminated);
  const eligible = noKey;

  if (round > 4 || noKey.length === 0) {
    players.forEach(p => {
      if (!p.key2 && !p.eliminated) {
        p.eliminated = true;
        eliminated.push(p);
      }
    });
    phase = 3;
    round = 1;
    return runRound();
  }

  log(`Phase 2 – Round ${round}`);

  if (!lockpickHolder && !lockpickUsed && Math.random() < 0.33) {
    const finder = noKey[Math.floor(Math.random() * noKey.length)];
    lockpickHolder = finder;
    log(`${finder.name} discovers the Lockpick!`);
  }

  let votingDetails = [];
  let voteTally = {};
  let voteWinner = null;

  if (lockpickHolder && noKey.includes(lockpickHolder)) {
    voteWinner = lockpickHolder;
    lockpickUsed = true;
    lockpickHolder = null;
    log(`${voteWinner.name} uses the Lockpick to override the vote.`);
  } else {
    for (let v of allVoters) {
      const voteFor = pickAllyOrRandom(v, noKey);
      votingDetails.push({ voter: v.name, votee: voteFor.name });
      voteTally[voteFor.name] = (voteTally[voteFor.name] || 0) + 1;
    }
    const sorted = Object.entries(voteTally).sort((a, b) => b[1] - a[1]);
    const topVotes = sorted.filter(e => e[1] === sorted[0][1]);
    const winnerName = topVotes.length === 1
      ? topVotes[0][0]
      : null;

    if (winnerName) {
      voteWinner = noKey.find(p => p.name === winnerName);
      log(`${voteWinner.name} wins the vote and must select an opponent.`);
    } else {
      const tiedNames = topVotes.map(e => e[0]);
      const duelists = noKey.filter(p => tiedNames.includes(p.name));
      log(`Vote ties between: ${duelists.map(p => p.name).join(", ")}. They must duel!`);
      const winner = duelists[Math.floor(Math.random() * duelists.length)];
      winner.key2 = true;
      winner.totalKeys++;
      log(`${winner.name} wins the duel and earns a Phase 2 key.`);
      displayVotingMatrix(round, votingDetails, "TIE", "Phase 2");
      round++;
      updateTable();
      return;
    }
  }

  const duelOptions = noKey.filter(p => p !== voteWinner);
  const opponent = pickAllyOrRandom(voteWinner, duelOptions);
  const duelists = [voteWinner, opponent];
  const winner = duelists[Math.floor(Math.random() * duelists.length)];
  winner.key2 = true;
  winner.totalKeys++;
  log(`${winner.name} wins the duel between ${voteWinner.name} and ${opponent.name}.`);

  displayVotingMatrix(round, votingDetails, voteWinner.name, "Phase 2");
  round++;
  updateTable();
}
function runPhase3Vote() {
  const active = players.filter(p => !p.eliminated && p.key1 && p.key2);
  log(`Phase 3 – Final 4 Vote`);

  const votingDetails = [];
  const voteTally = {};
  for (let v of active) {
    const options = active.filter(p => p !== v);
    const voteFor = pickAllyOrRandom(v, options);
    votingDetails.push({ voter: v.name, votee: voteFor.name });
    voteTally[voteFor.name] = (voteTally[voteFor.name] || 0) + 1;
  }
  const sorted = Object.entries(voteTally).sort((a, b) => b[1] - a[1]);
  window.phase3Votes = { sorted, votingDetails };
  displayVotingMatrix(round, votingDetails, sorted[0][0], "Phase 3");
  phase3Step = 1;
}

function runPhase3Challenge() {
  const active = players.filter(p => !p.eliminated && p.key1 && p.key2);
  const { sorted } = window.phase3Votes;
  let voteWinner, chosen, challengePair;

  if (sorted.length < 2 || sorted[0][1] > sorted[1][1]) {
    voteWinner = active.find(p => p.name === sorted[0][0]);
    const pickable = active.filter(p => p !== voteWinner);
    chosen = pickAllyOrRandom(voteWinner, pickable);
    challengePair = pickable.filter(p => p !== chosen);
    const challengeWinner = challengePair[Math.floor(Math.random() * challengePair.length)];
    finalists = [voteWinner, chosen, challengeWinner];
    jury.push(challengePair.find(p => p !== challengeWinner));
    log(`${voteWinner.name} brings ${chosen.name} to the finale.`);
    log(`${challengeWinner.name} wins the final duel.`);
  } else {
    const tied = sorted.filter(x => x[1] === sorted[0][1]).map(x => x[0]);
    const duelists = active.filter(p => tied.includes(p.name));
    const untied = active.filter(p => !tied.includes(p.name));
    const challengeWinner = duelists[Math.floor(Math.random() * duelists.length)];
    finalists = [...untied, challengeWinner];
    jury.push(duelists.find(p => p !== challengeWinner));
    log(`Vote tied. ${untied.map(p => p.name).join(" and ")} move on. ${challengeWinner.name} wins the duel.`);
  }

  for (let p of players) {
    if (!finalists.includes(p)) p.eliminated = true;
  }

  finalists.forEach(p => {
    p.key3 = true;
    p.totalKeys++;
  });

  phase = 4;
  round = 1;
  updateTable();
  phase3Step = 0;
}

function runFinale() {
  log(`Vault Finale Begins!`);

  const fNames = finalists.map(f => f.name);
  players.forEach(p => {
    if (!fNames.includes(p.name)) p.eliminated = true;
  });

  finalists.forEach(p => {
    p.totalFinalKeys = 3;
  });

  const p1Jury = eliminated.filter(p => p.key1 && !p.key2);
  const p2Jury = eliminated.filter(p => p.key2 && !p.key3);
  const p3Elim = eliminated.filter(p => !p.key3 && p.key2 && p.key1);

  let juryMatrix = {};
  function distribute(jurorList, keys) {
    for (let juror of jurorList) {
      juryMatrix[juror.name] = {};
      for (let i = 0; i < keys; i++) {
        const giveTo = shuffle(finalists)[0];
        giveTo.totalFinalKeys++;
        juryMatrix[juror.name][giveTo.name] = (juryMatrix[juror.name][giveTo.name] || 0) + 1;
      }
    }
  }

  distribute(p1Jury, 1);
  distribute(p2Jury, 2);
  distribute(p3Elim, 4);

  let html = `<h3>Jury Key Distribution</h3><table><tr><th>Juror</th>`;
  finalists.forEach(f => html += `<th>${f.name}</th>`);
  html += "</tr>";
  Object.entries(juryMatrix).forEach(([juror, dist]) => {
    html += `<tr><td>${juror}</td>`;
    finalists.forEach(f => {
      html += `<td>${dist[f.name] || 0}</td>`;
    });
    html += "</tr>";
  });
  html += "</table>";
  document.getElementById("votingChart").innerHTML = html;

  finalists.forEach(p => {
    const guess = vaults.filter(k => k <= p.totalFinalKeys).pop() || 3;
    p.vaultGuess = guess;
  });

  const opened = finalists.filter(p => p.totalFinalKeys >= p.vaultGuess);
  if (opened.length > 0) {
    const winner = opened.sort((a, b) => b.vaultGuess - a.vaultGuess)[0];
    log(`${winner.name} opens the ${winner.vaultGuess}-key vault and WINS!`);
  } else {
    const fallback = players.find(p => !p.key3 && p.key2 && p.key1);
    log(`No vaults opened. ${fallback.name} (4th place) wins by default.`);
  }

  updateTable();
  document.getElementById("nextBtn").textContent = "Simulate Again";
  document.getElementById("nextBtn").onclick = () => location.reload();
}

function pickAllyOrRandom(p, options) {
  const allies = options.filter(o => o.alliance.some(a => p.alliance.includes(a)));
  return allies.length > 0 ? allies[Math.floor(Math.random() * allies.length)] : options[Math.floor(Math.random() * options.length)];
}

function shuffle(arr) {
  return arr.slice().sort(() => Math.random() - 0.5);
}

function displayVotingMatrix(roundNum, votes, winner, phase) {
  let html = `<details open><summary>${phase} – Round ${roundNum} Voting Matrix</summary><table><tr><th>Voter</th><th>Votee</th></tr>`;
  for (let v of votes) {
    html += `<tr><td>${v.voter}</td><td>${v.votee}</td></tr>`;
  }
  html += `<tr><td colspan="2"><strong>Vote Winner: ${winner}</strong></td></tr></table></details>`;
  document.getElementById("liveVotingMatrix").innerHTML = html;
}

function updateTable() {
  let html = "<h3>Progress Chart</h3><table><tr><th>Player</th><th>Key 1</th><th>Key 2</th><th>Key 3</th><th>Total Keys</th></tr>";
  players.forEach(p => {
    html += `<tr class="${p.eliminated ? 'eliminated' : ''}"><td>${p.name}</td><td>${p.key1 ? '✅' : ''}</td><td>${p.key2 ? '✅' : ''}</td><td>${p.key3 ? '✅' : ''}</td><td>${p.totalKeys}</td></tr>`;
  });
  html += "</table>";
  document.getElementById("progressTable").innerHTML = html;
}

function clearLog() {
  document.getElementById("log").innerHTML = "";
  document.getElementById("liveVotingMatrix").innerHTML = "";
}
</script>
</body>
</html>