<!DOCTYPE html>
<html>
<head>
  <title>The Vault Simulator</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    textarea { width: 100%; height: 100px; }
    button { margin-top: 10px; padding: 10px; }
    table, th, td { border: 1px solid black; border-collapse: collapse; padding: 5px; }
    table { width: 100%; margin-top: 10px; }
    th { background-color: #f0f0f0; }
    .eliminated { background-color: #ddd; text-decoration: line-through; }
    #log { height: 200px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; margin-top: 10px; background: #fdfdfd; }
    #liveVotingMatrix details, #votingChart details { margin-bottom: 8px; }
    summary { font-weight: bold; cursor: pointer; }
    h3 { margin-top: 25px; }
  </style>
</head>
<body>

<h1>The Vault Simulator</h1>

<textarea id="playerInput" placeholder="Enter 12 players, one per line..."></textarea>
<br>
<button id="startBtn" onclick="startGame()">Start Game</button>
<button id="nextBtn" onclick="runRound()" style="display:none;">Next Round</button>

<div id="alliancesBox"></div>
<div id="log"></div>
<div id="liveVotingMatrix"></div>
<div id="progressTable"></div>
<div id="votingChart"></div>

<script>
let players = [];
let round = 1;
let phase = 1;
let phase3Step = 0;
let finalists = [];
let eliminated = [];
let jury = [];
let votingChart = [];
let lockpickHolder = null;
let lockpickUsed = false;
const vaults = [3, 5, 7, 9, 11, 13, 15, 17, 19, 20, 21, 22];

function startGame() {
  const input = document.getElementById("playerInput").value.trim().split("\n").map(s => s.trim()).filter(Boolean);
  if (input.length !== 12) return alert("Enter exactly 12 players.");
  players = input.map(name => ({
    name, alliance: [], key1: false, key2: false, key3: false, totalKeys: 0, totalFinalKeys: 0, bonusKeys: 0, eliminated: false
  }));
  assignAlliances();
  updateAlliancesBox();
  updateTable();
  log(`Game started with 12 players.`);
  document.getElementById("startBtn").style.display = "none";
  document.getElementById("nextBtn").style.display = "inline";
}

function runRound() {
  window.__logClearedThisRound = false;
  if (phase === 1) return runPhase1();
  if (phase === 2) return runPhase2();
  if (phase === 3) return phase3Step === 0 ? runPhase3Vote() : runPhase3Challenge();
  if (phase === 4) return runFinale();
}

function assignAlliances() {
  const a1 = shuffle(players).slice(0, 5);
  const a2 = shuffle(players).slice(0, 5);
  const a3 = shuffle(players).slice(0, 5);
  for (let p of players) {
    p.alliance = [];
    if (a1.includes(p)) p.alliance.push("A");
    if (a2.includes(p)) p.alliance.push("B");
    if (a3.includes(p)) p.alliance.push("C");
  }
}

function updateAlliancesBox() {
  const allianceGroups = { A: [], B: [], C: [] };
  for (let p of players) { p.alliance.forEach(a => allianceGroups[a].push(p.name)); }
  let html = "<h3>Alliances</h3>";
  for (let key in allianceGroups) {
    html += `<strong>Alliance ${key}</strong><ul>`;
    allianceGroups[key].forEach(name => html += `<li>${name}</li>`);
    html += "</ul>";
  }
  document.getElementById("alliancesBox").innerHTML = html;
}

function runPhase1() {
  const eligible = players.filter(p => !p.key1 && !p.eliminated);
  if (round > 4) {
    players.forEach(p => {
      if (!p.key1) {
        p.eliminated = true;
        eliminated.push(p);
      }
    });
    phase = 2; round = 1;
    return runRound();
  }

  const drawn = shuffle(eligible).slice(0, 4);
  log(`Phase 1 – Round ${round}`);
  log(`Drawn players: ${drawn.map(p => p.name).join(", ")}`);

  if (!lockpickHolder && !lockpickUsed && Math.random() < 0.33) {
    lockpickHolder = drawn[Math.floor(Math.random() * drawn.length)];
    log(`${lockpickHolder.name} found the Lockpick!`);
  }

  const voters = players.filter(p => !p.eliminated);
  const votingDetails = [];
  const voteTally = {};
  let voteWinner;

  if (lockpickHolder && drawn.includes(lockpickHolder)) {
    voteWinner = lockpickHolder;
    log(`${voteWinner.name} uses the Lockpick to guarantee the vote key.`);
    lockpickHolder = null;
    lockpickUsed = true;
  } else {
    for (let v of voters) {
      const voteFor = pickAllyOrRandom(v, drawn);
      votingDetails.push({ voter: v.name, votee: voteFor.name });
      voteTally[voteFor.name] = (voteTally[voteFor.name] || 0) + 1;
    }
    const winnerName = Object.entries(voteTally).sort((a, b) => b[1] - a[1])[0][0];
    voteWinner = drawn.find(p => p.name === winnerName);
    log(`${voteWinner.name} wins the vote key.`);
  }

  voteWinner.key1 = true;
  voteWinner.totalKeys++;

  const challengers = drawn.filter(p => p !== voteWinner);
  const challengeWinner = challengers[Math.floor(Math.random() * challengers.length)];
  challengeWinner.key1 = true;
  challengeWinner.totalKeys++;
  log(`${challengeWinner.name} wins the challenge key.`);

  recordVotes(round, votingDetails, voteWinner.name, "Phase 1");
  round++;
  updateTable();
}

function runPhase2() {
  const active = players.filter(p => !p.eliminated && !p.key2);
  const keyholders = players.filter(p => p.key2);

  if (round > 4 || active.length === 0) {
    players.forEach(p => {
      if (!p.key2 && !p.eliminated) {
        p.eliminated = true;
        eliminated.push(p);
      }
    });
    phase = 3; round = 1;
    return runRound();
  }

  log(`Phase 2 – Round ${round}`);

  if (!lockpickHolder && !lockpickUsed && Math.random() < 0.33) {
    const pool = players.filter(p => !p.key2 && !p.eliminated);
    if (pool.length > 0) {
      lockpickHolder = pool[Math.floor(Math.random() * pool.length)];
      log(`${lockpickHolder.name} discovered the Lockpick!`);
    }
  }

  const voters = players.filter(p => !p.eliminated);
  const votingDetails = [];
  const voteTally = {};
  const voteTargets = active;

  let voteWinner;

  if (lockpickHolder && voteTargets.includes(lockpickHolder)) {
    voteWinner = lockpickHolder;
    log(`${voteWinner.name} uses the Lockpick to override the vote.`);
    lockpickHolder = null;
    lockpickUsed = true;
  } else {
    for (let v of voters) {
      const voteFor = pickAllyOrRandom(v, voteTargets);
      votingDetails.push({ voter: v.name, votee: voteFor.name });
      voteTally[voteFor.name] = (voteTally[voteFor.name] || 0) + 1;
    }
    const winnerName = Object.entries(voteTally).sort((a, b) => b[1] - a[1])[0][0];
    voteWinner = active.find(p => p.name === winnerName);
    log(`${voteWinner.name} wins the vote.`);
  }

  const opponents = active.filter(p => p !== voteWinner);
  const chosenOpponent = pickAllyOrRandom(voteWinner, opponents);
  log(`${voteWinner.name} chooses to duel ${chosenOpponent.name}.`);

  const duelWinner = Math.random() < 0.5 ? voteWinner : chosenOpponent;
  duelWinner.key2 = true;
  duelWinner.totalKeys++;
  log(`${duelWinner.name} wins the duel and earns the key.`);

  recordVotes(round, votingDetails, voteWinner.name, "Phase 2");
  round++;
  updateTable();
}
function runPhase3Vote() {
  const active = players.filter(p => !p.eliminated && p.key1 && p.key2);
  log(`Phase 3 – Final 4 Vote`);
  const votingDetails = [];
  const voteTally = {};
  for (let v of active) {
    const options = active.filter(p => p !== v);
    const voteFor = pickAllyOrRandom(v, options);
    votingDetails.push({ voter: v.name, votee: voteFor.name });
    voteTally[voteFor.name] = (voteTally[voteFor.name] || 0) + 1;
  }
  const sorted = Object.entries(voteTally).sort((a, b) => b[1] - a[1]);
  log(`Votes cast. Click Next Round to resolve challenge.`);
  window.phase3Votes = { sorted, votingDetails };
  recordVotes(round, votingDetails, sorted[0][0], "Phase 3");
  phase3Step = 1;
}

function runPhase3Challenge() {
  const active = players.filter(p => !p.eliminated && p.key1 && p.key2);
  const { sorted } = window.phase3Votes;
  let voteWinner;
  let pick, rest;

  if (sorted.length < 2 || sorted[0][1] > sorted[1][1]) {
    voteWinner = active.find(p => p.name === sorted[0][0]);
    pick = active.filter(p => p !== voteWinner);
    const ally = pickAllyOrRandom(voteWinner, pick);
    rest = pick.filter(p => p !== ally);
    const challengeWinner = rest[Math.floor(Math.random() * rest.length)];
    finalists = [voteWinner, ally, challengeWinner];
    log(`${voteWinner.name} brings ${ally.name} to the finale.`);
    log(`${challengeWinner.name} wins the final challenge.`);
  } else {
    const tied = sorted.filter(e => e[1] === sorted[0][1]).map(e => e[0]);
    const duelists = active.filter(p => tied.includes(p.name));
    const untied = active.filter(p => !tied.includes(p.name));
    const challengeWinner = duelists[Math.floor(Math.random() * duelists.length)];
    finalists = [...untied, challengeWinner];
    log(`${untied.map(p => p.name).join(" and ")} advance. ${challengeWinner.name} wins the duel for the final spot.`);
  }

  players.forEach(p => {
    if (!finalists.includes(p)) {
      p.eliminated = true;
      jury.push(p);
    } else {
      p.key3 = true;
      p.totalKeys++;
    }
  });

  phase = 4;
  round = 1;
  window.phase3Votes = null;
  phase3Step = 0;
  updateTable();
}

function runFinale() {
  log("Vault Finale Begins!");
  finalists.forEach(f => f.totalFinalKeys = 3);
  let remainingKeys = 16;

  for (let j of jury) {
    const keysToGive = Math.min(remainingKeys, phase === 2 ? 2 : 1);
    j.bonusKeysAssigned = {};
    const receivers = shuffle(finalists).slice(0, Math.min(keysToGive, 2));
    receivers.forEach(r => {
      j.bonusKeysAssigned[r.name] = (j.bonusKeysAssigned[r.name] || 0) + 1;
      r.totalFinalKeys++;
      remainingKeys--;
    });
  }

  finalists.forEach(f => {
    const guess = Math.min(...vaults.filter(k => k <= f.totalFinalKeys + 1).reverse());
    f.vaultGuess = guess;
  });

  const opened = finalists.filter(f => f.totalFinalKeys >= f.vaultGuess);
  if (opened.length > 0) {
    const winner = opened.sort((a, b) => b.vaultGuess - a.vaultGuess)[0];
    log(`${winner.name} opens the ${winner.vaultGuess}-key vault and wins!`);
  } else {
    const altWinner = players.find(p => p.eliminated && !p.key3);
    log(`No vaults opened. ${altWinner.name} (4th place) wins by default.`);
  }

  updateTable();

  // Jury vote matrix
  let juryVoteTable = "<h3>Jury Key Vote Matrix</h3><table><tr><th>Juror</th>";
  finalists.forEach(f => juryVoteTable += `<th>${f.name}</th>`);
  juryVoteTable += "</tr>";
  jury.forEach(j => {
    juryVoteTable += `<tr><td>${j.name}</td>`;
    finalists.forEach(f => {
      const keys = j.bonusKeysAssigned?.[f.name] || 0;
      juryVoteTable += `<td>${keys}</td>`;
    });
    juryVoteTable += "</tr>";
  });
  juryVoteTable += "</table>";
  document.getElementById("votingChart").innerHTML += juryVoteTable;
}

function pickAllyOrRandom(player, options) {
  const allies = options.filter(o => o.alliance.some(a => player.alliance.includes(a)));
  return allies.length > 0 ? allies[Math.floor(Math.random() * allies.length)] : options[Math.floor(Math.random() * options.length)];
}

function shuffle(arr) {
  return arr.slice().sort(() => Math.random() - 0.5);
}

function log(text) {
  if (!window.__logClearedThisRound) {
    document.getElementById("log").innerHTML = "";
    window.__logClearedThisRound = true;
  }
  document.getElementById("log").innerHTML += `<div>${text}</div>`;
}

function updateTable() {
  let html = "<h3>Progress Chart</h3><table><tr><th>Player</th><th>Key 1</th><th>Key 2</th><th>Key 3</th><th>Total Keys</th></tr>";
  for (let p of players) {
    html += `<tr class="${p.eliminated ? 'eliminated' : ''}"><td>${p.name}</td><td>${p.key1 ? '✅' : ''}</td><td>${p.key2 ? '✅' : ''}</td><td>${p.key3 ? '✅' : ''}</td><td>${p.totalKeys}</td></tr>`;
  }
  html += "</table>";
  document.getElementById("progressTable").innerHTML = html;
}

function recordVotes(roundNum, votes, winner, phase) {
  let html = `<details open><summary>${phase} – Round ${roundNum} Voting Matrix</summary><table><tr><th>Voter</th><th>Votee</th></tr>`;
  for (let v of votes) {
    html += `<tr><td>${v.voter}</td><td>${v.votee}</td></tr>`;
  }
  html += `<tr><td colspan="2"><strong>Vote Winner: ${winner}</strong></td></tr></table></details>`;
  document.getElementById("liveVotingMatrix").innerHTML = html;
  votingChart.push(html);
}
</script>
</body>
</html>