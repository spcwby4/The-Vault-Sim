<!DOCTYPE html>
<html>
<head>
  <title>The Vault Simulator</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    textarea { width: 100%; height: 100px; }
    button { margin-top: 10px; padding: 10px; }
    table, th, td { border: 1px solid black; border-collapse: collapse; padding: 5px; }
    table { width: 100%; margin-top: 10px; }
    th { background-color: #f0f0f0; }
    .eliminated { background-color: #ddd; text-decoration: line-through; }
    #log { height: 200px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; margin-top: 10px; background: #fdfdfd; }
    #log div { margin-bottom: 4px; }
    #alliancesBox { margin-top: 20px; }
    summary { font-weight: bold; cursor: pointer; }
    h3 { margin-top: 25px; }
  </style>
</head>
<body>

<h1>The Vault Simulator</h1>

<textarea id="playerInput" placeholder="Enter 12 players, one per line..."></textarea>
<br>
<button id="startBtn" onclick="startGame()">Start Game</button>
<button id="nextBtn" onclick="runRound()" style="display:none;">Next Round</button>

<div id="alliancesBox"></div>
<div id="log"></div>
<div id="liveVotingMatrix"></div>
<div id="progressTable"></div>
<div id="votingChart"></div>

<script>
let players = [];
let round = 1;
let phase = 1;
let phase3Step = 0;
let finalists = [];
let eliminated = [];
let jury = [];
let lockpickHolder = null;
let lockpickUsed = false;
let vaults = [3, 5, 7, 9, 11, 13, 15, 17, 19, 20, 21, 22];

function startGame() {
  const input = document.getElementById("playerInput").value.trim().split("\n").map(s => s.trim()).filter(Boolean);
  if (input.length !== 12) return alert("Enter exactly 12 players.");
  players = input.map(name => ({
    name, alliance: [], key1: false, key2: false, key3: false, totalKeys: 0, totalFinalKeys: 0, eliminated: false
  }));
  assignAlliances();
  updateAlliancesBox();
  updateTable();
  clearLog();
  log(`Game started with 12 players.`);
  document.getElementById("startBtn").style.display = "none";
  document.getElementById("nextBtn").style.display = "inline";
}

function assignAlliances() {
  const a1 = shuffle(players).slice(0, 5);
  const a2 = shuffle(players).slice(0, 5);
  const a3 = shuffle(players).slice(0, 5);
  for (let p of players) {
    p.alliance = [];
    if (a1.includes(p)) p.alliance.push("A");
    if (a2.includes(p)) p.alliance.push("B");
    if (a3.includes(p)) p.alliance.push("C");
  }
}

function updateAlliancesBox() {
  const groups = { A: [], B: [], C: [] };
  players.forEach(p => {
    p.alliance.forEach(a => {
      if (!groups[a]) groups[a] = [];
      groups[a].push(p.name);
    });
  });
  let html = "<h3>Alliances</h3>";
  for (const a of ["A", "B", "C"]) {
    html += `<strong>Alliance ${a}</strong><ul>`;
    groups[a].forEach(name => html += `<li>${name}</li>`);
    html += "</ul>";
  }
  document.getElementById("alliancesBox").innerHTML = html;
}

function runRound() {
  window.__logClearedThisRound = false;
  clearLog();
  if (phase === 1) return runPhase1();
  if (phase === 2) return runPhase2();
  if (phase === 3) return phase3Step === 0 ? runPhase3Vote() : runPhase3Challenge();
  if (phase === 4) return runFinale();
}

function runPhase1() {
  const eligible = players.filter(p => !p.key1 && !p.eliminated);
  if (round > 4) {
    players.forEach(p => {
      if (!p.key1) {
        p.eliminated = true;
        eliminated.push(p);
      }
    });
    phase = 2; round = 1;
    return runRound();
  }

  const drawn = shuffle(eligible).slice(0, 4);
  log(`Phase 1 – Round ${round}`);
  log(`Drawn players: ${drawn.map(p => p.name).join(", ")}`);

  if (!lockpickHolder && !lockpickUsed && Math.random() < 0.33) {
    lockpickHolder = drawn[Math.floor(Math.random() * drawn.length)];
    log(`${lockpickHolder.name} found the Lockpick!`);
  }

  const voters = players.filter(p => !p.eliminated);
  const votingDetails = [];
  const voteTally = {};
  let voteWinner;

  if (lockpickHolder && drawn.includes(lockpickHolder)) {
    voteWinner = lockpickHolder;
    log(`${voteWinner.name} uses the Lockpick to guarantee the vote key.`);
    lockpickHolder = null;
    lockpickUsed = true;
  } else {
    for (let v of voters) {
      const voteFor = pickAllyOrRandom(v, drawn);
      votingDetails.push({ voter: v.name, votee: voteFor.name });
      voteTally[voteFor.name] = (voteTally[voteFor.name] || 0) + 1;
    }
    const winnerName = Object.entries(voteTally).sort((a, b) => b[1] - a[1])[0][0];
    voteWinner = drawn.find(p => p.name === winnerName);
    log(`${voteWinner.name} wins the vote key.`);
  }

  voteWinner.key1 = true;
  voteWinner.totalKeys++;

  const challengers = drawn.filter(p => p !== voteWinner);
  const challengeWinner = challengers[Math.floor(Math.random() * challengers.length)];
  challengeWinner.key1 = true;
  challengeWinner.totalKeys++;
  log(`${challengeWinner.name} wins the challenge key.`);

  displayVotingMatrix(round, votingDetails, voteWinner.name, "Phase 1");
  round++;
  updateTable();
}

function runPhase2() {
  const active = players.filter(p => !p.eliminated && !p.key2);
  const keyholders = players.filter(p => p.key2);

  if (round > 4 || active.length === 0) {
    players.forEach(p => {
      if (!p.key2 && !p.eliminated) {
        p.eliminated = true;
        eliminated.push(p);
      }
    });
    phase = 3; round = 1;
    return runRound();
  }

  log(`Phase 2 – Round ${round}`);

  if (!lockpickHolder && !lockpickUsed && Math.random() < 0.33) {
    const pool = players.filter(p => !p.key2 && !p.eliminated);
    if (pool.length > 0) {
      lockpickHolder = pool[Math.floor(Math.random() * pool.length)];
      log(`${lockpickHolder.name} discovered the Lockpick!`);
    }
  }

  const voters = players.filter(p => !p.eliminated);
  const votingDetails = [];
  const voteTally = {};
  const voteTargets = active;

  let voteWinner;

  if (lockpickHolder && voteTargets.includes(lockpickHolder)) {
    voteWinner = lockpickHolder;
    log(`${voteWinner.name} uses the Lockpick to override the vote.`);
    lockpickHolder = null;
    lockpickUsed = true;
  } else {
    for (let v of voters) {
      const voteFor = pickAllyOrRandom(v, voteTargets);
      votingDetails.push({ voter: v.name, votee: voteFor.name });
      voteTally[voteFor.name] = (voteTally[voteFor.name] || 0) + 1;
    }
    const winnerName = Object.entries(voteTally).sort((a, b) => b[1] - a[1])[0][0];
    voteWinner = active.find(p => p.name === winnerName);
    log(`${voteWinner.name} wins the vote.`);
  }

  const opponents = active.filter(p => p !== voteWinner);
  const chosenOpponent = pickAllyOrRandom(voteWinner, opponents);
  log(`${voteWinner.name} chooses to duel ${chosenOpponent.name}.`);

  const duelWinner = Math.random() < 0.5 ? voteWinner : chosenOpponent;
  duelWinner.key2 = true;
  duelWinner.totalKeys++;
  log(`${duelWinner.name} wins the duel and earns the key.`);

  displayVotingMatrix(round, votingDetails, voteWinner.name, "Phase 2");
  round++;
  updateTable();
}
function runPhase3Vote() {
  const active = players.filter(p => !p.eliminated && p.key1 && p.key2);
  log(`Phase 3 – Final 4 Vote`);

  const votingDetails = [];
  const voteTally = {};
  for (let v of active) {
    const options = active.filter(p => p !== v);
    const voteFor = pickAllyOrRandom(v, options);
    votingDetails.push({ voter: v.name, votee: voteFor.name });
    voteTally[voteFor.name] = (voteTally[voteFor.name] || 0) + 1;
  }
  const sorted = Object.entries(voteTally).sort((a, b) => b[1] - a[1]);
  const voteWinner = sorted[0][0];

  window.phase3Votes = { sorted, votingDetails };
  displayVotingMatrix(round, votingDetails, voteWinner, "Phase 3");
  phase3Step = 1;
}

function runPhase3Challenge() {
  const active = players.filter(p => !p.eliminated && p.key1 && p.key2);
  const { sorted } = window.phase3Votes;

  let voteWinner;
  let chosen, challengePair;

  if (sorted.length < 2 || sorted[0][1] > sorted[1][1]) {
    voteWinner = active.find(p => p.name === sorted[0][0]);
    const pickable = active.filter(p => p !== voteWinner);
    chosen = pickAllyOrRandom(voteWinner, pickable);
    challengePair = pickable.filter(p => p !== chosen);
    const challengeWinner = challengePair[Math.floor(Math.random() * challengePair.length)];
    finalists = [voteWinner, chosen, challengeWinner];
    log(`${voteWinner.name} brings ${chosen.name} to finale.`);
    log(`${challengeWinner.name} wins the final duel.`);
    jury.push(challengePair.find(p => p !== challengeWinner));
  } else {
    const tied = sorted.filter(x => x[1] === sorted[0][1]).map(x => x[0]);
    const duelists = active.filter(p => tied.includes(p.name));
    const untied = active.filter(p => !tied.includes(p.name));
    const challengeWinner = duelists[Math.floor(Math.random() * duelists.length)];
    finalists = [...untied, challengeWinner];
    log(`${untied.map(p => p.name).join(" and ")} move on. ${challengeWinner.name} wins tie-breaker duel.`);
    jury.push(duelists.find(p => p !== challengeWinner));
  }

  for (let p of players) {
    if (!finalists.includes(p)) p.eliminated = true;
  }

  finalists.forEach(p => {
    p.key3 = true;
    p.totalKeys++;
  });

  phase = 4;
  round = 1;
  updateTable();
  phase3Step = 0;
}

function runFinale() {
  log(`Vault Finale Begins!`);

  const fNames = finalists.map(f => f.name);
  players.forEach(p => {
    if (!p.eliminated && !fNames.includes(p.name)) p.eliminated = true;
  });

  finalists.forEach(p => p.totalFinalKeys = 3);

  const p1Jury = eliminated.filter(p => p.key1 && !p.key2);
  const p2Jury = eliminated.filter(p => p.key2 && !p.key3);
  const p3Elim = eliminated.filter(p => !p.key3 && p.key2 && p.key1);

  let remainingKeys = 16;
  let juryMatrix = {};

  function distribute(jurorList, keysPerJuror) {
    for (let juror of jurorList) {
      juryMatrix[juror.name] = {};
      const recipients = shuffle(finalists).slice(0, Math.min(keysPerJuror, 3));
      for (let i = 0; i < keysPerJuror; i++) {
        const target = recipients[i % recipients.length];
        target.totalFinalKeys++;
        juryMatrix[juror.name][target.name] = (juryMatrix[juror.name][target.name] || 0) + 1;
        remainingKeys--;
      }
    }
  }

  distribute(p1Jury, 1);
  distribute(p2Jury, 2);
  distribute(p3Elim, 4);

  finalists.forEach(p => {
    const vaultGuess = vaults.filter(k => k <= p.totalFinalKeys).pop() || 3;
    p.vaultGuess = vaultGuess;
  });

  const opened = finalists.filter(p => p.totalFinalKeys >= p.vaultGuess);
  if (opened.length > 0) {
    const winner = opened.sort((a, b) => b.vaultGuess - a.vaultGuess)[0];
    log(`${winner.name} opens the ${winner.vaultGuess}-key vault and WINS!`);
  } else {
    const fallback = players.find(p => !p.key3 && p.key2 && p.key1);
    log(`No vaults opened. ${fallback.name} (4th place) wins by default.`);
  }

  // Jury key matrix
  let html = `<h3>Jury Key Vote Matrix</h3><table><tr><th>Juror</th>`;
  finalists.forEach(f => html += `<th>${f.name}</th>`);
  html += "</tr>";

  for (const [juror, votes] of Object.entries(juryMatrix)) {
    html += `<tr><td>${juror}</td>`;
    finalists.forEach(f => {
      html += `<td>${votes[f.name] || 0}</td>`;
    });
    html += "</tr>";
  }
  html += "</table>";
  document.getElementById("votingChart").innerHTML = html;

  updateTable();
}

function pickAllyOrRandom(p, options) {
  const allies = options.filter(o => o.alliance.some(a => p.alliance.includes(a)));
  return allies.length > 0 ? allies[Math.floor(Math.random() * allies.length)] : options[Math.floor(Math.random() * options.length)];
}

function shuffle(arr) {
  return arr.slice().sort(() => Math.random() - 0.5);
}

function displayVotingMatrix(roundNum, votes, winner, phase) {
  let html = `<details open><summary>${phase} – Round ${roundNum} Voting Matrix</summary><table><tr><th>Voter</th><th>Votee</th></tr>`;
  for (let v of votes) {
    html += `<tr><td>${v.voter}</td><td>${v.votee}</td></tr>`;
  }
  html += `<tr><td colspan="2"><strong>Vote Winner: ${winner}</strong></td></tr></table></details>`;
  document.getElementById("liveVotingMatrix").innerHTML = html;
}

function updateTable() {
  let html = "<h3>Progress Chart</h3><table><tr><th>Player</th><th>Key 1</th><th>Key 2</th><th>Key 3</th><th>Total Keys</th></tr>";
  players.forEach(p => {
    html += `<tr class="${p.eliminated ? 'eliminated' : ''}"><td>${p.name}</td><td>${p.key1 ? '✅' : ''}</td><td>${p.key2 ? '✅' : ''}</td><td>${p.key3 ? '✅' : ''}</td><td>${p.totalKeys}</td></tr>`;
  });
  html += "</table>";
  document.getElementById("progressTable").innerHTML = html;
}

function clearLog() {
  document.getElementById("log").innerHTML = "";
  document.getElementById("liveVotingMatrix").innerHTML = "";
}
</script>
</body>
</html>