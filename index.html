<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Vault Simulator</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      background: #f4f4f4;
      display: flex;
      gap: 20px;
    }
    textarea, button {
      margin-top: 10px;
      display: block;
    }
    #log, #progressTable, #votingChart, #alliancesBox {
      background: white;
      padding: 10px;
      border-radius: 5px;
      margin-top: 20px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 5px;
      text-align: center;
    }
    .keyholder {
      background-color: #d0f0c0;
    }
    .eliminated {
      background-color: #e0e0e0;
      color: #888;
    }
    #leftCol, #rightCol {
      flex: 1;
    }
  </style>
</head>
<body>
  <div id="leftCol">
    <h1>The Vault Simulator</h1>

    <label for="playerInput">Enter 12 players (one per line):</label>
    <textarea id="playerInput" rows="12" cols="30"></textarea>

    <button id="startBtn" onclick="startGame()">Start Game</button>
    <button id="nextBtn" onclick="runRound()" style="display:none">Run Next Round</button>

    <!-- Alliances Display -->
    <div id="alliancesBox"></div>

    <!-- Key Progress Table -->
    <div id="progressTable"></div>

    <!-- Voting Chart -->
    <div id="votingChart"></div>
  </div>

  <div id="rightCol">
    <!-- Round Log -->
    <div id="log"></div>
  </div>

  <script>
    let players = [];
let phase = 1;
let round = 1;
let lockpickHolder = null;
let lockpickUsed = false;
let eliminated = [];
let finalists = [];
let jury = [];
let vaults = [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22];
let alliances = {};
let voteLogs = [];
let votingChart = [];

function startGame() {
  const input = document.getElementById("playerInput").value.trim().split("\n").map(p => p.trim()).filter(Boolean);
  if (input.length !== 12) {
    alert("Please enter exactly 12 player names.");
    return;
  }
  players = input.map(name => ({
    name,
    key1: false,
    key2: false,
    key3: false,
    totalKeys: 0,
    eliminated: false,
    alliance: [],
    vault: null,
    bonusKeys: 0,
    totalFinalKeys: 0
  }));
  assignAlliances();
  updateAlliancesBox();
  document.getElementById("startBtn").style.display = "none";
  document.getElementById("nextBtn").style.display = "inline-block";
  runRound();
}

function assignAlliances() {
  const allianceCount = Math.floor(Math.random() * 3) + 2;
  for (let i = 0; i < allianceCount; i++) {
    const name = `Alliance ${i + 1}`;
    const members = shuffle(players).slice(0, Math.floor(Math.random() * 4) + 2);
    alliances[name] = members.map(p => p.name);
    members.forEach(m => {
      if (!m.alliance.includes(name)) m.alliance.push(name);
    });
  }
}

function updateAlliancesBox() {
  let html = "<b>Alliances:</b><br>";
  for (let a in alliances) {
    html += `<b>${a}</b>: ${alliances[a].join(", ")}<br>`;
  }
  document.getElementById("alliancesBox").innerHTML = html;
}

function runRound() {
  clearLog();
  if (phase === 1) runPhase1();
  else if (phase === 2) runPhase2();
  else if (phase === 3) runPhase3();
  else if (phase === 4) runFinale();
  else if (phase === 5) generateVotingChart();
}

function runPhase1() {
  const eligible = players.filter(p => !p.key1 && !p.eliminated);
  if (round > 4) {
    players.forEach(p => {
      if (!p.key1) {
        p.eliminated = true;
        eliminated.push(p);
      }
    });
    phase = 2;
    round = 1;
    return runRound();
  }
  const drawn = shuffle(eligible).slice(0, 4);
  log(`Phase 1 - Round ${round}`);
  log(`Drawn players: ${drawn.map(p => p.name).join(", ")}`);

  if (!lockpickHolder && !lockpickUsed && Math.random() < 0.33) {
    lockpickHolder = drawn[Math.floor(Math.random() * drawn.length)];
    log(`${lockpickHolder.name} found the Lockpick!`);
  }

  let voteWinner;
  if (lockpickHolder && drawn.includes(lockpickHolder)) {
    voteWinner = lockpickHolder;
    log(`${voteWinner.name} uses the Lockpick to win the vote key.`);
    lockpickHolder = null;
    lockpickUsed = true;
  } else {
    voteWinner = drawn[Math.floor(Math.random() * drawn.length)];
    log(`${voteWinner.name} wins the vote key.`);
  }

  voteWinner.key1 = true;
  voteWinner.totalKeys++;

  const challengers = drawn.filter(p => p !== voteWinner);
  const challengeWinner = challengers[Math.floor(Math.random() * challengers.length)];
  challengeWinner.key1 = true;
  challengeWinner.totalKeys++;

  log(`${challengeWinner.name} wins the challenge key.`);

recordVotes(round, drawn.map(p => ({ voter: "N/A", votee: "Unknown" })), voteWinner.name, "Phase 1");

  round++;
  updateTable();
}

function runPhase2() {
  const noKey = players.filter(p => !p.key2 && !p.eliminated);
  if (round > 4 || noKey.length < 2) {
    players.forEach(p => {
      if (!p.key2 && !p.eliminated) {
        p.eliminated = true;
        eliminated.push(p);
      }
    });
    phase = 3;
    round = 1;
    return runRound();
  }

  log(`Phase 2 - Round ${round}`);

  if (!lockpickHolder && !lockpickUsed && Math.random() < 0.33) {
    let eligible = noKey;
    if (eligible.length) {
      lockpickHolder = eligible[Math.floor(Math.random() * eligible.length)];
      log(`${lockpickHolder.name} found the Lockpick!`);
    }
  }

  const votes = {};
  const voters = players.filter(p => !p.eliminated);
  const votingDetails = [];

  for (let v of voters) {
    const choices = noKey.filter(p => p.name !== v.name);
    if (choices.length === 0) continue;
    const voteFor = pickAllyOrRandom(v, choices);
    votingDetails.push({ voter: v.name, votee: voteFor.name });
    votes[voteFor.name] = (votes[voteFor.name] || 0) + 1;
  }

  let winnerName = Object.entries(votes).sort((a,b)=>b[1]-a[1])[0][0];
  let voteWinner = noKey.find(p => p.name === winnerName);

  if (lockpickHolder && !voteWinner.key2) {
    voteWinner = lockpickHolder;
    log(`${voteWinner.name} uses the Lockpick to override the vote.`);
    lockpickHolder = null;
    lockpickUsed = true;
  } else {
    log(`${voteWinner.name} wins the vote.`);
  }

  const duelChoices = noKey.filter(p => p.name !== voteWinner.name);
  const opponent = pickAllyOrRandom(voteWinner, duelChoices);

  log(`${voteWinner.name} selects ${opponent.name} to duel.`);

  const duelWinner = Math.random() < 0.5 ? voteWinner : opponent;
  duelWinner.key2 = true;
  duelWinner.totalKeys++;

  log(`${duelWinner.name} wins the duel and earns a key.`);

  recordVotes(round, votingDetails, voteWinner.name, "Phase 2");

  round++;
  updateTable();
}

function runPhase3() {
  const active = players.filter(p => !p.eliminated && p.key1 && p.key2);
  if (active.length !== 4) {
    log("Error: Phase 3 requires 4 players.");
    return;
  }

  const votes = {};
  const votingDetails = [];

  for (let v of active) {
    const choices = active.filter(p => p.name !== v.name);
    const voteFor = pickAllyOrRandom(v, choices);
    votingDetails.push({ voter: v.name, votee: voteFor.name });
    votes[voteFor.name] = (votes[voteFor.name] || 0) + 1;
  }

  const sorted = Object.entries(votes).sort((a,b)=>b[1]-a[1]);
  let voteWinner;
  let pick, rest;

  if (sorted.length < 2 || sorted[0][1] > sorted[1][1]) {
    voteWinner = active.find(p => p.name === sorted[0][0]);
    pick = active.filter(p => p !== voteWinner);
    const ally = pickAllyOrRandom(voteWinner, pick);
    rest = pick.filter(p => p !== ally);
    const challengeWinner = rest[Math.floor(Math.random() * rest.length)];
    finalists = [voteWinner, ally, challengeWinner];
    log(`${voteWinner.name} brings ${ally.name} to the finale.`);
    log(`${challengeWinner.name} wins the final challenge.`);
  } else {
    const tied = sorted.filter(e => e[1] === sorted[0][1]).map(e => e[0]);
    const duelists = active.filter(p => tied.includes(p.name));
    const untied = active.filter(p => !tied.includes(p.name));
    const challengeWinner = duelists[Math.floor(Math.random() * duelists.length)];
    finalists = [...untied, challengeWinner];
    log(`${untied.map(p => p.name).join(" and ")} advance. ${challengeWinner.name} wins the duel for the final spot.`);
  }

  players.forEach(p => {
    if (!finalists.includes(p)) {
      p.eliminated = true;
      jury.push(p);
    } else {
      p.key3 = true;
    }
  });

  recordVotes(round, votingDetails, sorted[0][0], "Phase 3");

  phase = 4;
  round = 1;
  updateTable();
}

function runFinale() {
  const vaultSelections = [];

  for (let f of finalists) {
    let estimate = f.totalKeys + 3;
    let range = vaults.filter(v => v <= estimate + 2 && v >= estimate - 1 && !vaultSelections.includes(v));
    f.vault = range[Math.floor(Math.random() * range.length)] || 3;
    vaultSelections.push(f.vault);
    f.totalFinalKeys = 3;
    log(`${f.name} chooses to open the vault requiring ${f.vault} keys.`);
  }

  // Distribute exactly 16 keys from the jury
  const weights = jury.map(j => j.key3 ? 4 : j.key2 ? 2 : 1);
  let totalWeight = weights.reduce((a, b) => a + b, 0);
  let keysLeft = 16;

  for (let i = 0; i < jury.length; i++) {
    let share = Math.round((weights[i] / totalWeight) * 16);
    share = Math.min(share, keysLeft);
    keysLeft -= share;
    const juror = jury[i];
    while (share-- > 0) {
      const recipient = pickAllyOrRandom(juror, finalists);
      recipient.bonusKeys++;
      recipient.totalFinalKeys++;
    }
  }

  for (let f of finalists) {
    log(`${f.name} ended with ${f.totalFinalKeys} total keys.`);
  }

  const unlocked = finalists.filter(f => f.totalFinalKeys >= f.vault);
  if (unlocked.length) {
    unlocked.sort((a,b)=>b.vault - a.vault);
    log(`${unlocked[0].name} unlocks the highest vault and wins!`);
  } else {
    const fallback = players.find(p => !p.eliminated && !finalists.includes(p));
    log(`No vaults opened. ${fallback ? fallback.name : finalists[0].name} wins by default.`);
  }

  phase = 5;
  updateTable();
}

function pickAllyOrRandom(voter, choices) {
  const allies = choices.filter(c => c.alliance.some(a => voter.alliance.includes(a)));
  return allies.length ? allies[Math.floor(Math.random() * allies.length)] : choices[Math.floor(Math.random() * choices.length)];
}

function recordVotes(roundNum, details, selected, phase) {
  votingChart.push({ roundNum, phase, details, selected });
}

function generateVotingChart() {
  let html = "<h3>Voting Chart</h3><table><tr><th>Round</th><th>Phase</th><th>Voter</th><th>Voted For</th></tr>";
  for (let vote of votingChart) {
    vote.details.forEach(d => {
      html += `<tr><td>${vote.roundNum}</td><td>${vote.phase}</td><td>${d.voter}</td><td>${d.votee}</td></tr>`;
    });
  }
  html += "</table>";
  document.getElementById("votingChart").innerHTML = html;
}

function updateTable() {
  let html = "<h3>Progress Table</h3><table><tr><th>Player</th><th>Phase 1</th><th>Phase 2</th><th>Phase 3</th><th>Total Keys</th></tr>";
  for (let p of players) {
    const className = p.eliminated ? "eliminated" : "";
    html += `<tr class="${className}"><td>${p.name}</td><td>${p.key1 ? "üóùÔ∏è¬Ö" : ""}</td><td>${p.key2 ? "üóùÔ∏è¬Ö" : ""}</td><td>${p.key3 ? "üóùÔ∏è¬Ö" : ""}</td><td>${p.totalFinalKeys || p.totalKeys}</td></tr>`;
  }
  html += "</table>";
  document.getElementById("progressTable").innerHTML = html;
}

function clearLog() {
  document.getElementById("log").innerHTML = "";
}

function log(msg) {
  document.getElementById("log").innerHTML += msg + "<br>";
}

function shuffle(arr) {
  return arr.slice().sort(() => Math.random() - 0.5);
}
  </script>
</body>
</html>