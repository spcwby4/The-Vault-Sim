<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>The Vault Simulator</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#1a1d24;
      --muted:#2a2f3a;
      --text:#e5e7eb;
      --sub:#aeb4c0;
      --accent:#7aa2ff;
      --good:#6ee7b7;
      --warn:#fbbf24;
      --bad:#f87171;
      --border:#2b3340;
    }
    *{box-sizing:border-box}
    body{font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);padding:20px;margin:0}
    h1{margin:0 0 16px;text-align:center}
    h2{margin:0 0 10px;font-size:18px;color:var(--text)}
    textarea,button,input,select{width:100%;padding:10px;margin-top:10px;font-size:15px;border-radius:8px;border:1px solid var(--border);background:var(--panel);color:var(--text)}
    button{cursor:pointer}
    button:hover{background:var(--muted)}
    .box{background:var(--panel);padding:15px;border-radius:12px;box-shadow:0 0 0 1px var(--border);margin-bottom:18px}
    pre{background:var(--bg);padding:10px;border-radius:8px;height:220px;overflow-y:auto;border:1px solid var(--border);white-space:pre-wrap}
    table{width:100%;border-collapse:collapse;margin-top:10px}
    th,td{border:1px solid var(--border);padding:8px;text-align:center;white-space:nowrap}
    th{background:var(--muted);position:sticky;top:0}
    .pill{display:inline-block;min-width:20px;border-radius:6px;padding:2px 6px}
    .ok{background:rgba(110,231,183,.15);border:1px solid rgba(110,231,183,.35)}
    .no{background:rgba(248,113,113,.12);border:1px solid rgba(248,113,113,.3)}
    .table-scroll{overflow:auto;max-width:100%}
    .stats-input{width:70px}
    .rowwrap{display:flex;gap:18px;flex-wrap:wrap}
    .third{flex:1 1 240px}
    .right{max-width:520px}
    .hint{color:var(--sub);font-size:13px;margin-top:6px}
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;background:var(--muted);font-size:12px;margin-left:6px}
    .muted{color:var(--sub)}
  </style>
</head>
<body>

  <h1>The Vault Simulator <span class="badge">Dark</span></h1>

  <div class="box">
    <label for="playerInput"><strong>Enter 12 Players (one per line):</strong></label>
    <textarea id="playerInput" rows="12" placeholder="Player 1&#10;Player 2&#10;..."></textarea>
    <button id="startBtn">Start Game</button>
    <button id="nextBtn" style="display:none;">Next</button>
    <div class="hint">Flow: Phase 1 → Phase 2 → Phase 3 (vote step, then duel step) → Finale (Jury → Open → Winner). F4 special: 2‑way tie = tied duel for last spot; 4‑way tie = top‑3 challenge.</div>
  </div>

  <div class="rowwrap">
    <div class="box third" id="statsBox">
      <h2>Player Stats (Preseason)</h2>
      <div id="statsTable"></div>
      <div class="rowwrap">
        <button id="presetBalanced" class="third">Balanced</button>
        <button id="presetSocial" class="third">Social‑heavy</button>
        <button id="presetChallenge" class="third">Challenge‑heavy</button>
        <button id="presetRandom" class="third">Randomize All</button>
      </div>
      <button id="applyStats">Apply Stats</button>
      <div class="hint">Range: 1–15. Defaults to 8/8. Stats lock after you click Start Game.</div>
    </div>

    <!-- Player-focused relationships editor -->
    <div class="box third" id="relsPreBox">
      <h2>Relationships (Preseason)</h2>
      <div class="hint">Pick a focus player, then set their relationship with everyone else (−5..+5). Bonds &gt; 0, feuds &lt; 0.</div>
      <div class="rowwrap" style="align-items:center">
        <label class="muted">Focus Player</label>
        <select id="relFocus"></select>
      </div>
      <div id="relEditor"></div>
      <div class="rowwrap" style="margin-top:8px">
        <button id="relSave" class="third">Save (All Players)</button>
        <button id="relRandFocus" class="third">Randomize Mild (Focus)</button>
        <button id="relClearFocus" class="third">Clear (Focus)</button>
      </div>
      <div class="rowwrap" style="margin-top:8px">
        <button id="relRandAll" class="third">Randomize Mild (All)</button>
        <button id="relClearAll" class="third">Clear (All)</button>
      </div>
    </div>

    <div class="box third right">
      <h2>Alliances</h2>
      <div id="alliancesList"></div>
    </div>
  </div>

  <div class="box">
    <h2>Round Events</h2>
    <pre id="roundEvents"></pre>
  </div>

  <div class="box">
    <h2>Progress Chart</h2>
    <div id="progressChart"></div>
  </div>

  <div class="box">
    <h2>Voting Matrix (Season)</h2>
    <div id="votingMatrix"></div>
    <div class="hint">LOCKPICK appears in the voter’s cell if used that round. Order: active/finalists → Phase 3 elim → Phase 2 elim → Phase 1 elim.</div>
  </div>

  <!-- MOVED: Relationships (Live) under Voting Matrix -->
  <div class="box">
    <h2>Relationships (Live)</h2>
    <div id="relsLive"></div>
  </div>

  <div class="box">
    <h2>Jury Key Distribution</h2>
    <div id="juryMatrix"></div>
  </div>

<script>
/* ====== Tunables ====== */
const ALPHA_SOCIAL = 0.65;
const BETA_CHALLENGE = 1.0;
const GAMMA_BEATABLE = 1.2;
const LOGIT_K = 0.7;
const WIN_CLAMP_LO = 0.15;
const WIN_CLAMP_HI = 0.85;

const VOTE_JITTER_MIN = 0.8;
const VOTE_JITTER_MAX = 1.2;
const ALLY_PREFERENCE_RATE = 0.6;

const REL_SCALE = 0.08;      // ±8% per point (–5..+5)
const REL_MIN_FACTOR = 0.3;  // floor for extreme feuds

/* ====== State ====== */
let players = [];
let initialOrder = [];
let phase = 1;
let round = 1;

let alliances = {};
let keys = {};
let jury = [];
let finalists = [];
let eliminated = [];

let lockpickHolder = null;
let lockpickUsed = false;
let lockpickFound = false;

let currentDraw = [];

let voteColumns = [];
let knownVoters = [];
let vaults = [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22];

let gameStarted = false;
let phase3Step = 0;

let finaleStep = 0;
let finaleState = {
  finalistKeys: null,
  chosenVaults: null,
  juryMatrix: null,
  resultList: null,
  winner: null,
};

let stats = {};
let rel = {};   // symmetric: rel[A][B] = -5..+5

// NEW: queue relationship updates so they print between event blocks
let relUpdateQueue = [];

/* ====== DOM ====== */
const startBtn = document.getElementById('startBtn');
const nextBtn  = document.getElementById('nextBtn');
const roundsBox= document.getElementById('roundEvents');
const statsBox = document.getElementById('statsBox');
const relsPreBox = document.getElementById('relsPreBox');
const statsTableDiv = document.getElementById('statsTable');

startBtn.onclick = startGame;
nextBtn.onclick  = nextRound;

/* ====== Logging helpers ====== */
function log(msg){
  roundsBox.textContent += (roundsBox.textContent ? '\n' : '') + msg;
  roundsBox.scrollTop = roundsBox.scrollHeight;
}
function clearLog(){ roundsBox.textContent = '' }
function queueRelUpdate(msg){ relUpdateQueue.push(msg) }
function flushRelUpdates(){
  if(!relUpdateQueue.length) return;
  log('— Relationship updates —');
  log(relUpdateQueue.join('\n'));
  relUpdateQueue = [];
}

/* ====== Utils ====== */
function shuffle(arr){ return arr.slice().sort(()=>Math.random()-0.5) }
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)) }
function inAlliance(a,b){
  return Object.values(alliances).some(list => list.includes(a) && list.includes(b));
}
function getElimPhase(name){ const j = jury.find(x=>x.name===name); return j ? j.phase : null }

function setRel(a,b,val){
  if(!rel[a]) rel[a]={};
  if(!rel[b]) rel[b]={};
  rel[a][b] = val;
  rel[b][a] = val;
}
function getRel(a,b){
  if(!rel[a] || rel[a][b]===undefined) return 0;
  return rel[a][b];
}
function incRel(a,b,delta){
  const oldV = getRel(a,b);
  const v = clamp(oldV + delta, -5, 5);
  setRel(a,b,v);
  // QUEUE message instead of logging immediately
  if(delta>0){
    queueRelUpdate(`${a} and ${b} strengthen their bond (+${delta} → ${v}).`);
  }else if(delta<0){
    queueRelUpdate(`${a} and ${b} get into a fight (${delta} → ${v}).`);
  }
  renderRelsLive(); // keep panel fresh
}

function weightedChoice(items, weightArg){
  let weights;
  if (typeof weightArg === 'function') {
    weights = items.map(x => Math.max(0.0001, weightArg(x)));
  } else {
    weights = (weightArg || []).slice();
    if (weights.length !== items.length) weights = items.map(_ => 1);
  }
  const sum = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*sum;
  for(let i=0;i<items.length;i++){
    r -= weights[i];
    if(r <= 0) return items[i];
  }
  return items[items.length-1];
}
function duelWinProb(a,b){
  const da = stats[a]?.challenge ?? 8;
  const db = stats[b]?.challenge ?? 8;
  const p = 1 / (1 + Math.exp(-LOGIT_K * (da - db)));
  return clamp(p, WIN_CLAMP_LO, WIN_CLAMP_HI);
}
function relFactor(voter, target){
  const rf = 1 + REL_SCALE * getRel(voter, target);
  return clamp(rf, REL_MIN_FACTOR, 2);
}

/* ====== Stats UI ====== */
document.getElementById('applyStats').onclick = applyStatsFromInputs;
document.getElementById('presetBalanced').onclick  = ()=>presetStats('balanced');
document.getElementById('presetSocial').onclick    = ()=>presetStats('social');
document.getElementById('presetChallenge').onclick = ()=>presetStats('challenge');
document.getElementById('presetRandom').onclick    = ()=>presetStats('random');

function buildStatsTable(){
  const vals = getPlist();
  let html = `<div class="table-scroll"><table>
    <tr><th>Player</th><th>Social</th><th>Challenge</th></tr>`;
  vals.forEach(name=>{
    const s = stats[name]?.social ?? 8;
    const c = stats[name]?.challenge ?? 8;
    html += `<tr>
      <td>${name}</td>
      <td><input class="stats-input" type="number" min="1" max="15" value="${s}" data-name="${name}" data-field="social"></td>
      <td><input class="stats-input" type="number" min="1" max="15" value="${c}" data-name="${name}" data-field="challenge"></td>
    </tr>`;
  });
  html += `</table></div>`;
  statsTableDiv.innerHTML = html;
}
function getPlist(){
  const input = document.getElementById('playerInput').value.trim().split('\n').map(s=>s.trim()).filter(Boolean);
  return input.length ? input : Object.keys(stats);
}
function applyStatsFromInputs(){
  const inputs = statsTableDiv.querySelectorAll('input.stats-input');
  inputs.forEach(inp=>{
    const name = inp.getAttribute('data-name');
    const field= inp.getAttribute('data-field');
    const v = clamp(parseInt(inp.value||'8',10), 1, 15);
    if(!stats[name]) stats[name] = {social:8, challenge:8};
    stats[name][field] = v;
  });
  log('Preseason stats applied.');
}
function presetStats(which){
  const names = getPlist();
  names.forEach(n=>{
    if(!stats[n]) stats[n] = {social:8, challenge:8};
    if(which==='balanced'){  stats[n].social = 8;  stats[n].challenge = 8; }
    if(which==='social'){    stats[n].social = 12; stats[n].challenge = 8; }
    if(which==='challenge'){ stats[n].social = 8;  stats[n].challenge = 12; }
    if(which==='random'){
      stats[n].social    = Math.floor(1 + Math.random()*15);
      stats[n].challenge = Math.floor(1 + Math.random()*15);
    }
  });
  buildStatsTable();
}

/* ====== Preseason Relationship Editor (player-focused) ====== */
const relFocusSel = document.getElementById('relFocus');
const relEditorDiv = document.getElementById('relEditor');
document.getElementById('relSave').onclick = saveRelAllSweep;
document.getElementById('relRandFocus').onclick = randRelFocus;
document.getElementById('relClearFocus').onclick = clearRelFocus;
document.getElementById('relRandAll').onclick = randRelAll;
document.getElementById('relClearAll').onclick = clearRelAll;

function buildRelFocusList(){
  const names = getPlist();
  relFocusSel.innerHTML = names.map(n=>`<option value="${n}">${n}</option>`).join('');
  if(names.length) renderRelEditorFor(names[0]);
}
relFocusSel?.addEventListener('change', e=>{
  renderRelEditorFor(e.target.value);
});
function renderRelEditorFor(focus){
  const names = getPlist().filter(n=>n!==focus);
  let html = `<div class="table-scroll"><table>
    <tr><th>Player</th><th>Score (−5..+5)</th></tr>`;
  names.forEach(n=>{
    const v = getRel(focus, n);
    html += `<tr>
      <td>${n}</td>
      <td><input type="number" class="rel-spin" data-focus="${focus}" data-target="${n}" min="-5" max="5" step="1" value="${v}"></td>
    </tr>`;
  });
  html += `</table></div>`;
  relEditorDiv.innerHTML = html;

  // Auto-save on change (silent, no spam)
  relEditorDiv.querySelectorAll('.rel-spin').forEach(inp=>{
    inp.addEventListener('input', ()=>{
      const f = inp.getAttribute('data-focus');
      const t = inp.getAttribute('data-target');
      const val = clamp(parseInt(inp.value||'0',10), -5, 5);
      setRel(f, t, val);
      renderRelsLive();
    });
  });
}
function saveRelAllSweep(){
  const names = getPlist();
  // Save current focus screen first
  relEditorDiv.querySelectorAll('.rel-spin').forEach(inp=>{
    const f = inp.getAttribute('data-focus');
    const t = inp.getAttribute('data-target');
    const val = clamp(parseInt(inp.value||'0',10), -5, 5);
    setRel(f, t, val);
  });
  // Sweep everyone to enforce symmetry
  names.forEach(f=>{
    const others = names.filter(n=>n!==f);
    others.forEach(t=>{
      const v = getRel(f,t);
      setRel(f,t,v);
    });
  });
  log('Saved relationships for ALL players.');
  renderRelsLive();
}
function randRelFocus(){
  const focus = relFocusSel.value;
  relEditorDiv.querySelectorAll('.rel-spin').forEach(inp=>{
    const target = inp.getAttribute('data-target');
    const val = Math.floor(-2 + Math.random()*5); // −2..+2
    setRel(focus, target, val);
    inp.value = val;
  });
  log(`Randomized (mild) relationships for ${focus}.`);
  renderRelsLive();
}
function clearRelFocus(){
  const focus = relFocusSel.value;
  relEditorDiv.querySelectorAll('.rel-spin').forEach(inp=>{
    const target = inp.getAttribute('data-target');
    setRel(focus, target, 0);
    inp.value = 0;
  });
  log(`Cleared relationships for ${focus}.`);
  renderRelsLive();
}
function randRelAll(){
  const names = getPlist();
  names.forEach(a=>{
    names.forEach(b=>{
      if(a>=b) return;
      const v = Math.floor(-2 + Math.random()*5); // −2..+2
      setRel(a,b,v);
    });
  });
  log('Randomized (mild) relationships for all players.');
  renderRelEditorFor(relFocusSel.value);
  renderRelsLive();
}
function clearRelAll(){
  const names = getPlist();
  names.forEach(a=>{
    names.forEach(b=>{
      if(a>=b) return;
      setRel(a,b,0);
    });
  });
  log('Cleared all preseason relationships.');
  renderRelEditorFor(relFocusSel.value);
  renderRelsLive();
}

/* Relationships (Live) view */
function renderRelsLive(){
  const wrap = document.getElementById('relsLive');
  const names = players.length ? players : getPlist();
  if(!names.length){ wrap.innerHTML = ''; return; }
  const pairs = [];
  const seen = new Set();
  names.forEach(a=>{
    names.forEach(b=>{
      if(a===b) return;
      const key = [a,b].sort().join('|');
      if(seen.has(key)) return;
      seen.add(key);
      pairs.push({a,b,v:getRel(a,b)});
    });
  });
  pairs.sort((x,y)=>Math.abs(y.v)-Math.abs(x.v));
  const topBonds = pairs.filter(p=>p.v>0).slice(0,6);
  const topFeuds = pairs.filter(p=>p.v<0).slice(0,6);

  let html = `<div class="rowwrap">
    <div class="third"><strong>Top Bonds</strong><br/>` +
      (topBonds.length? topBonds.map(p=>`${p.a} ↔ ${p.b} (+${p.v})`).join('<br/>') : '<span class="muted">None yet</span>') +
      `</div>
    <div class="third"><strong>Top Rivalries</strong><br/>` +
      (topFeuds.length? topFeuds.map(p=>`${p.a} ↔ ${p.b} (${p.v})`).join('<br/>') : '<span class="muted">None yet</span>') +
      `</div>
  </div>`;
  wrap.innerHTML = html;
}

/* Render initial tables */
buildStatsTable();
buildRelFocusList();

/* Keep preseason editors synced with names typed */
document.getElementById('playerInput').addEventListener('input', ()=>{
  if(!gameStarted){
    buildStatsTable();
    buildRelFocusList();
    renderRelsLive();
  }
});

/* ====== Start / Next / Reset ====== */
function startGame(){
  if(gameStarted) return;
  const input = document.getElementById('playerInput').value.trim().split('\n').map(s=>s.trim()).filter(Boolean);
  if(input.length !== 12){ alert('Please enter exactly 12 players.'); return }
  gameStarted = true;

  players = input;
  initialOrder = input.slice();
  knownVoters = input.slice();
  players.forEach(p => keys[p] = []);
  players.forEach(p => { if(!stats[p]) stats[p] = {social:8, challenge:8}; if(!rel[p]) rel[p]={}; });

  // Lock preseason UIs
  statsBox.style.display = 'none';
  relsPreBox.style.display = 'none';

  generateAlliances();
  updateAlliances();
  updateProgress();
  renderMasterVoteTable();
  renderRelsLive();

  log('Phase 1 begins: The Key Quest starts now.');
  startBtn.style.display = 'none';
  nextBtn.style.display = 'inline-block';
  nextBtn.textContent = 'Next';
  nextBtn.onclick = nextRound;

  nextRound();
}

function nextRound(){
  clearLog();
  if(phase === 1) runPhase1();
  else if(phase === 2) runPhase2();
  else if(phase === 3) runPhase3();
  else if(phase === 4) runFinale();
}

function endGameUI(){
  nextBtn.textContent = 'Simulate Again';
  nextBtn.onclick = ()=>location.reload();
}

/* ====== Voting Core (secret, relationships-weighted) ====== */
function simulateVote(voters, eligible){
  return voters.map(v=>{
    const choices = eligible.filter(p=>p!==v);
    const allyChoices = choices.filter(c=>inAlliance(v,c));
    const prioritizeAllies = allyChoices.length > 0 && Math.random() < ALLY_PREFERENCE_RATE;

    const pool = prioritizeAllies ? allyChoices : choices;
    const baseAlpha = prioritizeAllies ? ALPHA_SOCIAL : 0.5 * ALPHA_SOCIAL;

    const weights = pool.map(cand=>{
      const social = (stats[cand]?.social ?? 8);
      const jitter = VOTE_JITTER_MIN + Math.random()*(VOTE_JITTER_MAX - VOTE_JITTER_MIN);
      const rf = relFactor(v, cand);
      return Math.pow(social, baseAlpha) * jitter * rf;
    });

    const pick = weightedChoice(pool, weights);
    return [v, pick];
  });
}
function tally(votePairs, eligible){
  const counts = {}; eligible.forEach(p => counts[p]=0);
  votePairs.forEach(([_,to]) => { if(counts.hasOwnProperty(to)) counts[to]++ });
  const max = Math.max(...Object.values(counts));
  const tied = Object.keys(counts).filter(p => counts[p]===max);
  return [tied[0], tied, counts];
}

/* Season voting chart */
function addVoteColumn(label, phaseTag, roundNo, voters, votePairs, result, lockpickUser=null){
  const values = {};
  knownVoters.forEach(v => values[v] = '—');
  votePairs.forEach(([v,to]) => { values[v] = to });
  if(lockpickUser){ values[lockpickUser] = 'LOCKPICK' }
  voteColumns.push({label, phaseTag, roundNo, result, values});
  renderMasterVoteTable();
}
function renderMasterVoteTable(){
  const wrap = document.getElementById('votingMatrix');
  let html = `<div class="table-scroll"><table><thead><tr><th>Voter</th>`;
  voteColumns.forEach(c => { html += `<th>${c.label}</th>`; });
  html += `</tr></thead><tbody>`;

  const activeRows = players.slice();
  const elimP3 = eliminated.filter(n=>getElimPhase(n)===3);
  const elimP2 = eliminated.filter(n=>getElimPhase(n)===2);
  const elimP1 = eliminated.filter(n=>getElimPhase(n)===1);

  function renderRow(name){
    html += `<tr><td>${name}</td>`;
    voteColumns.forEach(c=>{
      html += `<td>${c.values[name] ?? '—'}</td>`;
    });
    html += `</tr>`;
  }

  activeRows.forEach(renderRow);
  elimP3.forEach(renderRow);
  elimP2.forEach(renderRow);
  elimP1.forEach(renderRow);

  html += `<tr><th>Result</th>`;
  voteColumns.forEach(c => { html += `<th>${c.result || ''}</th>`; });
  html += `</tr></tbody></table></div>`;
  wrap.innerHTML = html;
}

/* ====== Alliances (fluid, relationship-aware) ====== */
function generateAlliances(){
  alliances = {};
  const count = Math.floor(Math.random()*3)+2; // 2..4
  const names = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').slice(0,count);
  const sh = shuffle(players);

  names.forEach(n => alliances[n] = []);
  sh.forEach((p,i)=> alliances[names[i%count]].push(p));

  players.forEach(p=>{
    if(Math.random()<0.15){
      const other = names[Math.floor(Math.random()*names.length)];
      if(!alliances[other].includes(p)) alliances[other].push(p);
    }
  });
}
function averageRelWithAlliance(p, allianceName){
  const members = alliances[allianceName].filter(x=>x!==p);
  if(!members.length) return 0;
  const sum = members.reduce((a,b)=>a+getRel(p,b),0);
  return sum / members.length;
}
function considerAllianceKicks(p){
  for(const [name, list] of Object.entries(alliances)){
    if(!list.includes(p)) continue;
    if(averageRelWithAlliance(p, name) < -2 && Math.random() < 0.5){
      alliances[name] = list.filter(x=>x!==p);
      log(`${p} is removed from Alliance ${name} due to frayed relationships.`);
    }
  }
  updateAlliances();
}
function maybeFormNewAllianceFromBonds(){
  const free = players.slice();
  for(let i=0;i<free.length;i++){
    for(let j=i+1;j<free.length;j++){
      const a=free[i], b=free[j];
      if(getRel(a,b) >= 4 && !inAlliance(a,b) && Math.random()<0.25){
        const name = pickNewAllianceName();
        alliances[name] = [a,b];
        const third = free.find(x=>x!==a&&x!==b && getRel(a,x)>=3 && getRel(b,x)>=3);
        if(third) alliances[name].push(third);
        log(`New Alliance ${name} forms via strong bonds: ${alliances[name].join(', ')}`);
        updateAlliances();
        return;
      }
    }
  }
}
function penalizeNonAllyDuel(decider, opponent, alliesAvailable){
  if(alliesAvailable && !inAlliance(decider, opponent)){
    const allySet = new Set();
    for(const list of Object.values(alliances)){
      if(list.includes(decider)){
        list.forEach(x=>{ if(x!==decider) allySet.add(x) });
      }
    }
    allySet.forEach(ally=> incRel(decider, ally, -2));
    log(`${decider} snubs allies by picking a non‑ally for the duel. Trust drops inside their alliances.`);
    considerAllianceKicks(decider);
  }
}
function pickNewAllianceName(){
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
  for(const c of alphabet){
    if(!alliances[c]) return c;
  }
  return 'Z'+Math.floor(Math.random()*99);
}
function updateAlliances(){
  const box = document.getElementById("alliancesList");
  box.innerHTML = '';
  Object.entries(alliances).forEach(([name, members])=>{
    const visible = members.filter(m => initialOrder.includes(m));
    if(visible.length){
      box.innerHTML += `<strong>Alliance ${name}</strong>: ${visible.join(', ')}` + '<br/>';
    }
  });
}

/* ====== Progress ====== */
function updateProgress(){
  const chart = document.getElementById('progressChart');
  const everyone = players.concat(eliminated.filter(p=>!players.includes(p)));
  let html = `<div class="table-scroll"><table>
    <tr><th>Player</th><th>P1</th><th>P2</th><th>Final</th></tr>`;
  everyone.forEach(p=>{
    const p1 = keys[p]?.includes('P1') ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    const p2 = keys[p]?.includes('P2') ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    const pf = finalists.includes(p)     ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    html += `<tr><td>${p}</td><td>${p1}</td><td>${p2}</td><td>${pf}</td></tr>`;
  });
  html += `</table></div>`;
  chart.innerHTML = html;
}

/* ====== Phase 1 ====== */
function runPhase1(){
  flushRelUpdates(); // pre-events updates

  if(round > 4 || Object.values(keys).filter(k=>k.includes('P1')).length >= 8){
    return endPhase1();
  }

  const eligible = players.filter(p=>!keys[p].includes('P1'));
  const drawn = shuffle(eligible).slice(0,4);
  currentDraw = drawn;

  log(`Phase 1 – Round ${round}`);
  log(`Drawn: ${drawn.join(', ')}`);

  const beastInDrawn = drawn.some(p => (stats[p]?.challenge ?? 8) >= 13);
  const findChance = 0.33 + (beastInDrawn ? 0.01 : 0);
  if(!lockpickFound && Math.random() < findChance){
    lockpickHolder = drawn[Math.floor(Math.random()*drawn.length)];
    lockpickFound = true;
    log(`${lockpickHolder} discovers the Lockpick.`);
  }

  const votePairs = simulateVote(knownVoters, drawn);
  let [voteWinner] = tally(votePairs, drawn);

  votePairs.forEach(([v,to])=>{
    if(to===voteWinner && inAlliance(v, voteWinner)) incRel(v, voteWinner, +1);
  });

  flushRelUpdates(); // vote-based updates

  let lockUser = null;
  if(lockpickHolder && !lockpickUsed && drawn.includes(lockpickHolder)){
    const mustUse = (round===4 && !keys[lockpickHolder].includes('P1'));
    const willUse = mustUse || Math.random() < 0.2;
    if(willUse){
      voteWinner = lockpickHolder;
      lockUser = lockpickHolder;
      lockpickUsed = true;
      log(`${lockpickHolder} uses the Lockpick to override the vote.`);
    }
  }

  addVoteColumn(`P1 R${round}`, 'P1', round, knownVoters, votePairs, voteWinner, lockUser);

  keys[voteWinner].push('P1');
  log(`${voteWinner} wins the vote key.`);

  const challengers = drawn.filter(p=>p!==voteWinner && !keys[p].includes('P1'));
  if(challengers.length>0){
    const challengeWinner = weightedChoice(challengers, p => Math.pow((stats[p]?.challenge ?? 8), BETA_CHALLENGE));
    keys[challengeWinner].push('P1');
    log(`${challengeWinner} wins the challenge key.`);
  }else{
    log(`No challenge key awarded.`);
  }

  maybeFormNewAllianceFromBonds();
  flushRelUpdates(); // alliance-forming updates

  updateProgress();
  renderRelsLive();
  updateAlliances();
  round++;
}

function endPhase1(){
  const advancing = players.filter(p=>keys[p].includes('P1'));
  const phaseOut  = players.filter(p=>!advancing.includes(p));

  phaseOut.forEach(p=>{ if(!eliminated.includes(p)) eliminated.push(p) });
  phaseOut.forEach(p=>jury.push({name:p, phase:1}));

  players = advancing;
  log(`Phase 1 complete. Eliminated: ${phaseOut.join(', ')}`);
  renderMasterVoteTable();
  updateAlliances();
  renderRelsLive();
  round = 1; phase = 2;
  nextRound();
}

/* ====== Phase 2 ====== */
function runPhase2(){
  flushRelUpdates(); // pre-events

  if(round > 4 || Object.values(keys).filter(k=>k.includes('P2')).length >= 4){
    return endPhase2();
  }

  log(`Phase 2 – Round ${round}`);
  const noKey = players.filter(p=>!keys[p].includes('P2'));
  if(noKey.length < 2){
    log('Not enough no‑key players for another duel.');
    return endPhase2();
  }

  const votePairs = simulateVote(players, noKey);
  let [voteWinner] = tally(votePairs, noKey);

  votePairs.forEach(([v,to])=>{
    if(to===voteWinner && inAlliance(v, voteWinner)) incRel(v, voteWinner, +1);
  });

  flushRelUpdates(); // vote-based

  let lockUser = null;
  if(lockpickHolder && !lockpickUsed && noKey.includes(lockpickHolder) && !keys[lockpickHolder].includes('P2')){
    if(Math.random() < 0.6){
      voteWinner = lockpickHolder;
      lockUser = lockpickHolder;
      lockpickUsed = true;
      log(`${lockpickHolder} uses the Lockpick to auto‑win the vote.`);
    }
  }

  addVoteColumn(`P2 R${round}`, 'P2', round, knownVoters, votePairs, voteWinner, lockUser);

  const candidates = noKey.filter(p=>p!==voteWinner);
  const nonAllies = candidates.filter(p=>!inAlliance(p, voteWinner));
  const allies    = candidates.filter(p=> inAlliance(p, voteWinner));
  let opponent, reason;
  const alliesAvailable = allies.length>0;

  if(allies.length && Math.random()<0.55){
    opponent = weightedChoice(allies, p => 1/Math.max(1,(stats[p]?.challenge ?? 8)) * relFactor(voteWinner, p));
    reason = 'keeps the key within their alliance';
    incRel(voteWinner, opponent, +2);
  }else if(nonAllies.length){
    opponent = weightedChoice(nonAllies, p => Math.pow(1/Math.max(1,(stats[p]?.challenge ?? 8)), GAMMA_BEATABLE) * relFactor(voteWinner, p));
    reason = 'chooses someone they believe they can beat';
    if(alliesAvailable) penalizeNonAllyDuel(voteWinner, opponent, true);
  }else{
    opponent = weightedChoice(candidates, p => relFactor(voteWinner, p));
    reason = 'makes a neutral pick';
  }
  log(`${voteWinner} chooses to duel ${opponent} — ${reason}.`);

  flushRelUpdates(); // pick-related (snubs/bonds)

  const pWin = duelWinProb(voteWinner, opponent);
  const duelWinner = Math.random() < pWin ? voteWinner : opponent;
  keys[duelWinner].push('P2');
  log(`${duelWinner} wins the duel and earns a Phase 2 key.`);

  considerAllianceKicks(voteWinner);
  maybeFormNewAllianceFromBonds();
  flushRelUpdates(); // post-duel evolution

  updateProgress();
  renderRelsLive();
  updateAlliances();
  round++;
}

function endPhase2(){
  const advancing = players.filter(p=>keys[p].includes('P2'));
  const phaseOut  = players.filter(p=>!advancing.includes(p));

  phaseOut.forEach(p=>{ if(!eliminated.includes(p)) eliminated.push(p) });
  phaseOut.forEach(p=>jury.push({name:p, phase:2}));

  players = advancing;
  log(`Phase 2 complete. Eliminated: ${phaseOut.join(', ')}`);
  renderMasterVoteTable();
  renderRelsLive();
  updateAlliances();
  round = 1; phase = 3; phase3Step = 0;
  nextRound();
}

/* ====== Phase 3 (Two-step + F4 tie logic) ====== */
let p3_voteWinner = null;
let p3_chosenAlly = null;
let p3_duelists = [];

function runPhase3(){
  if(phase3Step === 0){
    flushRelUpdates(); // pre P3 vote

    log(`Phase 3 — Final Cut: Vote step`);
    const votePairsRaw = simulateVote(players, players);
    const votePairs = votePairsRaw.map(([v,to])=>{
      if(v===to){
        const choices = players.filter(p=>p!==v);
        return [v, weightedChoice(choices, choices.map(c=>{
          const social = (stats[c]?.social ?? 8);
          const jitter = VOTE_JITTER_MIN + Math.random()*(VOTE_JITTER_MAX - VOTE_JITTER_MIN);
          return Math.pow(social, ALPHA_SOCIAL) * jitter * relFactor(v,c);
        }))];
      }
      return [v,to];
    });

    const [voteWinner, tied, counts] = (()=>{
      const [w, t, c] = tally(votePairs, players);
      return [w, t, c];
    })();

    // F4 tie handling
    if(players.length===4){
      const cm = {}; players.forEach(p=>cm[p]=0); votePairs.forEach(([_,to])=>cm[to]++);
      const vals = Object.values(cm);
      const maxV = Math.max(...vals);
      const tiedAtMax = Object.keys(cm).filter(p=>cm[p]===maxV);

      if(new Set(vals).size===1){
        log(`Final 4 vote is a four‑way tie! All four compete; top three advance.`);
        const perf = players.map(p=>({p, score: (stats[p]?.challenge ?? 8) * (0.8 + Math.random()*0.4)}));
        perf.sort((a,b)=>b.score-a.score);
        const advancing = perf.slice(0,3).map(x=>x.p);
        const fourth = perf[3].p;
        finalists = advancing.slice();
        jury.push({name: fourth, phase:3});
        if(!eliminated.includes(fourth)) eliminated.push(fourth);
        log(`Challenge order: ${perf.map(x=>x.p).join(' > ')}`);
        log(`${fourth} finishes last and is eliminated; the others advance to the finale.`);
        updateProgress();
        renderRelsLive();
        phase = 4;
        return;
      }

      if(tiedAtMax.length===2){
        const nonTied = players.filter(p=>!tiedAtMax.includes(p));
        finalists = nonTied.slice(); // auto-advance
        log(`Final 4 vote has a two‑way tie between ${tiedAtMax[0]} and ${tiedAtMax[1]}. They duel for the final spot. Others advance: ${nonTied.join(', ')}.`);

        const a = tiedAtMax[0], b = tiedAtMax[1];
        const pWin = duelWinProb(a,b);
        const duelWinner = Math.random() < pWin ? a : b;
        const duelLoser  = duelWinner===a ? b : a;
        finalists.push(duelWinner);
        jury.push({name:duelLoser, phase:3});
        if(!eliminated.includes(duelLoser)) eliminated.push(duelLoser);
        log(`${duelWinner} wins the tiebreak duel. ${duelLoser} is eliminated and becomes the 4th juror.`);
        updateProgress();
        renderRelsLive();
        phase = 4;
        return;
      }
    }

    p3_voteWinner = voteWinner;
    log(`${voteWinner} wins the vote and becomes a finalist.`);

    const available = players.filter(p=>p!==voteWinner);
    const allyOpts = available.filter(p=>inAlliance(p, voteWinner));
    const pool = (allyOpts.length ? allyOpts : available);
    p3_chosenAlly = weightedChoice(pool, p => ((stats[p]?.social ?? 8) + 0.1*(16 - (stats[p]?.challenge ?? 8))) * relFactor(voteWinner,p));
    if(inAlliance(voteWinner, p3_chosenAlly)) incRel(voteWinner, p3_chosenAlly, +2);

    addVoteColumn(`P3 Vote`, 'P3', 1, knownVoters, votePairs, voteWinner, null);

    flushRelUpdates(); // after ally selection

    p3_duelists = players.filter(p=>p!==voteWinner && p!==p3_chosenAlly);
    log(`${voteWinner} selects ${p3_chosenAlly} to join them. Next: ${p3_duelists[0]} vs ${p3_duelists[1]} for the last spot. Click Next to resolve.`);
    finalists = [p3_voteWinner, p3_chosenAlly];
    updateProgress();
    renderRelsLive();
    phase3Step = 1;
    return;
  }

  if(phase3Step === 1){
    flushRelUpdates(); // pre duel resolution

    const a = p3_duelists[0], b = p3_duelists[1];
    const pWin = duelWinProb(a,b);
    const duelWinner = Math.random() < pWin ? a : b;
    const duelLoser  = p3_duelists.find(p=>p!==duelWinner);
    finalists.push(duelWinner);
    if(!eliminated.includes(duelLoser)) eliminated.push(duelLoser);
    jury.push({name:duelLoser, phase:3});
    log(`${duelWinner} wins the final duel. ${duelLoser} is eliminated and joins the jury.`);

    flushRelUpdates(); // any post-duel evolutions

    updateProgress();
    renderRelsLive();

    phase = 4;
    phase3Step = 0;
    log(`Click Next to proceed to the Vault Finale.`);
  }
}

/* ====== Finale (3 screens: Jury → Open → Winner) ====== */
function runFinale(){
  flushRelUpdates(); // pre-jury

  if(finaleStep === 0){
    if(!finaleState.finalistKeys){
      finaleState.finalistKeys = {};
      finalists.forEach(p => finaleState.finalistKeys[p] = 3);

      const supportScore = {};
      finalists.forEach(f=>{
        let score = 0;
        jury.forEach(j=>{
          const cap = j.phase===1?1:j.phase===2?2:4;
          if(inAlliance(j.name, f)) score += cap;
        });
        supportScore[f] = score + 0.4*(stats[f]?.social ?? 8);
      });

      const expect = {};
      const maxSupport = Math.max(1, ...Object.values(supportScore));
      finalists.forEach(f=>{
        const normalized = (supportScore[f]/maxSupport);
        expect[f] = Math.round(6 + normalized * 6); // 6..12
      });

      finaleState.chosenVaults = pickUniqueVaultsForFinalists(expect);
      finaleState.juryMatrix = distributeJuryKeysExact16(finalists, jury, finaleState.finalistKeys);
    }

    log(`Vault Finale — Jury awards keys now.`);
    displayJuryMatrix(finaleState.juryMatrix);
    log(`Click Next to reveal vault openings.`);
    finaleStep = 1;
    return;
  }

  if(finaleStep === 1){
    flushRelUpdates(); // if any queued

    log(`Vault selections: ${finalists.map(f=>`${f} → ${finaleState.chosenVaults[f]} keys`).join(', ')}`);
    finalists.forEach(f=>{
      log(`${f} has ${finaleState.finalistKeys[f]} total keys.`);
    });

    const result = finalists.map(name => ({
      name,
      keys: finaleState.finalistKeys[name],
      vault: finaleState.chosenVaults[name]
    })).sort((a,b)=>b.vault - a.vault);
    finaleState.resultList = result;
    finaleState.winner = result.find(r => r.keys >= r.vault) || null;

    log(`Click Next to reveal the winner.`);
    finaleStep = 2;
    return;
  }

  if(finaleStep === 2){
    flushRelUpdates();

    if(!finaleState.winner){
      const fourth = jury.find(j=>j.phase===3)?.name || 'Fourth Place';
      log(`No finalist opened a vault. ${fourth} wins by default.`);
    }else{
      log(`${finaleState.winner.name} opens the ${finaleState.winner.vault}-key vault with ${finaleState.winner.keys} keys and wins.`);
    }
    endGameUI();
  }
}

/* Unique vaults closest to expectations, no duplicates */
function pickUniqueVaultsForFinalists(expect){
  const picked = {};
  const available = vaults.slice();
  const order = Object.keys(expect).sort((a,b)=>expect[b]-expect[a]);
  order.forEach(f=>{
    let best = available[0], bestDiff = Infinity, bestIdx = 0;
    available.forEach((v,i)=>{
      const d = Math.abs(v - expect[f]);
      if(d < bestDiff){ bestDiff = d; best = v; bestIdx = i; }
    });
    picked[f] = best;
    available.splice(bestIdx, 1);
  });
  return picked;
}

/* Jury distribution (closer by default; blowouts only if undeniable) */
function distributeJuryKeysExact16(finalists, jury, finalistKeys){
  const capPool = [];
  jury.forEach(j=>{
    const cap = j.phase===1?1:j.phase===2?2:4;
    for(let i=0;i<cap;i++) capPool.push(j.name);
  });
  shuffle(capPool);
  const draws = capPool.slice(0,16);

  const jm = {};
  jury.forEach(j=>{ jm[j.name] = Object.fromEntries(finalists.map(f=>[f,0])) });

  function allianceSupportForFinalist(f){
    let s = 0;
    jury.forEach(j=>{
      const cap = j.phase===1?1:j.phase===2?2:4;
      if(inAlliance(j.name, f)) s += cap;
    });
    return s;
  }
  const baseStrength = {};
  finalists.forEach(f=>{
    const a = allianceSupportForFinalist(f);
    const soc = (stats[f]?.social ?? 8);
    baseStrength[f] = a + 0.6 * soc;
  });

  function normalizeProbs(strength){
    const vals = finalists.map(f=>strength[f]);
    const sorted = vals.slice().sort((x,y)=>y-x);
    const top = sorted[0], second = sorted[1] ?? sorted[0];
    const disparity = (top - second) / (top || 1);
    const T = disparity >= 0.5 ? 0.55 : disparity >= 0.25 ? 0.7 : 0.9;
    const exp = {};
    let sum = 0;
    finalists.forEach(f=>{
      const e = Math.exp((strength[f]) / T);
      exp[f] = e; sum += e;
    });
    let probs = {};
    finalists.forEach(f=>{ probs[f] = exp[f] / sum; });
    const uniform = 1 / finalists.length;
    const lambda = disparity >= 0.5 ? 0.05 : disparity >= 0.25 ? 0.18 : 0.35;
    finalists.forEach(f=>{ probs[f] = (1 - lambda)*probs[f] + lambda*uniform; });
    return probs;
  }
  const baseProbs = normalizeProbs(baseStrength);

  draws.forEach(jName=>{
    const j = jury.find(x=>x.name===jName);
    let jurorProbs = Object.assign({}, baseProbs);
    const allied = finalists.filter(f=>inAlliance(j.name, f));
    if(allied.length === 1){
      const fav = allied[0];
      jurorProbs[fav] *= 1.15;
      let s = 0; finalists.forEach(f=> s += jurorProbs[f]);
      finalists.forEach(f=> jurorProbs[f] /= s);
    }
    const fTarget = weightedChoice(finalists, f => jurorProbs[f]);
    jm[jName][fTarget] += 1;
    finalistKeys[fTarget] += 1;
  });

  return jm;
}
</script>
</body>
</html>