<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>The Vault Simulator</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#1a1d24;
      --muted:#2a2f3a;
      --text:#e5e7eb;
      --sub:#aeb4c0;
      --accent:#7aa2ff;
      --good:#6ee7b7;
      --warn:#fbbf24;
      --bad:#f87171;
      --border:#2b3340;
    }
    *{box-sizing:border-box}
    body{font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);padding:20px;margin:0}
    h1{margin:0 0 16px;text-align:center}
    h2{margin:0 0 10px;font-size:18px;color:var(--text)}
    textarea,button{width:100%;padding:10px;margin-top:10px;font-size:15px;border-radius:8px;border:1px solid var(--border);background:var(--panel);color:var(--text)}
    button{cursor:pointer}
    button:hover{background:var(--muted)}
    .box{background:var(--panel);padding:15px;border-radius:12px;box-shadow:0 0 0 1px var(--border);margin-bottom:18px}
    pre{background:var(--bg);padding:10px;border-radius:8px;height:220px;overflow-y:auto;border:1px solid var(--border);white-space:pre-wrap}
    table{width:100%;border-collapse:collapse;margin-top:10px}
    th,td{border:1px solid var(--border);padding:8px;text-align:center;white-space:nowrap}
    th{background:var(--muted);position:sticky;top:0}
    .pill{display:inline-block;min-width:20px;border-radius:6px;padding:2px 6px}
    .ok{background:rgba(110,231,183,.15);border:1px solid rgba(110,231,183,.35)}
    .no{background:rgba(248,113,113,.12);border:1px solid rgba(248,113,113,.3)}
    .flex{display:flex;gap:18px;flex-wrap:wrap}
    .half{flex:1 1 420px}
    .right{max-width:520px}
    .hint{color:var(--sub);font-size:13px;margin-top:6px}
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;background:var(--muted);font-size:12px;margin-left:6px}
    .table-scroll{overflow:auto;max-width:100%}
  </style>
</head>
<body>

  <h1>The Vault Simulator <span class="badge">Dark</span></h1>

  <div class="box">
    <label for="playerInput"><strong>Enter 12 Players (one per line):</strong></label>
    <textarea id="playerInput" rows="12" placeholder="Player 1&#10;Player 2&#10;..."></textarea>
    <button id="startBtn">Start Game</button>
    <button id="nextBtn" style="display:none;">Next</button>
    <div class="hint">Flow: Phase 1 → Phase 2 → Phase 3 (vote step, then duel step) → Finale.</div>
  </div>

  <div class="flex">
    <div class="box half">
      <h2>Round Events</h2>
      <pre id="roundEvents"></pre>
    </div>

    <div class="box half right">
      <h2>Alliances</h2>
      <div id="alliancesList"></div>
    </div>
  </div>

  <div class="box">
    <h2>Progress Chart</h2>
    <div id="progressChart"></div>
  </div>

  <div class="box">
    <h2>Voting Matrix (Season)</h2>
    <div class="table-scroll" id="votingMatrix"></div>
    <div class="hint">Plain text. “LOCKPICK” appears in the voter’s cell if they used it that round. Eliminated voters are kept and moved to the bottom from the round after they’re out.</div>
  </div>

  <div class="box">
    <h2>Jury Key Distribution</h2>
    <div id="juryMatrix"></div>
  </div>

<script>
/* ====== State ====== */
let players = [];
let initialOrder = []; // preserve original order for active-section sorting
let phase = 1;
let round = 1;

let alliances = {};     // {Name:[players]}
let keys = {};          // {player:[ "P1", "P2" ]}
let jury = [];          // [{name, phase}]
let finalists = [];     // [p1,p2,p3]
let eliminated = [];    // elimination order

let lockpickHolder = null;
let lockpickUsed = false;
let lockpickFound = false;

let currentDraw = [];

let voteColumns = [];   // [{label, phaseTag, roundNo, result, values:{voter:value}}]
let knownVoters = [];   // fixed list of the original 12
let vaults = [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22];

let gameStarted = false;
let phase3Step = 0; // 0 = vote+ally, 1 = duel

/* cache DOM */
const startBtn = document.getElementById('startBtn');
const nextBtn  = document.getElementById('nextBtn');
const roundsBox= document.getElementById('roundEvents');

startBtn.onclick = startGame;
nextBtn.onclick  = nextRound;

/* ====== Helpers ====== */
function log(msg){
  roundsBox.textContent += (roundsBox.textContent ? '\n' : '') + msg;
  roundsBox.scrollTop = roundsBox.scrollHeight;
}
function clearLog(){ roundsBox.textContent = '' }
function shuffle(arr){ return arr.slice().sort(()=>Math.random()-0.5) }

function inAlliance(a,b){
  return Object.values(alliances).some(list => list.includes(a) && list.includes(b));
}
function allianceNamesFor(p){
  return Object.entries(alliances).filter(([n,list])=>list.includes(p)).map(([n])=>n);
}

/* ====== Start / Next / Reset ====== */
function startGame(){
  if(gameStarted) return;
  const input = document.getElementById('playerInput').value.trim().split('\n').map(s=>s.trim()).filter(Boolean);
  if(input.length !== 12){ alert('Please enter exactly 12 players.'); return }
  gameStarted = true;

  players = input;
  initialOrder = input.slice();
  knownVoters = input.slice();
  players.forEach(p => keys[p] = []);

  generateAlliances();
  updateAlliances();
  updateProgress();
  renderMasterVoteTable(); // empty shell initially

  log('Phase 1 begins: The Key Quest starts now.');
  startBtn.style.display = 'none';
  nextBtn.style.display = 'inline-block';
  nextBtn.textContent = 'Next';
  nextBtn.onclick = nextRound;

  nextRound();
}

function nextRound(){
  clearLog();
  if(phase === 1) runPhase1();
  else if(phase === 2) runPhase2();
  else if(phase === 3) runPhase3();
  else if(phase === 4) runFinale();
}

function endGameUI(){
  nextBtn.textContent = 'Simulate Again';
  nextBtn.onclick = ()=>location.reload();
}

/* ====== Voting Core ====== */
function simulateVote(voters, eligible){
  // slight bias toward allies when possible
  return voters.map(v=>{
    const choices = eligible.filter(p=>p!==v);
    const allyChoices = choices.filter(c=>inAlliance(v,c));
    const pick = allyChoices.length && Math.random()<0.6
      ? allyChoices[Math.floor(Math.random()*allyChoices.length)]
      : choices[Math.floor(Math.random()*choices.length)];
    return [v,pick];
  });
}
function tally(votePairs, eligible){
  const counts = {}; eligible.forEach(p => counts[p]=0);
  votePairs.forEach(([_,to]) => { if(counts.hasOwnProperty(to)) counts[to]++ });
  const max = Math.max(...Object.values(counts));
  const tied = Object.keys(counts).filter(p => counts[p]===max);
  return [tied[0], tied, counts];
}

/* Season voting chart: add a column and render */
function addVoteColumn(label, phaseTag, roundNo, voters, votePairs, result, lockpickUser=null){
  // create base values map with '—' for everyone
  const values = {};
  knownVoters.forEach(v => values[v] = '—');
  // fill voter → target
  votePairs.forEach(([v,to]) => { values[v] = to });
  // LOCKPICK override
  if(lockpickUser){ values[lockpickUser] = 'LOCKPICK' }
  voteColumns.push({label, phaseTag, roundNo, result, values});
  renderMasterVoteTable();
}

/* Render wiki-style season chart */
function renderMasterVoteTable(){
  const wrap = document.getElementById('votingMatrix');
  // columns: each vote column label + final "Result" row
  let html = `<div class="table-scroll"><table><thead><tr><th>Voter</th>`;
  voteColumns.forEach(c => { html += `<th>${c.label}</th>`; });
  html += `</tr></thead><tbody>`;

  // row order: active players in current in-game order, then eliminated in elimination order
  const activeRows = players.slice();
  const eliminatedRows = eliminated.slice();

  function renderRow(name){
    html += `<tr><td>${name}</td>`;
    voteColumns.forEach(c=>{
      html += `<td>${c.values[name] ?? '—'}</td>`;
    });
    html += `</tr>`;
  }

  activeRows.forEach(renderRow);
  eliminatedRows.forEach(renderRow);

  // result row
  html += `<tr><th>Result</th>`;
  voteColumns.forEach(c => { html += `<th>${c.result || ''}</th>`; });
  html += `</tr>`;

  html += `</tbody></table></div>`;
  wrap.innerHTML = html;
}

/* ====== Alliances (fluid) ====== */
function generateAlliances(){
  alliances = {};
  const count = Math.floor(Math.random()*3)+2; // 2..4 alliances
  const names = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').slice(0,count);
  const sh = shuffle(players);

  names.forEach(n => alliances[n] = []);
  sh.forEach((p,i)=> alliances[names[i%count]].push(p));

  // small chance of dual-membership at start
  players.forEach(p=>{
    if(Math.random()<0.15){
      const other = names[Math.floor(Math.random()*names.length)];
      if(!alliances[other].includes(p)) alliances[other].push(p);
    }
  });
}
function evolveAlliancesAfterVote(votePairs){
  // Identify betrayals: voter had at least one eligible ally but voted a non‑ally
  const eligSet = new Set(votePairs.map(([_,cand])=>cand)); // eligible targets
  const kicked = [];
  votePairs.forEach(([v,to])=>{
    const memberOf = Object.entries(alliances).filter(([_,list])=>list.includes(v)).map(([n])=>n);
    if(!memberOf.length) return;
    memberOf.forEach(name=>{
      const mates = alliances[name].filter(p=>p!==v && eligSet.has(p));
      const votedNonAlly = mates.length && !mates.includes(to);
      if(votedNonAlly && Math.random()<0.5){
        // boot from that alliance
        const arr = alliances[name];
        const idx = arr.indexOf(v);
        if(idx>-1){ arr.splice(idx,1); kicked.push(`${v} removed from Alliance ${name} for untrustworthy voting`); }
      }
    });
  });
  if(kicked.length) log(kicked.join('; '));

  // Chance to form a new micro-alliance midgame (2–4 members) from active players
  if(Math.random()<0.25 && players.length>=4){
    const size = Math.floor(Math.random()*3)+2; // 2..4
    const cand = shuffle(players).slice(0, size);
    const newName = pickNewAllianceName();
    alliances[newName] = cand.slice();
    log(`New Alliance ${newName} forms: ${cand.join(', ')}`);
  }

  // Clean up empty or eliminated members
  Object.keys(alliances).forEach(name=>{
    alliances[name] = alliances[name].filter(p=>initialOrder.includes(p)); // keep only original contestants
    if(alliances[name].length===0) delete alliances[name];
  });

  updateAlliances();
}
function pickNewAllianceName(){
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
  for(const c of alphabet){
    if(!alliances[c]) return c;
  }
  return 'Z'+Math.floor(Math.random()*99);
}
function updateAlliances(){
  const box = document.getElementById("alliancesList");
  box.innerHTML = '';
  Object.entries(alliances).forEach(([name, members])=>{
    box.innerHTML += `<strong>Alliance ${name}</strong>: ${members.join(', ')}<br/>`;
  });
}

/* ====== Progress (keep eliminated at bottom) ====== */
function updateProgress(){
  const chart = document.getElementById('progressChart');
  const everyone = players.concat(eliminated.filter(p=>!players.includes(p)));
  let html = `<div class="table-scroll"><table>
    <tr><th>Player</th><th>P1</th><th>P2</th><th>Final</th></tr>`;
  everyone.forEach(p=>{
    const p1 = keys[p]?.includes('P1') ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    const p2 = keys[p]?.includes('P2') ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    const pf = finalists.includes(p)     ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    html += `<tr><td>${p}</td><td>${p1}</td><td>${p2}</td><td>${pf}</td></tr>`;
  });
  html += `</table></div>`;
  chart.innerHTML = html;
}

/* ====== Phase 1 ====== */
function runPhase1(){
  if(round > 4 || Object.values(keys).filter(k=>k.includes('P1')).length >= 8){
    return endPhase1();
  }

  const eligible = players.filter(p=>!keys[p].includes('P1'));
  const drawn = shuffle(eligible).slice(0,4);
  currentDraw = drawn;

  log(`Phase 1 – Round ${round}`);
  log(`Drawn: ${drawn.join(', ')}`);

  // Lockpick discovery
  if(!lockpickFound && Math.random() < 0.33){
    lockpickHolder = drawn[Math.floor(Math.random()*drawn.length)];
    lockpickFound = true;
    log(`${lockpickHolder} discovers the Lockpick.`);
  }

  // All 12 vote among drawn
  const votePairs = simulateVote(knownVoters, drawn);
  let [voteWinner] = tally(votePairs, drawn);

  // Smart Lockpick use in P1: auto-use in Round 4 if holder lacks P1; otherwise small chance
  let lockUser = null;
  if(lockpickHolder && !lockpickUsed && drawn.includes(lockpickHolder)){
    const mustUse = (round===4 && !keys[lockpickHolder].includes('P1'));
    const willUse = mustUse || Math.random() < 0.2;
    if(willUse){
      voteWinner = lockpickHolder;
      lockUser = lockpickHolder;
      lockpickUsed = true;
      log(`${lockpickHolder} uses the Lockpick to override the vote.`);
    }
  }

  // Add column to season chart
  addVoteColumn(`P1 R${round}`, 'P1', round, knownVoters, votePairs, voteWinner, lockUser);

  // Award vote key
  keys[voteWinner].push('P1');
  log(`${voteWinner} wins the vote key.`);

  // Challenge among remaining drawn without P1
  const challengers = drawn.filter(p=>p!==voteWinner && !keys[p].includes('P1'));
  if(challengers.length>0){
    const challengeWinner = challengers[Math.floor(Math.random()*challengers.length)];
    keys[challengeWinner].push('P1');
    log(`${challengeWinner} wins the challenge key.`);
  }else{
    log(`No challenge key awarded.`);
  }

  evolveAlliancesAfterVote(votePairs);
  updateProgress();
  round++;
}

function endPhase1(){
  const advancing = players.filter(p=>keys[p].includes('P1'));
  const phaseOut  = players.filter(p=>!advancing.includes(p));

  phaseOut.forEach(p=>{ if(!eliminated.includes(p)) eliminated.push(p) });
  phaseOut.forEach(p=>jury.push({name:p, phase:1}));

  players = advancing;
  log(`Phase 1 complete. Eliminated: ${phaseOut.join(', ')}`);
  renderMasterVoteTable(); // move eliminated rows to bottom
  round = 1; phase = 2;
  nextRound();
}

/* ====== Phase 2 ====== */
function runPhase2(){
  if(round > 4 || Object.values(keys).filter(k=>k.includes('P2')).length >= 4){
    return endPhase2();
  }

  log(`Phase 2 – Round ${round}`);
  const noKey = players.filter(p=>!keys[p].includes('P2'));
  if(noKey.length < 2){
    log('Not enough no‑key players for another duel.');
    return endPhase2();
  }

  // All active players vote among no-key
  const votePairs = simulateVote(players, noKey);
  let [voteWinner] = tally(votePairs, noKey);

  // Lockpick in P2: if holder lacks P2, often used to seize control
  let lockUser = null;
  if(lockpickHolder && !lockpickUsed && noKey.includes(lockpickHolder) && !keys[lockpickHolder].includes('P2')){
    if(Math.random() < 0.6){
      voteWinner = lockpickHolder;
      lockUser = lockpickHolder;
      lockpickUsed = true;
      log(`${lockpickHolder} uses the Lockpick to auto‑win the vote.`);
    }
  }

  // Add column to season chart for P2 vote
  addVoteColumn(`P2 R${round}`, 'P2', round, knownVoters, votePairs, voteWinner, lockUser);

  // Strategy-aware opponent selection with reason
  const candidates = noKey.filter(p=>p!==voteWinner);
  const nonAllies = candidates.filter(p=>!inAlliance(p, voteWinner));
  const allies    = candidates.filter(p=> inAlliance(p, voteWinner));

  let opponent, reason;
  if(nonAllies.length && Math.random()<0.65){
    opponent = nonAllies[Math.floor(Math.random()*nonAllies.length)];
    reason = 'chooses someone they believe they can beat';
  }else if(allies.length){
    opponent = allies[Math.floor(Math.random()*allies.length)];
    reason = 'keeps the key within their alliance';
  }else{
    opponent = candidates[Math.floor(Math.random()*candidates.length)];
    reason = 'makes a neutral pick';
  }
  log(`${voteWinner} chooses to duel ${opponent} — ${reason}.`);

  const duelWinner = Math.random() < 0.5 ? voteWinner : opponent;
  keys[duelWinner].push('P2');
  log(`${duelWinner} wins the duel and earns a Phase 2 key.`);

  evolveAlliancesAfterVote(votePairs);
  updateProgress();
  round++;
}

function endPhase2(){
  const advancing = players.filter(p=>keys[p].includes('P2'));
  const phaseOut  = players.filter(p=>!advancing.includes(p));

  phaseOut.forEach(p=>{ if(!eliminated.includes(p)) eliminated.push(p) });
  phaseOut.forEach(p=>jury.push({name:p, phase:2}));

  players = advancing;
  log(`Phase 2 complete. Eliminated: ${phaseOut.join(', ')}`);
  renderMasterVoteTable();
  round = 1; phase = 3; phase3Step = 0;
  nextRound();
}

/* ====== Phase 3 (Two-step) ====== */
let p3_voteWinner = null;
let p3_chosenAlly = null;
let p3_duelists = [];

function runPhase3(){
  if(phase3Step === 0){
    log(`Phase 3 — Final Cut: Vote step`);
    // All remaining players vote; cannot vote for self
    const votePairsRaw = simulateVote(players, players);
    const votePairs = votePairsRaw.map(([v,to])=>{
      if(v===to){
        const choices = players.filter(p=>p!==v);
        return [v, choices[Math.floor(Math.random()*choices.length)]];
      }
      return [v,to];
    });
    let [voteWinner] = tally(votePairs, players);
    p3_voteWinner = voteWinner;
    log(`${voteWinner} wins the vote and becomes a finalist.`);

    const available = players.filter(p=>p!==voteWinner);
    const allyOpts = available.filter(p=>inAlliance(p, voteWinner));
    p3_chosenAlly = (allyOpts.length ? allyOpts : available)[Math.floor(Math.random()* (allyOpts.length?allyOpts.length:available.length))];
    log(`${voteWinner} selects ${p3_chosenAlly} to join them in the finale.`);

    // Add P3 vote column to season chart
    addVoteColumn(`P3 Vote`, 'P3', 1, knownVoters, votePairs, voteWinner, null);

    // Duelists are the remaining two
    p3_duelists = players.filter(p=>p!==voteWinner && p!==p3_chosenAlly);
    log(`Next: ${p3_duelists[0]} vs ${p3_duelists[1]} duel for the last spot. Click Next to resolve.`);
    finalists = [p3_voteWinner, p3_chosenAlly];
    updateProgress();
    phase3Step = 1;
    return;
  }

  if(phase3Step === 1){
    const duelWinner = Math.random() < 0.5 ? p3_duelists[0] : p3_duelists[1];
    const duelLoser  = p3_duelists.find(p=>p!==duelWinner);
    finalists.push(duelWinner);
    if(!eliminated.includes(duelLoser)) eliminated.push(duelLoser);
    jury.push({name:duelLoser, phase:3});
    log(`${duelWinner} wins the final duel. ${duelLoser} is eliminated and joins the jury.`);
    updateProgress();

    phase = 4;
    phase3Step = 0;
    log(`Click Next to proceed to the Vault Finale.`);
  }
}

/* ====== Finale ====== */
function runFinale(){
  log(`Vault Finale — Finalists: ${finalists.join(', ')}`);

  // Each finalist starts with 3 base keys
  const finalistKeys = {};
  finalists.forEach(p => finalistKeys[p] = 3);

  // Support score by alliance overlap to guide vault choices and jury tilt
  const supportScore = {};
  finalists.forEach(f=>{
    let score = 0;
    jury.forEach(j=>{
      const cap = j.phase===1?1:j.phase===2?2:4;
      if(inAlliance(j.name, f)) score += cap;
    });
    supportScore[f] = score;
  });

  // Expectation heuristic ~ 6..12 keys total
  const expect = {};
  const maxSupport = Math.max(1, ...Object.values(supportScore));
  finalists.forEach(f=>{
    const normalized = (supportScore[f]/maxSupport);
    expect[f] = Math.round(6 + normalized * 6); // 6..12
  });

  const chosenVaults = pickUniqueVaultsForFinalists(expect);

  // Distribute exactly 16 jury keys with per-juror caps and “mostly one finalist” behavior
  const jm = distributeJuryKeysExact16(finalists, jury, finalistKeys);
  displayJuryMatrix(jm);

  // Determine winner: highest vault they can open
  const result = finalists.map(name => ({
    name,
    keys: finalistKeys[name],
    vault: chosenVaults[name]
  })).sort((a,b)=>b.vault - a.vault);

  let winner = result.find(r => r.keys >= r.vault);
  if(!winner){
    const fourth = jury.find(j=>j.phase===3)?.name || 'Fourth Place';
    log(`No finalist opened a vault. ${fourth} wins by default.`);
  }else{
    log(`${winner.name} opens the ${winner.vault}-key vault with ${winner.keys} keys and wins.`);
  }

  // End of game
  endGameUI();
}

/* Unique vaults closest to expectations, no duplicates */
function pickUniqueVaultsForFinalists(expect){
  const picked = {};
  const available = vaults.slice();
  const order = Object.keys(expect).sort((a,b)=>expect[b]-expect[a]);
  order.forEach(f=>{
    let best = available[0], bestDiff = Infinity, bestIdx = 0;
    available.forEach((v,i)=>{
      const d = Math.abs(v - expect[f]);
      if(d < bestDiff){ bestDiff = d; best = v; bestIdx = i; }
    });
    picked[f] = best;
    available.splice(bestIdx, 1);
  });
  log(`Vault choices based on expectations: ${order.map(f=>`${f} → ${picked[f]}`).join(', ')}`);
  return picked;
}

/* Jury distribution that totals EXACTLY 16 keys with per-juror caps.
   Jurors usually dump keys on one finalist unless they share alliances with two. */
function distributeJuryKeysExact16(finalists, jury, finalistKeys){
  const capPool = [];
  jury.forEach(j=>{
    const cap = j.phase===1?1:j.phase===2?2:4;
    for(let i=0;i<cap;i++) capPool.push(j.name);
  });

  shuffle(capPool);
  const draws = capPool.slice(0,16);

  const jm = {};
  jury.forEach(j=>{ jm[j.name] = Object.fromEntries(finalists.map(f=>[f,0])) });

  draws.forEach(jName=>{
    const j = jury.find(x=>x.name===jName);
    const shared = finalists.filter(f=>inAlliance(j.name, f));
    let target;
    if(shared.length === 1){
      target = shared[0]; // give to ally
    }else if(shared.length === 2){
      target = Math.random()<0.6 ? finalists.slice().sort((a,b)=>expectedSupport(b)-expectedSupport(a))[0]
                                 : finalists[Math.floor(Math.random()*finalists.length)];
    }else{
      target = Math.random()<0.65 ? finalists.slice().sort((a,b)=>expectedSupport(b)-expectedSupport(a))[0]
                                  : finalists[Math.floor(Math.random()*finalists.length)];
    }
    jm[jName][target] += 1;
    finalistKeys[target] += 1;
  });

  return jm;

  function expectedSupport(f){
    let s = 0;
    jury.forEach(j=>{
      const cap = j.phase===1?1:j.phase===2?2:4;
      if(inAlliance(j.name, f)) s += cap;
    });
    return s;
  }
}

/* ====== UI: Jury Matrix ====== */
function displayJuryMatrix(matrix){
  const area = document.getElementById('juryMatrix');
  if(!finalists.length){ area.innerHTML = ''; return }
  let html = `<div class="table-scroll"><table><tr><th>Juror</th>${finalists.map(f=>`<th>${f}</th>`).join('')}<th>Total</th></tr>`;
  let totalGiven = 0;
  for(const juror in matrix){
    let sum = 0;
    html += `<tr><td>${juror}</td>`;
    finalists.forEach(f=>{
      const v = matrix[juror][f]||0;
      sum += v; totalGiven += v;
      html += `<td>${v}</td>`;
    });
    html += `<td>${sum}</td></tr>`;
  }
  html += `</table></div>`;
  html += `<div class="hint">Total jury keys distributed: <strong>${totalGiven}</strong> (should be exactly 16)</div>`;
  area.innerHTML = html;
}

/* ====== Wire up ====== */
updateProgress();

</script>
</body>
</html>