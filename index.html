<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Vault Simulator</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f4f4f4; padding: 20px; }
    h2 { margin-top: 40px; }
    #log, #votingMatrix, #juryMatrix, #progressTable, #allianceBox {
      background: white; border: 1px solid #ccc; padding: 10px; margin-top: 10px;
    }
    #log { height: 150px; overflow-y: auto; }
    textarea { width: 100%; height: 120px; }
    button { margin: 5px 0; padding: 8px 12px; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border: 1px solid #ccc; padding: 4px; text-align: center; }
    .keyholder { background: #d4edda; }
    details { margin-top: 5px; }
    .sidebar {
      display: flex;
      justify-content: space-between;
      gap: 20px;
    }
    .sidebar > div { flex: 1; }
  </style>
</head>
<body>

<h1>The Vault Simulator</h1>

<textarea id="playerInput" placeholder="Enter one player per line (12 total)"></textarea>
<button onclick="startGame()">Start Game</button>
<button onclick="nextRound()" id="nextRoundBtn" style="display:none;">Next Round</button>

<div class="sidebar">
  <div>
    <h2>Round Events</h2>
    <div id="log"></div>

    <h2>Voting Matrix</h2>
    <div id="votingMatrix"></div>

    <h2>Jury Key Matrix</h2>
    <div id="juryMatrix"></div>
  </div>
  <div>
    <h2>Alliances</h2>
    <div id="allianceBox"></div>

    <h2>Progress Chart</h2>
    <div id="progressTable"></div>
  </div>
</div>

<script>
let players = [];
let activePlayers = [];
let eliminatedPlayers = [];
let alliances = [];
let round = 0;
let phase = 1;
let gameStarted = false;
let lockpickHolder = null;
let lockpickUsed = false;
let currentVoteMatrix = [];

function startGame() {
  const input = document.getElementById("playerInput").value.trim().split("\n").map(x => x.trim()).filter(x => x);
  if (input.length !== 12) return alert("Enter exactly 12 players.");
  players = input.map(name => ({ name, eliminated: false, key1: false, key2: false, key3: false, votes: [], allianceIds: [] }));
  activePlayers = [...players];
  eliminatedPlayers = [];
  round = 0;
  phase = 1;
  gameStarted = true;
  lockpickHolder = null;
  lockpickUsed = false;
  generateAlliances();
  updateAllianceBox();
  updateProgressChart();
  document.getElementById("nextRoundBtn").innerText = "Next Round";
  document.getElementById("nextRoundBtn").style.display = "inline-block";
  document.getElementById("log").innerHTML = "Game started with 12 players.";
  document.getElementById("votingMatrix").innerHTML = "";
  document.getElementById("juryMatrix").innerHTML = "";
}

function generateAlliances() {
  const a1 = { name: "Alliance A", members: shuffle([...players]).slice(0, 4) };
  const a2 = { name: "Alliance B", members: shuffle([...players]).slice(0, 4) };
  const a3 = { name: "Alliance C", members: shuffle([...players]).slice(0, 4) };
  alliances = [a1, a2, a3];
  players.forEach(p => p.allianceIds = []);
  alliances.forEach((a, idx) => a.members.forEach(m => {
    const player = players.find(p => p.name === m.name);
    if (!player.allianceIds.includes(idx)) player.allianceIds.push(idx);
  }));
}

function updateAllianceBox() {
  let html = "";
  alliances.forEach((a, i) => {
    html += `<strong>${a.name}</strong>: ${a.members.map(m => m.name).join(", ")}<br>`;
  });
  document.getElementById("allianceBox").innerHTML = html;
}

function updateProgressChart() {
  let html = `<table><tr><th>Player</th><th>Phase 1</th><th>Phase 2</th><th>Phase 3</th></tr>`;
  players.forEach(p => {
    const k1 = p.key1 ? "✅" : "";
    const k2 = p.key2 ? "✅" : "";
    const k3 = p.key3 ? "✅" : "";
    html += `<tr><td>${p.name}</td><td>${k1}</td><td>${k2}</td><td>${k3}</td></tr>`;
  });
  html += `</table>`;
  document.getElementById("progressTable").innerHTML = html;
}

function updateEventLog(text) {
  document.getElementById("log").innerHTML = text;
}

function shuffle(array) {
  let arr = [...array];
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
</script>

function nextRound() {
  if (!gameStarted) return;

  // Clear previous voting matrix and log
  document.getElementById("votingMatrix").innerHTML = "";
  document.getElementById("juryMatrix").innerHTML = "";

  if (phase === 1) {
    runPhase1();
  } else if (phase === 2) {
    runPhase2();
  } else if (phase === 3) {
    runPhase3();
  } else if (phase === 4) {
    runVaultFinale();
  }

  updateProgressChart();
}

function runPhase1() {
  if (round >= 4) {
    // Eliminate players without a key
    const eliminated = players.filter(p => !p.key1);
    eliminated.forEach(p => p.eliminated = true);
    eliminatedPlayers.push(...eliminated);
    activePlayers = players.filter(p => !p.eliminated);
    updateEventLog("Phase 1 complete. Eliminated: " + eliminated.map(p => p.name).join(", "));
    phase = 2;
    round = 0;
    return;
  }

  const logLines = [];
  logLines.push(`<strong>Phase 1 - Round ${round + 1}</strong>`);
  const drawn = shuffle(activePlayers.filter(p => !p.key1)).slice(0, 4);
  logLines.push("Drawn players: " + drawn.map(p => p.name).join(", "));

  // Lockpick random discovery
  if (!lockpickHolder && Math.random() < 0.33) {
    const lucky = drawn[Math.floor(Math.random() * drawn.length)];
    lockpickHolder = lucky.name;
    logLines.push(`${lucky.name} found the Lockpick!`);
  }

  let voteWinner;
  if (lockpickHolder && drawn.some(p => p.name === lockpickHolder)) {
    voteWinner = players.find(p => p.name === lockpickHolder);
    voteWinner.key1 = true;
    logLines.push(`${voteWinner.name} used the Lockpick and claimed the vote key!`);
    lockpickUsed = true;
    lockpickHolder = null;
  } else {
    voteWinner = drawn[Math.floor(Math.random() * drawn.length)];
    voteWinner.key1 = true;
    logLines.push(`${voteWinner.name} won the vote and received a key.`);
  }

  const challengers = drawn.filter(p => p.name !== voteWinner.name);
  const challengeWinner = challengers[Math.floor(Math.random() * challengers.length)];
  challengeWinner.key1 = true;
  logLines.push(`${challengeWinner.name} won the challenge and received a key.`);

  round++;
  renderVotingMatrix([
    { voter: "House", vote: voteWinner.name },
    { voter: "Challenge", vote: challengeWinner.name }
  ]);

  updateEventLog(logLines.join("<br>"));
}

function runPhase2() {
  if (round >= 4) {
    const eliminated = activePlayers.filter(p => !p.key2);
    eliminated.forEach(p => p.eliminated = true);
    eliminatedPlayers.push(...eliminated);
    activePlayers = players.filter(p => !p.eliminated);
    updateEventLog("Phase 2 complete. Eliminated: " + eliminated.map(p => p.name).join(", "));
    phase = 3;
    round = 0;
    return;
  }

  const logLines = [];
  logLines.push(`<strong>Phase 2 - Round ${round + 1}</strong>`);

  const eligible = activePlayers.filter(p => !p.key2);
  let voteTarget;
  let duelOpponent;

  // Lockpick used
  if (lockpickHolder && !lockpickUsed && Math.random() < 0.4) {
    voteTarget = players.find(p => p.name === lockpickHolder);
    lockpickUsed = true;
    lockpickHolder = null;
    logLines.push(`${voteTarget.name} used the Lockpick to override the vote!`);
  } else {
    voteTarget = eligible[Math.floor(Math.random() * eligible.length)];
  }

  // Pick opponent
  const otherEligibles = eligible.filter(p => p.name !== voteTarget.name);
  if (otherEligibles.length === 0) {
    duelOpponent = voteTarget;
  } else {
    duelOpponent = otherEligibles[Math.floor(Math.random() * otherEligibles.length)];
  }

  const winner = Math.random() < 0.5 ? voteTarget : duelOpponent;
  winner.key2 = true;
  logLines.push(`${voteTarget.name} and ${duelOpponent.name} dueled. ${winner.name} won the key.`);

  round++;
  renderVotingMatrix([
    { voter: "House", vote: voteTarget.name },
    { voter: "Challenge", vote: winner.name }
  ]);

  updateEventLog(logLines.join("<br>"));
}

function runPhase3() {
  const logLines = [];
  if (round === 0) {
    logLines.push(`<strong>Phase 3 - Final 4 Vote</strong>`);
    const finalists = activePlayers;
    const voteWinner = finalists[Math.floor(Math.random() * finalists.length)];
    voteWinner.key3 = true;

    const ally = finalists.filter(p => p.name !== voteWinner.name)[Math.floor(Math.random() * 3)];
    ally.key3 = true;

    const remaining = finalists.filter(p => p.name !== voteWinner.name && p.name !== ally.name);
    const challengeWinner = remaining[Math.floor(Math.random() * remaining.length)];
    challengeWinner.key3 = true;

    const eliminated = remaining.find(p => p.name !== challengeWinner.name);
    eliminated.eliminated = true;
    eliminatedPlayers.push(eliminated);
    activePlayers = finalists.filter(p => !p.eliminated);

    logLines.push(`${voteWinner.name} won the vote and brought ${ally.name}.`);
    logLines.push(`${challengeWinner.name} won the final duel.`);
    logLines.push(`${eliminated.name} was eliminated.`);

    renderVotingMatrix([
      { voter: "House", vote: voteWinner.name },
      { voter: "Pick", vote: ally.name },
      { voter: "Duel", vote: challengeWinner.name }
    ]);

    updateEventLog(logLines.join("<br>"));
    phase = 4;
    round = 0;
  }
}

function runVaultFinale() {
  const logLines = [];
  logLines.push(`<strong>The Vault Finale</strong>`);

  const finalists = activePlayers;
  const jury = eliminatedPlayers;

  // Jury distributes keys
  const keyDistribution = {};
  finalists.forEach(f => keyDistribution[f.name] = 3);

  jury.forEach(j => {
    const keys = j.key3 ? 4 : j.key2 ? 2 : 1;
    for (let i = 0; i < keys; i++) {
      const target = finalists[Math.floor(Math.random() * finalists.length)];
      keyDistribution[target.name]++;
    }
  });

  let matrix = `<table><tr><th>Jury</th>`;
  finalists.forEach(f => matrix += `<th>${f.name}</th>`);
  matrix += `</tr>`;

  jury.forEach(j => {
    matrix += `<tr><td>${j.name}</td>`;
    finalists.forEach(f => {
      const count = Math.floor(Math.random() * 2); // random split
      matrix += `<td>${count}</td>`;
    });
    matrix += `</tr>`;
  });
  matrix += `</table>`;
  document.getElementById("juryMatrix").innerHTML = matrix;

  const winner = Object.entries(keyDistribution).sort((a, b) => b[1] - a[1])[0][0];
  logLines.push(`${winner} wins The Vault with the most keys!`);
  updateEventLog(logLines.join("<br>"));
  document.getElementById("nextRoundBtn").innerText = "Simulate Again";
  document.getElementById("nextRoundBtn").onclick = () => location.reload();
}

function renderVotingMatrix(votes) {
  let html = `<details open><summary>Voting Matrix</summary><table><tr><th>Voter</th><th>Vote</th></tr>`;
  votes.forEach(v => {
    html += `<tr><td>${v.voter}</td><td>${v.vote}</td></tr>`;
  });
  html += `</table></details>`;
  document.getElementById("votingMatrix").innerHTML = html;
}
</body>
</html>