<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>The Vault Simulator</title>
  <style>
    body { font-family: Arial, sans-serif; display: flex; }
    #leftColumn, #rightColumn { width: 50%; padding: 20px; box-sizing: border-box; }
    #log, #progressTable, #votingChart, #liveVotingMatrix, #alliancesBox {
      margin-top: 20px;
    }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    .eliminated { background-color: #ddd; }
  </style>
</head>
<body>

<div id="leftColumn">
  <h2>The Vault Simulator</h2>
  <textarea id="playerInput" rows="12" placeholder="Enter 12 players, one per line"></textarea><br>
  <button id="startBtn" onclick="startGame()">Start Game</button>
  <button id="nextBtn" style="display:none;" onclick="runRound()">Next Round</button>
  <div id="log"></div>
  <div id="liveVotingMatrix"></div>
</div>

<div id="rightColumn">
  <div id="alliancesBox"></div>
  <div id="progressTable"></div>
  <div id="votingChart"></div>
</div>

<script>
let players = [];
let round = 1;
let phase = 1;
let phase3Step = 0;
let lockpickHolder = null;
let lockpickUsed = false;
let eliminated = [];
let finalists = [];
const vaults = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22];
let alliances = [];

function startGame() {
  const input = document.getElementById("playerInput").value.trim().split("\n").map(s => s.trim()).filter(Boolean);
  if (input.length !== 12) return alert("Enter exactly 12 players.");

  players = input.map(name => ({
    name,
    alliance: [],
    key1: false,
    key2: false,
    key3: false,
    totalKeys: 0,
    totalFinalKeys: 0,
    eliminated: false
  }));

  assignAlliances();
  updateAlliancesBox();
  updateTable();
  clearLog();
  log(`Game started with 12 players.`);

  document.getElementById("startBtn").style.display = "none";
  document.getElementById("nextBtn").style.display = "inline";

  phase = 1;
  round = 1;
  runRound();
}
function assignAlliances() {
  alliances = [
    { name: "Alliance A", members: [] },
    { name: "Alliance B", members: [] },
    { name: "Alliance C", members: [] }
    { name: "Alliance D", members: [] }
  ];
  let shuffled = shuffle([...players]);
  alliances[0].members = shuffled.slice(0, 5);
  alliances[1].members = shuffled.slice(3, 8);
  alliances[2].members = shuffled.slice(6, 11);

  for (let player of players) {
    player.alliance = alliances.filter(a => a.members.includes(player)).map(a => a.name);
  }
}

function updateAlliancesBox() {
  let html = "<h3>Alliances</h3>";
  alliances.forEach(alliance => {
    html += `<details open><summary>${alliance.name}</summary><ul>`;
    alliance.members.forEach(member => {
      html += `<li>${member.name}</li>`;
    });
    html += "</ul></details>";
  });
  document.getElementById("alliancesBox").innerHTML = html;
}

function runRound() {
  clearLog();
  document.getElementById("liveVotingMatrix").innerHTML = "";

  if (phase === 1) return runPhase1();
  if (phase === 2) return runPhase2();
  if (phase === 3) {
    if (phase3Step === 0) return runPhase3Vote();
    if (phase3Step === 1) return runPhase3Challenge();
  }
  if (phase === 4) return runFinale();
}

function runPhase1() {
  log(`Phase 1 – Round ${round}`);

  const keyholders = players.filter(p => p.key1);
  const noKey = players.filter(p => !p.key1);

  if (round === 4) {
    const drawn = noKey;
    let votingDetails = [];
    for (let v of players) {
      const voteFor = pickAllyOrRandom(v, drawn);
      votingDetails.push({ voter: v.name, votee: voteFor.name });
    }
    const tally = {};
    votingDetails.forEach(v => {
      tally[v.votee] = (tally[v.votee] || 0) + 1;
    });
    const sorted = Object.entries(tally).sort((a, b) => b[1] - a[1]);
    const top = sorted.filter(e => e[1] === sorted[0][1]);
    const winnerName = shuffle(top)[0][0];
    const voteWinner = players.find(p => p.name === winnerName);
    voteWinner.key1 = true;
    voteWinner.totalKeys++;

    const remaining = drawn.filter(p => p !== voteWinner);
    const challengeWinner = shuffle(remaining)[0];
    challengeWinner.key1 = true;
    challengeWinner.totalKeys++;

    displayVotingMatrix(round, votingDetails, voteWinner.name, "Phase 1");
    round++;
    phase = 2;
    round = 1;

    // eliminate players with no key1
    for (let p of players) {
      if (!p.key1) {
        p.eliminated = true;
        eliminated.push(p);
      }
    }
    updateTable();
    return;
  }

  const eligible = shuffle(noKey).slice(0, 4);
  let votingDetails = [];
  for (let v of players) {
    const voteFor = pickAllyOrRandom(v, eligible);
    votingDetails.push({ voter: v.name, votee: voteFor.name });
  }
  const tally = {};
  votingDetails.forEach(v => {
    tally[v.votee] = (tally[v.votee] || 0) + 1;
  });
  const sorted = Object.entries(tally).sort((a, b) => b[1] - a[1]);
  const top = sorted.filter(e => e[1] === sorted[0][1]);
  const winnerName = shuffle(top)[0][0];
  const voteWinner = players.find(p => p.name === winnerName);
  voteWinner.key1 = true;
  voteWinner.totalKeys++;

  const challengePool = eligible.filter(p => p !== voteWinner);
  const challengeWinner = shuffle(challengePool)[0];
  challengeWinner.key1 = true;
  challengeWinner.totalKeys++;

  displayVotingMatrix(round, votingDetails, voteWinner.name, "Phase 1");

  round++;
  updateTable();
}
function runPhase2() {
  log(`Phase 2 – Round ${round}`);
  const eligible = players.filter(p => !p.eliminated && !p.key2);
  const voters = players.filter(p => !p.eliminated);

  if (eligible.length === 0 || round > 4) {
    phase = 3;
    round = 1;
    updateTable();
    return;
  }

  // Check for Lockpick
  if (!lockpickHolder && Math.random() < 0.33) {
    lockpickHolder = shuffle(eligible)[0];
    log(`${lockpickHolder.name} found the Lockpick!`);
  }

  let votingDetails = [];
  let voteTally = {};
  let voteWinner;

  if (lockpickHolder && !lockpickUsed && eligible.includes(lockpickHolder)) {
    lockpickUsed = true;
    voteWinner = lockpickHolder;
    log(`${voteWinner.name} used the Lockpick to override the vote!`);
  } else {
    for (let v of voters) {
      const voteFor = pickAllyOrRandom(v, eligible);
      votingDetails.push({ voter: v.name, votee: voteFor.name });
      voteTally[voteFor.name] = (voteTally[voteFor.name] || 0) + 1;
    }

    const sorted = Object.entries(voteTally).sort((a, b) => b[1] - a[1]);
    const top = sorted.filter(e => e[1] === sorted[0][1]);
    const winnerName = shuffle(top)[0][0];
    voteWinner = players.find(p => p.name === winnerName);
  }

  let duelOpponent;
  const otherEligible = eligible.filter(p => p !== voteWinner);

  if (voteTally[voteWinner.name] && Object.values(voteTally).filter(x => x === voteTally[voteWinner.name]).length > 1) {
    // Tie: top vote-getters duel
    const tied = Object.entries(voteTally).filter(([_, count]) => count === voteTally[voteWinner.name]).map(([name]) => name);
    const duelists = eligible.filter(p => tied.includes(p.name));
    [voteWinner, duelOpponent] = shuffle(duelists);
    log(`Vote tied – ${voteWinner.name} and ${duelOpponent.name} must duel!`);
  } else {
    duelOpponent = pickAllyOrRandom(voteWinner, otherEligible);
    log(`${voteWinner.name} chooses to duel ${duelOpponent.name}`);
  }

  const winner = shuffle([voteWinner, duelOpponent])[0];
  winner.key2 = true;
  winner.totalKeys++;
  log(`${winner.name} wins the duel and earns a key!`);

  round++;
  updateTable();

  const votingWinnerName = voteWinner ? voteWinner.name : "TIE";
  displayVotingMatrix(round - 1, votingDetails, votingWinnerName, "Phase 2");
}
function runPhase3Vote() {
  log(`Phase 3 – Final 4 Vote`);

  const active = players.filter(p => !p.eliminated);
  let votingDetails = [];
  let voteTally = {};

  for (let v of active) {
    const options = active.filter(p => p !== v);
    const voteFor = pickAllyOrRandom(v, options);
    votingDetails.push({ voter: v.name, votee: voteFor.name });
    voteTally[voteFor.name] = (voteTally[voteFor.name] || 0) + 1;
  }

  const sorted = Object.entries(voteTally).sort((a, b) => b[1] - a[1]);
  const top = sorted.filter(e => e[1] === sorted[0][1]);
  const winnerName = shuffle(top)[0][0];
  const voteWinner = players.find(p => p.name === winnerName);
  voteWinner.key3 = true;
  voteWinner.totalKeys++;

  const others = active.filter(p => p !== voteWinner);
  const chosen = pickAllyOrRandom(voteWinner, others);
  chosen.key3 = true;
  chosen.totalKeys++;

  const remaining = others.filter(p => p !== chosen);
  log(`${voteWinner.name} wins the vote and brings ${chosen.name} to the finale.`);
  log(`${remaining.map(p => p.name).join(" and ")} will face off in a final challenge.`);

  finalists = [voteWinner, chosen];
  finalChallengePlayers = remaining;
  phase3Step = 1;

  displayVotingMatrix("Final", votingDetails, voteWinner.name, "Phase 3");
  updateTable();
}

function runPhase3Challenge() {
  const winner = shuffle(finalChallengePlayers)[0];
  winner.key3 = true;
  winner.totalKeys++;
  log(`${winner.name} wins the final challenge and joins the finale.`);

  const loser = finalChallengePlayers.find(p => p !== winner);
  loser.eliminated = true;
  eliminated.push(loser);
  log(`${loser.name} is eliminated and will distribute 4 jury keys.`);

  finalists.push(winner);
  phase = 4;
  round = 1;
  updateTable();
}

function runFinale() {
  log("Vault Finale Begins!");

  // Award 3 base keys
  for (let p of finalists) {
    p.totalFinalKeys = 3;
  }

  let jury = eliminated;
  const juryMatrix = {};
  for (let juror of jury) {
    const keysToGive = juror.key3 ? 4 : juror.key2 ? 2 : 1;
    juryMatrix[juror.name] = {};

    let targets = shuffle([...finalists]);
    while (targets.length > 0 && keysToGive > 0) {
      const giveTo = targets.pop();
      const amt = Math.min(keysToGive, Math.floor(Math.random() * keysToGive) + 1);
      juryMatrix[juror.name][giveTo.name] = amt;
      giveTo.totalFinalKeys += amt;
    }
  }

  let chart = "<h3>Jury Key Distribution</h3><table><tr><th>Juror</th>";
  finalists.forEach(f => chart += `<th>${f.name}</th>`);
  chart += "</tr>";

  for (let juror in juryMatrix) {
    chart += `<tr><td>${juror}</td>`;
    finalists.forEach(f => {
      chart += `<td>${juryMatrix[juror][f.name] || 0}</td>`;
    });
    chart += "</tr>";
  }

  chart += "</table>";
  document.getElementById("votingChart").innerHTML = chart;

  // Vault picks
  let picks = [...vaults].sort((a, b) => b - a);
  finalists.sort((a, b) => b.totalFinalKeys - a.totalFinalKeys);
  let winner = null;

  for (let i = 0; i < finalists.length; i++) {
    const f = finalists[i];
    const guessRange = f.totalFinalKeys;
    const vaultPick = picks.find(v => v <= guessRange);
    if (vaultPick) {
      f.vault = vaultPick;
      picks = picks.filter(v => v !== vaultPick);
    } else {
      f.vault = "X";
    }
  }

  // Winner is whoever opens the highest vault
  const opened = finalists.filter(f => f.vault !== "X");
  if (opened.length > 0) {
    winner = opened.sort((a, b) => b.vault - a.vault)[0];
    log(`${winner.name} opens the highest vault (${winner.vault} keys) and wins The Vault!`);
  } else {
    const backup = players.find(p => p.eliminated && p.key3);
    if (backup) {
      log(`No vaults opened. ${backup.name}, the 4th place finisher, wins The Vault!`);
    } else {
      log(`No vaults opened. No winner.`);
    }
  }

  document.getElementById("nextBtn").textContent = "Simulate Again";
  document.getElementById("nextBtn").onclick = () => location.reload();
}
function updateTable() {
  let html = "<h3>Player Progress</h3><table><tr><th>Name</th><th>Key 1</th><th>Key 2</th><th>Key 3</th><th>Total Keys</th></tr>";
  for (let p of players) {
    if (p.eliminated) continue;
    html += `<tr${p.eliminated ? ' class="eliminated"' : ''}>
      <td>${p.name}</td>
      <td>${p.key1 ? "✅" : ""}</td>
      <td>${p.key2 ? "✅" : ""}</td>
      <td>${p.key3 ? "✅" : ""}</td>
      <td>${p.totalKeys}</td>
    </tr>`;
  }
  html += "</table>";
  document.getElementById("progressTable").innerHTML = html;
}

function clearLog() {
  document.getElementById("log").innerHTML = "";
}

function log(msg) {
  const box = document.getElementById("log");
  box.innerHTML += `<div>${msg}</div>`;
}

function shuffle(array) {
  let a = [...array];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function pickAllyOrRandom(voter, choices) {
  const allies = choices.filter(p => {
    return p.alliance.some(a => voter.alliance.includes(a));
  });
  return shuffle(allies.length ? allies : choices)[0];
}

function displayVotingMatrix(roundLabel, voteData, winner, phaseLabel) {
  let html = `<details open><summary>Voting Matrix – ${phaseLabel} Round ${roundLabel}</summary>`;
  html += `<table><tr><th>Voter</th><th>Voted For</th></tr>`;
  for (let v of voteData) {
    html += `<tr><td>${v.voter}</td><td>${v.votee}</td></tr>`;
  }
  html += `<tr><td colspan="2"><b>Vote Winner: ${winner}</b></td></tr>`;
  html += "</table></details>";
  document.getElementById("liveVotingMatrix").innerHTML = html;
}
</script>

</body>
</html>