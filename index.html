<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Vault Simulator</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    #log, #votingChart, #votingMatrix { margin-top: 20px; }
    #log { max-height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; }
    #progressTable, table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 5px; text-align: center; }
    .keyholder { background-color: #d4edda; font-weight: bold; }
    .eliminated { background-color: #f8d7da; text-decoration: line-through; }
    #alliances { margin-top: 20px; float: right; width: 25%; }
    #main { width: 70%; float: left; }
    details summary { cursor: pointer; font-weight: bold; }
  </style>
</head>
<body>
  <h1>The Vault Simulator</h1>
  <textarea id="playerInput" rows="12" cols="30" placeholder="Enter one player per line..."></textarea><br>
  <button onclick="startGame()">Start Game</button>
  <div id="main">
    <button id="nextBtn" onclick="runRound()" style="display:none;">Next Round</button>
    <div id="progressTable"></div>
    <div id="votingMatrix"></div>
    <div id="votingChart"></div>
    <div id="log"></div>
  </div>
  <div id="alliances">
    <h3>Alliances</h3>
    <div id="allianceBox"></div>
  </div>

  <script>
    let players = [], round = 1, phase = 1, lockpickHolder = null, lockpickUsed = false;
    let eliminated = [], finalists = [], phase3Duel = [], juryMatrix = [], alliances = [], phase3Step = 0;

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function startGame() {
      const names = document.getElementById("playerInput").value.trim().split("\n").filter(n => n);
      if (names.length !== 12) return alert("Enter exactly 12 players.");
      players = names.map(n => ({ name: n, key1: false, key2: false, key3: false, totalFinalKeys: 0, eliminated: false }));
      round = 1; phase = 1; lockpickHolder = null; lockpickUsed = false;
      eliminated = []; finalists = []; phase3Duel = []; phase3Step = 0; juryMatrix = [];

      generateAlliances();
      updateAllianceBox();
      document.getElementById("nextBtn").style.display = "inline-block";
      document.getElementById("log").innerHTML = "";
      document.getElementById("votingMatrix").innerHTML = "";
      document.getElementById("votingChart").innerHTML = "";
      runRound();
    }

    function getActivePlayers() {
      return players.filter(p => !p.eliminated && !finalists.includes(p));
    }

    function generateAlliances() {
      const shuffled = [...players];
      shuffle(shuffled);
      alliances = [
        { name: "The Untucked Dolls", members: shuffled.slice(0, 4).map(p => p.name) },
        { name: "Pretty Problematic", members: shuffled.slice(3, 7).map(p => p.name) },
        { name: "Confessional Crushers", members: shuffled.slice(6, 10).map(p => p.name) }
      ];
    }

    function updateAllianceBox() {
      let html = "<ul>";
      alliances.forEach(a => {
        html += `<li><strong>${a.name}</strong><ul>${a.members.map(m => `<li>${m}</li>`).join("")}</ul></li>`;
      });
      html += "</ul>";
      document.getElementById("allianceBox").innerHTML = html;
    }

    function updateProgressTable() {
      let html = "<h3>Progress</h3><table><tr><th>Player</th><th>Phase 1</th><th>Phase 2</th><th>Phase 3</th><th>Total Keys</th></tr>";
      players.forEach(p => {
        const c1 = p.key1 ? "keyholder" : p.eliminated ? "eliminated" : "";
        const c2 = p.key2 ? "keyholder" : p.eliminated ? "eliminated" : "";
        const c3 = p.key3 ? "keyholder" : p.eliminated ? "eliminated" : "";
        html += `<tr class="${p.eliminated ? 'eliminated' : ''}"><td>${p.name}</td><td class="${c1}">${p.key1 ? "✅" : ""}</td><td class="${c2}">${p.key2 ? "✅" : ""}</td><td class="${c3}">${p.key3 ? "✅" : ""}</td><td>${p.totalFinalKeys}</td></tr>`;
      });
      html += "</table>";
      document.getElementById("progressTable").innerHTML = html;
    }

    function log(text) {
      document.getElementById("log").innerHTML = `<div>${text}</div>`;
    }

    function createVotingMatrix(title, votes) {
      let html = `<details open><summary>${title}</summary><table><tr><th>Voter</th><th>Voted For</th></tr>`;
      votes.forEach(v => {
        html += `<tr><td>${v.voter}</td><td>${v.voted}</td></tr>`;
      });
      html += "</table></details>";
      document.getElementById("votingMatrix").innerHTML = html;
    }

    function runRound() {
      if (phase === 1) runPhase1();
      else if (phase === 2) runPhase2();
      else if (phase === 3) runPhase3();
      else if (phase === 4) runFinale();
    }
  </script>
  <script>
    function runPhase1() {
      const active = getActivePlayers();
      const eligible = active.filter(p => !p.key1);
      if (round <= 4 && eligible.length >= 4) {
        const drawn = [];
        shuffle(eligible);
        for (let i = 0; i < 4; i++) drawn.push(eligible[i]);
        let found = Math.random() < 0.33 ? drawn[Math.floor(Math.random() * 4)].name : null;
        if (found) lockpickHolder = found;

        const voters = players.map(p => p.name);
        const votes = voters.map(voter => {
          const votee = drawn[Math.floor(Math.random() * 4)].name;
          return { voter, voted: votee };
        });

        const tally = {};
        drawn.forEach(p => tally[p.name] = 0);
        votes.forEach(v => tally[v.voted]++);
        let voteWinner = drawn[0].name;
        let max = 0;
        for (let name in tally) {
          if (tally[name] > max) {
            max = tally[name];
            voteWinner = name;
          }
        }

        const challengePlayers = drawn.filter(p => p.name !== voteWinner);
        const challengeWinner = challengePlayers[Math.floor(Math.random() * challengePlayers.length)];

        const voteNote = lockpickHolder === voteWinner ? `${voteWinner} used Lockpick to override vote.` : `${voteWinner} wins the vote key.`;
        const challengeNote = `${challengeWinner.name} wins the challenge key.`;

        const winner1 = players.find(p => p.name === voteWinner);
        winner1.key1 = true;

        const winner2 = players.find(p => p.name === challengeWinner.name);
        winner2.key1 = true;

        if (lockpickHolder) lockpickUsed = true;

        createVotingMatrix(`Phase 1 - Round ${round}`, votes);
        log(`<strong>Drawn:</strong> ${drawn.map(p => p.name).join(", ")}<br><strong>${voteNote}</strong><br><strong>${challengeNote}</strong>`);
        round++;
        updateProgressTable();

        if (round > 4 || getActivePlayers().filter(p => !p.key1).length === 0) {
          const removed = players.filter(p => !p.key1);
          removed.forEach(p => { p.eliminated = true; eliminated.push(p); });
          phase = 2; round = 1;
        }
      }
    }

    function runPhase2() {
      const active = getActivePlayers();
      const noKey = active.filter(p => !p.key2);
      if (noKey.length < 2 || round > 4) {
        const removed = noKey;
        removed.forEach(p => { p.eliminated = true; eliminated.push(p); });
        phase = 3; round = 1;
        return;
      }

      let votes = [];
      let duelists = [];
      const voteOptions = noKey.map(p => p.name);
      const voters = active.map(p => p.name);

      const tiedTally = {};
      voteOptions.forEach(n => tiedTally[n] = 0);
      voters.forEach(voter => {
        const votee = voteOptions[Math.floor(Math.random() * voteOptions.length)];
        tiedTally[votee]++;
        votes.push({ voter, voted: votee });
      });

      const maxVotes = Math.max(...Object.values(tiedTally));
      const top = Object.keys(tiedTally).filter(p => tiedTally[p] === maxVotes);

      if (top.length === 1) {
        const voteWinner = top[0];
        if (lockpickHolder === voteWinner && !lockpickUsed) {
          lockpickUsed = true;
        }
        const duelOpponent = voteOptions.filter(n => n !== voteWinner)[Math.floor(Math.random() * (voteOptions.length - 1))];
        duelists = [players.find(p => p.name === voteWinner), players.find(p => p.name === duelOpponent)];
        log(`<strong>${voteWinner}</strong> wins vote. Chooses <strong>${duelOpponent}</strong> to duel.`);
      } else {
        duelists = top.map(n => players.find(p => p.name === n));
        log(`Vote tie! ${top.join(" & ")} will duel.`);
      }

      const winner = duelists[Math.floor(Math.random() * duelists.length)];
      winner.key2 = true;
      log(`Duel Winner: <strong>${winner.name}</strong> earns a key.`);
      createVotingMatrix(`Phase 2 - Round ${round}`, votes);
      round++;
      updateProgressTable();
    }

    function runPhase3() {
      const active = getActivePlayers();
      if (phase3Step === 0) {
        const votes = [];
        const options = active.map(p => p.name);
        active.forEach(voter => {
          const filtered = options.filter(o => o !== voter.name);
          const votee = filtered[Math.floor(Math.random() * filtered.length)];
          votes.push({ voter: voter.name, voted: votee });
        });

        const tally = {};
        options.forEach(p => tally[p] = 0);
        votes.forEach(v => tally[v.voted]++);
        const max = Math.max(...Object.values(tally));
        const top = Object.keys(tally).filter(p => tally[p] === max);

        if (top.length === 2) {
          phase3Duel = top.map(n => players.find(p => p.name === n));
          finalists = active.filter(p => !top.includes(p.name));
          log(`Vote tie! ${top.join(" & ")} will duel. ${finalists.map(f => f.name).join(", ")} advance.`);
        } else {
          const voteWinner = players.find(p => p.name === top[0]);
          const choice = active.filter(p => p.name !== voteWinner.name)[Math.floor(Math.random() * (active.length - 1))];
          finalists.push(voteWinner, choice);
          phase3Duel = active.filter(p => ![voteWinner.name, choice.name].includes(p.name));
          log(`${voteWinner.name} wins vote and selects ${choice.name}. ${phase3Duel.map(p => p.name).join(" & ")} will duel.`);
        }

        createVotingMatrix(`Phase 3 - Vote`, votes);
        phase3Step = 1;
      } else {
        const winner = phase3Duel[Math.floor(Math.random() * 2)];
        finalists.push(winner);
        const loser = phase3Duel.find(p => p !== winner);
        loser.eliminated = true; eliminated.push(loser);
        finalists.forEach(p => { p.key3 = true; p.totalFinalKeys++; });
        log(`Duel winner: ${winner.name} advances. ${loser.name} is eliminated.`);
        phase = 4; round = 1;
        updateProgressTable();
      }
    }

    function runFinale() {
      const vaults = [3, 8, 13, 17, 22];
      const shuffled = [...vaults];
      shuffle(shuffled);

      finalists.forEach((f, i) => {
        f.vault = shuffled[i];
        f.totalFinalKeys = 3;
      });

      let totalKeysGiven = 0;
      const jury = eliminated;
      jury.forEach(j => {
        const keys = j.key1 ? 1 : j.key2 ? 2 : 4;
        const given = {};
        for (let i = 0; i < keys; i++) {
          const f = finalists[Math.floor(Math.random() * finalists.length)];
          given[f.name] = (given[f.name] || 0) + 1;
          f.totalFinalKeys++;
          totalKeysGiven++;
        }
        juryMatrix.push({ juror: j.name, keys: given });
      });

      // Normalize to 16 keys
      let overage = totalKeysGiven - 16;
      while (overage > 0) {
        const f = finalists[Math.floor(Math.random() * finalists.length)];
        if (f.totalFinalKeys > 3) {
          f.totalFinalKeys--;
          overage--;
        }
      }

      let winner = finalists.filter(f => f.totalFinalKeys >= f.vault).sort((a, b) => b.vault - a.vault)[0];
      if (!winner) {
        const fallback = players.find(p => p.key3 && !finalists.includes(p));
        winner = fallback;
        log(`No finalist opened a vault! Fourth place player <strong>${winner.name}</strong> wins!`);
      } else {
        log(`<strong>${winner.name}</strong> opens the vault (${winner.vault} keys needed) with ${winner.totalFinalKeys} keys!`);
      }

      let chart = "<h3>Jury Key Distribution</h3><table><tr><th>Juror</th>" + finalists.map(f => `<th>${f.name}</th>`).join("") + "</tr>";
      juryMatrix.forEach(j => {
        chart += `<tr><td>${j.juror}</td>` + finalists.map(f => `<td>${j.keys[f.name] || 0}</td>`).join("") + "</tr>";
      });
      chart += "</table>";
      document.getElementById("votingChart").innerHTML = chart;

      document.getElementById("nextBtn").innerText = "Simulate Again";
      document.getElementById("nextBtn").onclick = startGame;
      updateProgressTable();
    }
  </script>
</body>
</html>