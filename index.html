<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>The Vault Simulator</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    .log { white-space: pre-wrap; background: #f8f8f8; padding: 10px; border: 1px solid #ccc; margin: 20px 0; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
    td, th { border: 1px solid #999; padding: 5px 10px; text-align: center; }
    .highlight { font-weight: bold; color: #d42; }
    .keyholder { background-color: #ffd; font-weight: bold; }
  </style>
</head>
<body>
  <h1>The Vault Simulator</h1>
  <p>Enter 12 player names (one per line):</p>
  <textarea id="playerInput" rows="12" cols="30" placeholder="Player 1&#10;Player 2&#10;..."></textarea><br>
  <button onclick="startGame()" id="startBtn">Start Game</button>
  <button onclick="runRound()" id="nextBtn" style="display:none;">Run Next Round</button>

  <div id="log" class="log"></div>
  <div id="votingTable"></div>
  <div id="progressTable"></div>

  <script>
    let players = [];
    let phase = 1;
    let round = 1;
    let lockpickHolder = null;
    let alliances = {};
    let usedLockpicks = [];
    let jury = [];
    let eliminated = [];
    let finalists = [];
    let finaleVotes = [];
    let vaults = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22];

    function startGame() {
      const names = document.getElementById("playerInput").value.trim().split("\n").map(n => n.trim());
      if (names.length !== 12) {
        alert("Enter exactly 12 names.");
        return;
      }
      players = names.map(name => ({
        name,
        key1: false,
        key2: false,
        key3: false,
        eliminated: false,
        alliance: [],
        votes: [],
        totalKeys: 0
      }));
      createAlliances();
      document.getElementById("startBtn").style.display = "none";
      document.getElementById("nextBtn").style.display = "inline-block";
      logAlliances();
      runRound();
    }

    function logAlliances() {
      let text = "üß© Initial Alliances:\n";
      for (let i = 0; i < players.length; i++) {
        if (players[i].alliance.length > 0) {
          text += `- ${players[i].name} is in: ${players[i].alliance.join(", ")}\n`;
        }
      }
      log(text);
    }

    function createAlliances() {
      const allAllianceNames = ["The Vault Divas", "Secret Lockstars", "Key Cutters"];
      for (let name of allAllianceNames) {
        let members = shuffle(players).slice(0, Math.floor(Math.random() * 4) + 2);
        for (let member of members) {
          if (!member.alliance.includes(name)) {
            member.alliance.push(name);
          }
        }
        alliances[name] = members.map(m => m.name);
      }
    }

    function runRound() {
      clearLog();
      log(`üì¶ Phase ${phase} ‚Äî Round ${round}`);
      if (phase === 1) {
        runPhase1Round();
      } else if (phase === 2) {
        runPhase2Round();
      } else if (phase === 3) {
        runPhase3();
      } else if (phase === 4) {
        runFinale();
      }
    }

    function clearLog() {
      document.getElementById("log").innerText = "";
      document.getElementById("votingTable").innerHTML = "";
    }

    function log(text) {
      document.getElementById("log").innerText += text + "\n";
    }

    function shuffle(array) {
      return array.slice().sort(() => Math.random() - 0.5);
    }
        let phase1Rounds = 1;
    let lockpickFound = false;

    function runPhase1Round() {
      const activePlayers = players.filter(p => !p.key1);
      const drawn = shuffle(players).slice(0, 4);
      log("üé≤ Drawn: " + drawn.map(p => p.name).join(", "));

      // Lockpick chance
      if (!lockpickHolder && Math.random() < 0.33) {
        lockpickHolder = drawn[Math.floor(Math.random() * drawn.length)];
        log("üóùÔ∏è A Lockpick was found by " + lockpickHolder.name + "!");
      }

      // Vote (simulate)
      let voteTarget = drawn[Math.floor(Math.random() * drawn.length)];
      if (lockpickHolder && drawn.includes(lockpickHolder)) {
        voteTarget = lockpickHolder;
        log(`üîê ${lockpickHolder.name} uses the Lockpick and overrides the vote.`);
        lockpickHolder = null;
      } else {
        log(`üèÜ ${voteTarget.name} wins the vote key.`);
      }
      voteTarget.key1 = true;
      voteTarget.totalKeys += 1;

      // Challenge (among remaining 3)
      const challengePool = drawn.filter(p => p !== voteTarget);
      const challengeWinner = challengePool[Math.floor(Math.random() * challengePool.length)];
      challengeWinner.key1 = true;
      challengeWinner.totalKeys += 1;
      log(`üèÅ ${challengeWinner.name} wins the challenge key.`);

      // Update visual voting chart
      updateVotingTable();

      phase1Rounds++;
      if (phase1Rounds > 4) {
        log("üîö Phase 1 complete. Moving to Phase 2...");
        phase = 2;
        round = 1;
        lockpickHolder = null; // re-hide Lockpick for Phase 2
      } else {
        round++;
      }
    }

    function updateVotingTable() {
      let html = "<table><tr><th>Player</th><th>Phase 1 Key</th><th>Total Keys</th></tr>";
      for (let p of players) {
        const keyCell = p.key1 ? "‚úÖ" : "";
        html += `<tr${p.key1 ? ' class="keyholder"' : ''}><td>${p.name}</td><td>${keyCell}</td><td>${p.totalKeys}</td></tr>`;
      }
      html += "</table>";
      document.getElementById("votingTable").innerHTML = html;
    }
        function runPhase2Round() {
      const eligible = players.filter(p => !p.key2 && !p.eliminated);
      const keyholders = players.filter(p => p.key2);

      if (eligible.length <= 1) {
        log("üîö Phase 2 complete. Moving to Phase 3...");
        phase = 3;
        round = 1;
        return;
      }

      // Voting logic
      const votes = {};
      for (let voter of players.filter(p => !p.eliminated)) {
        const choices = eligible.filter(p => p.name !== voter.name);
        let voteTarget = pickAllianceTarget(voter, choices) || choices[Math.floor(Math.random() * choices.length)];
        votes[voteTarget.name] = (votes[voteTarget.name] || 0) + 1;
      }

      let voteWinnerName = Object.entries(votes).sort((a, b) => b[1] - a[1])[0][0];
      let voteWinner = eligible.find(p => p.name === voteWinnerName);

      log("üó≥Ô∏è Vote Winner: " + voteWinner.name);

      // Lockpick override
      if (lockpickHolder && !voteWinner.key2 && !voteWinner.eliminated) {
        log("üîê " + lockpickHolder.name + " uses the Lockpick to override the vote and choose the duel.");
        voteWinner = lockpickHolder;
        lockpickHolder = null;
      }

      // Duel opponent selection
      const duelOptions = eligible.filter(p => p.name !== voteWinner.name);
      let chosenOpponent = pickDuelOpponent(voteWinner, duelOptions);

      log(`‚öîÔ∏è ${voteWinner.name} selects ${chosenOpponent.name} for the duel.`);

      // Duel result
      const duelWinner = Math.random() < 0.5 ? voteWinner : chosenOpponent;
      const duelLoser = duelWinner === voteWinner ? chosenOpponent : voteWinner;

      duelWinner.key2 = true;
      duelWinner.totalKeys += 1;
      log(`üèÖ ${duelWinner.name} wins the duel and earns the Phase 2 key.`);

      // Update table
      updatePhase2Table();

      round++;
    }

    function pickAllianceTarget(voter, choices) {
      const sharedAlliances = voter.alliance;
      const allianceTargets = choices.filter(c => {
        return sharedAlliances.some(a => c.alliance.includes(a));
      });
      return allianceTargets.length ? allianceTargets[Math.floor(Math.random() * allianceTargets.length)] : null;
    }

    function pickDuelOpponent(chooser, options) {
      const allies = options.filter(p =>
        p.alliance.some(a => chooser.alliance.includes(a))
      );
      if (allies.length) return allies[Math.floor(Math.random() * allies.length)];
      return options[Math.floor(Math.random() * options.length)];
    }

    function updatePhase2Table() {
      let html = "<table><tr><th>Player</th><th>Phase 2 Key</th><th>Total Keys</th></tr>";
      for (let p of players) {
        const keyCell = p.key2 ? "‚úÖ" : "";
        html += `<tr${p.key2 ? ' class="keyholder"' : ''}><td>${p.name}</td><td>${keyCell}</td><td>${p.totalKeys}</td></tr>`;
      }
      html += "</table>";
      document.getElementById("votingTable").innerHTML = html;
    }
        function runPhase3() {
      const remaining = players.filter(p => !p.eliminated && p.key1 && p.key2);
      if (remaining.length !== 4) {
        log("‚ùå Error: Phase 3 requires exactly 4 players.");
        return;
      }

      log("üéØ Final 4: " + remaining.map(p => p.name).join(", "));

      // Voting (no self-vote)
      const votes = {};
      for (let voter of remaining) {
        const choices = remaining.filter(p => p.name !== voter.name);
        let voteTarget = pickAllianceTarget(voter, choices) || choices[Math.floor(Math.random() * choices.length)];
        votes[voteTarget.name] = (votes[voteTarget.name] || 0) + 1;
      }

      let sorted = Object.entries(votes).sort((a, b) => b[1] - a[1]);
      let [top1, top2] = sorted;

      let autoFinalist, finalist2, challengePlayers;

      if (!top2 || top1[1] > top2[1]) {
        // Clear winner
        autoFinalist = remaining.find(p => p.name === top1[0]);
        const pickable = remaining.filter(p => p !== autoFinalist);
        finalist2 = pickable[Math.floor(Math.random() * pickable.length)];
        challengePlayers = pickable.filter(p => p !== finalist2);
        log(`üèÜ ${autoFinalist.name} wins the vote and brings ${finalist2.name} to the finale.`);
      } else {
        // Tie ‚Äî untied go through
        const tied = [top1[0], top2[0]];
        challengePlayers = remaining.filter(p => tied.includes(p.name));
        const advanced = remaining.filter(p => !tied.includes(p.name));
        autoFinalist = advanced[0];
        finalist2 = advanced[1];
        log(`ü§ù Vote tied between ${tied.join(" & ")}. The untied (${autoFinalist.name}, ${finalist2.name}) advance.`);
      }

      // Challenge
      const challengeWinner = challengePlayers[Math.floor(Math.random() * challengePlayers.length)];
      log(`üèÅ ${challengePlayers.map(p => p.name).join(" vs ")} ‚Äî ${challengeWinner.name} wins the challenge.`);

      finalists = [autoFinalist, finalist2, challengeWinner];
      players.forEach(p => {
        if (!finalists.includes(p)) {
          p.eliminated = true;
          jury.push(p);
        }
      });

      log("üéâ Finalists: " + finalists.map(f => f.name).join(", "));
      phase = 4;
      round = 1;
    }
        function runFinale() {
      log("üîí The Vault Finale begins!");

      // Step 1: Finalists choose vaults (based on estimated key count)
      for (let f of finalists) {
        let base = 3;
        let estimate = base;

        if (f.totalKeys >= 2) estimate += 3;
        if (f.totalKeys === 3) estimate += 2;
        const safeRange = vaults.filter(v => v <= estimate + 2 && v >= estimate - 1);
        f.vault = safeRange[Math.floor(Math.random() * safeRange.length)] || vaults[0];
        log(`üîê ${f.name} selects vault: ${f.vault} keys.`);
      }

      // Step 2: Jury distributes keys
      for (let j of jury) {
        let keysToGive = j.key1 && !j.key2 ? 1 : j.key2 && !j.key1 ? 2 : 1;
        if (!j.key1 && !j.key2) keysToGive = 1;
        if (j.eliminated && !j.key3) keysToGive = 2;
        if (j.eliminated && j.key3) keysToGive = 4;

        let target;
        if (j.alliance.length && Math.random() < 0.6) {
          const allies = finalists.filter(f => f.alliance.some(a => j.alliance.includes(a)));
          if (allies.length) target = allies[Math.floor(Math.random() * allies.length)];
        }
        if (!target) {
          target = finalists[Math.floor(Math.random() * finalists.length)];
        }
        target.bonusKeys = (target.bonusKeys || 0) + keysToGive;
        log(`üéÅ ${j.name} gives ${keysToGive} keys to ${target.name}`);
      }

      // Step 3: Count total keys
      for (let f of finalists) {
        f.totalFinalKeys = 3 + (f.bonusKeys || 0);
        log(`üîë ${f.name} ends with ${f.totalFinalKeys} keys (needs ${f.vault})`);
      }

      // Step 4: Check vaults
      const successful = finalists.filter(f => f.totalFinalKeys >= f.vault);
      if (successful.length) {
        const highest = successful.sort((a, b) => b.vault - a.vault)[0];
        log(`üëë ${highest.name} unlocks the highest vault (${highest.vault}) and wins!`);
      } else {
        const fallback = players.find(p => !p.eliminated && !finalists.includes(p));
        log(`üí• No vaults unlocked. By default, ${fallback?.name || finalists[0].name} wins.`);
      }

      // Final summary
      showProgressSummary();
    }

    function showProgressSummary() {
      let html = "<h2>üìä Final Game Summary</h2><table><tr><th>Player</th><th>Phase 1</th><th>Phase 2</th><th>Phase 3</th><th>Vault</th><th>Total</th></tr>";
      const sorted = [...players].sort((a, b) => b.totalKeys - a.totalKeys);
      for (let p of sorted) {
        html += `<tr>
          <td>${p.name}</td>
          <td>${p.key1 ? "‚úÖ" : ""}</td>
          <td>${p.key2 ? "‚úÖ" : ""}</td>
          <td>${p.key3 ? "‚úÖ" : ""}</td>
          <td>${p.vault || ""}</td>
          <td>${p.totalFinalKeys || p.totalKeys}</td>
        </tr>`;
      }
      html += "</table>";
      document.getElementById("progressTable").innerHTML = html;
    }
  </script>
</body>
</html>