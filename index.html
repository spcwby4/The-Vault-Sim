<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>The Vault Simulator</title>
  <style>
    body { font-family: Arial, sans-serif; display: flex; padding: 0; margin: 0; }
    #main { flex: 3; padding: 20px; }
    #sidebar { flex: 1; background: #f4f4f4; padding: 20px; max-width: 300px; overflow-y: auto; }
    textarea { width: 100%; height: 150px; margin-top: 10px; }
    button { margin: 5px 0; }
    .hidden { display: none; }
    .matrix-table { border-collapse: collapse; margin-top: 10px; width: 100%; }
    .matrix-table th, .matrix-table td { border: 1px solid #ccc; padding: 5px; font-size: 12px; text-align: center; }
    .collapsible { background-color: #eee; cursor: pointer; padding: 10px; width: 100%; text-align: left; border: none; outline: none; }
    .active, .collapsible:hover { background-color: #ccc; }
    .content { padding: 0 10px; display: none; overflow: hidden; }
    .finalist { font-weight: bold; }
    .eliminated { color: gray; }
    .keyholder { background: #d4edda; }
  </style>
</head>
<body>
  <div id="main">
    <h1>The Vault Simulator</h1>
    <div>
      <textarea id="playersInput" placeholder="Enter 12 player names, one per line..."></textarea>
      <button onclick="startGame()">Start Game</button>
      <button id="nextRoundBtn" class="hidden" onclick="runNextRound()">Next Round</button>
    </div>
    <div id="eventLog"></div>
    <div id="votingMatrix"></div>
    <div id="finalChart" class="hidden"></div>
  </div>
  <div id="sidebar">
    <h3>Alliances</h3>
    <div id="alliancesBox"></div>
  </div>
  <script>
    let players = [], phase = 1, round = 1, alliances = [], logs = [], votingMatrix = [],
      usedLockpicks = [], currentLockpickHolder = null, vaults = [3, 5, 7, 9, 11, 14, 17, 20, 22],
      jury = [], juryKeys = {}, lockpickHidden = true, lockpickLocation = null;

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function log(text) {
      logs = [text];
      document.getElementById("eventLog").innerHTML = "<p>" + logs.join("</p><p>") + "</p>";
    }

    function showMatrix(title, matrix) {
      let html = `<button class="collapsible">${title}</button><div class="content"><table class="matrix-table"><tr><th>Voter</th>`;
      if (matrix.length === 0) {
        document.getElementById("votingMatrix").innerHTML = "";
        return;
      }
      matrix[0].votes.forEach(v => html += `<th>${v.target}</th>`);
      html += "</tr>";
      matrix.forEach(row => {
        html += `<tr><td>${row.voter}</td>`;
        row.votes.forEach(v => html += `<td>${v.count || ''}</td>`);
        html += "</tr>";
      });
      html += "</table></div>`;
      document.getElementById("votingMatrix").innerHTML = html;
      addCollapsibles();
    }

    function addCollapsibles() {
      const coll = document.getElementsByClassName("collapsible");
      for (let i = 0; i < coll.length; i++) {
        coll[i].onclick = function () {
          this.classList.toggle("active");
          const content = this.nextElementSibling;
          if (content.style.display === "block") {
            content.style.display = "none";
          } else {
            content.style.display = "block";
          }
        };
      }
    }

    function updateProgressChart() {
      const chart = players.map(p => {
        let name = p.name;
        if (p.eliminated) name = `<span class="eliminated">${name}</span>`;
        if (p.finalist) name = `<span class="finalist">${name}</span>`;
        let vault = p.vault || '';
        return `<tr><td>${name}</td><td>${p.keys || 0}</td><td>${vault}</td><td>${p.finalPlace || ''}</td></tr>`;
      }).join("");
      document.getElementById("finalChart").innerHTML = `<h3>Final Progress</h3><table class="matrix-table"><tr><th>Player</th><th>Keys</th><th>Vault</th><th>Placement</th></tr>${chart}</table>`;
    }

    function updateAlliances() {
      let output = "";
      alliances.forEach((a, i) => {
        output += `<strong>Alliance ${i + 1}</strong>: ${a.members.map(m => m.name).join(", ")}<br>`;
      });
      document.getElementById("alliancesBox").innerHTML = output;
    }

    function assignAlliances() {
      alliances = [];
      const shuffled = shuffle([...players]);
      for (let i = 0; i < 3; i++) {
        const members = shuffled.slice(i * 4, i * 4 + 4);
        alliances.push({ members });
      }
      updateAlliances();
    }

    function startGame() {
      const input = document.getElementById("playersInput").value.trim().split("\n").map(x => x.trim()).filter(Boolean);
      if (input.length !== 12) {
        alert("Please enter exactly 12 names.");
        return;
      }
      players = input.map(name => ({
        name,
        keys: 0,
        eliminated: false,
        finalist: false
      }));
      assignAlliances();
      phase = 1;
      round = 1;
      logs = [];
      document.getElementById("playersInput").style.display = "none";
      document.getElementById("nextRoundBtn").classList.remove("hidden");
      document.getElementById("finalChart").classList.add("hidden");
      runNextRound();
    }
    function runNextRound() {
  log(`Running Phase ${phase}, Round ${round}...`);
  let currentPlayers = players.filter(p => !p.eliminated);
  if (phase === 1) {
    const eligible = currentPlayers.filter(p => !p.keys);
    const gobletDraw = shuffle(eligible).slice(0, 4);
    let voters = currentPlayers;
    let votingResults = gobletDraw.map(p => ({ target: p.name, count: 0 }));
    let matrix = [];

    // Lockpick chance
    if (lockpickHidden && Math.random() < 0.33) {
      const finder = gobletDraw[Math.floor(Math.random() * gobletDraw.length)];
      currentLockpickHolder = finder.name;
      lockpickHidden = false;
      log(`${finder.name} discovered the Lockpick!`);
    }

    // Lockpick usage
    let lockpickUsed = false;
    if (currentLockpickHolder && gobletDraw.some(p => p.name === currentLockpickHolder)) {
      lockpickUsed = true;
      let pickTarget = gobletDraw.find(p => p.name === currentLockpickHolder);
      pickTarget.keys++;
      log(`${pickTarget.name} used the Lockpick to win the vote key!`);
      currentLockpickHolder = null;
    } else {
      // Vote normally
      voters.forEach(voter => {
        const votee = shuffle(gobletDraw)[0];
        const voteEntry = votingResults.find(v => v.target === votee.name);
        if (voteEntry) voteEntry.count++;
        matrix.push({ voter: voter.name, votes: gobletDraw.map(p => ({ target: p.name, count: p.name === votee.name ? 1 : '' })) });
      });

      const voteWinner = votingResults.reduce((a, b) => (a.count > b.count ? a : b));
      const winnerObj = currentPlayers.find(p => p.name === voteWinner.target);
      winnerObj.keys++;
      log(`${voteWinner.target} won the vote and earned a key!`);
    }

    // Challenge for second key
    const challengers = gobletDraw.filter(p => p.keys === 0);
    if (challengers.length > 0) {
      const challengeWinner = shuffle(challengers)[0];
      challengeWinner.keys++;
      log(`${challengeWinner.name} won the challenge and earned a key!`);
    }

    showMatrix(`Phase 1 – Round ${round} Voting`, matrix);

    // Phase 1 ends after 4 rounds
     if (round === 4) {
      const eliminated = currentPlayers.filter(p => p.keys === 0);
      eliminated.forEach(p => {
        p.eliminated = true;
        jury.push(p);
        juryKeys[p.name] = 1;
      });
      log(`Phase 1 complete. Eliminated: ${eliminated.map(p => p.name).join(", ")}`);
      phase = 2;
      round = 1;
    } else {
      round++;
    }

    updateAlliances();
    updateProgressChart();
  }

  else if (phase === 2) {
    let noKeyPlayers = currentPlayers.filter(p => p.keys < 2);
    let matrix = [];
    let voteCounts = noKeyPlayers.map(p => ({ target: p.name, count: 0 }));
    let voters = currentPlayers;

    // Lockpick use in Phase 2
    let voteWinnerName;
    if (!lockpickHidden && currentLockpickHolder) {
      voteWinnerName = currentLockpickHolder;
      currentLockpickHolder = null;
      lockpickHidden = true;
      log(`${voteWinnerName} used the Lockpick to win the Phase 2 vote!`);
    } else {
      // Normal vote
      voters.forEach(voter => {
        const choices = noKeyPlayers.filter(p => p.name !== voter.name);
        const votee = shuffle(choices)[0];
        const entry = voteCounts.find(v => v.target === votee.name);
        if (entry) entry.count++;
        matrix.push({ voter: voter.name, votes: noKeyPlayers.map(p => ({ target: p.name, count: p.name === votee.name ? 1 : '' })) });
      });

      const topVotes = Math.max(...voteCounts.map(v => v.count));
      const tied = voteCounts.filter(v => v.count === topVotes);
      if (tied.length > 1) {
        log(`Vote tie between ${tied.map(t => t.target).join(" & ")}. They will face off in the duel.`);
        let [p1, p2] = tied.map(t => currentPlayers.find(p => p.name === t.target));
        const winner = shuffle([p1, p2])[0];
        winner.keys++;
        log(`${winner.name} wins the duel and earns a key!`);
      } else {
        voteWinnerName = voteCounts.find(v => v.count === topVotes).target;
        const voteWinner = currentPlayers.find(p => p.name === voteWinnerName);
        const duelChoices = noKeyPlayers.filter(p => p.name !== voteWinner.name);
        const opponent = shuffle(duelChoices)[0];
        const duelWinner = shuffle([voteWinner, opponent])[0];
        duelWinner.keys++;
        log(`${voteWinner.name} faced off against ${opponent.name}. ${duelWinner.name} wins and earns a key!`);
      }
    }

    showMatrix(`Phase 2 – Round ${round} Voting`, matrix);

    // Phase 2 ends after 4 rounds
    if (round === 4) {
      const eliminated = currentPlayers.filter(p => p.keys < 2);
      eliminated.forEach(p => {
        p.eliminated = true;
        jury.push(p);
        juryKeys[p.name] = 2;
      });
      log(`Phase 2 complete. Eliminated: ${eliminated.map(p => p.name).join(", ")}`);
      phase = 3;
      round = 1;
    } else {
      round++;
    }
  }
    else if (phase === 3) {
    if (round === 1) {
      let matrix = [];
      const finalists = currentPlayers;
      const voteCounts = finalists.map(p => ({ target: p.name, count: 0 }));

      // Vote (can't vote for self)
      finalists.forEach(voter => {
        const choices = finalists.filter(p => p.name !== voter.name);
        const votee = shuffle(choices)[0];
        const voteEntry = voteCounts.find(v => v.target === votee.name);
        if (voteEntry) voteEntry.count++;
        matrix.push({ voter: voter.name, votes: finalists.map(p => ({ target: p.name, count: p.name === votee.name ? 1 : '' })) });
      });

      const topVotes = Math.max(...voteCounts.map(v => v.count));
      const tied = voteCounts.filter(v => v.count === topVotes);
      if (tied.length === 2) {
        // Tie between 2, others move on
        const movingOn = finalists.filter(p => !tied.some(t => t.target === p.name));
        movingOn.forEach(p => {
          p.finalist = true;
          p.keys++;
        });
        duelFinalists = tied.map(t => currentPlayers.find(p => p.name === t.target));
        log(`Vote tie: ${tied.map(t => t.target).join(" & ")} must duel. ${movingOn.map(p => p.name).join(", ")} advance.`);
      } else {
        const voteWinner = voteCounts.find(v => v.count === topVotes).target;
        const voteWinnerObj = currentPlayers.find(p => p.name === voteWinner);
        voteWinnerObj.finalist = true;
        voteWinnerObj.keys++;
        const others = finalists.filter(p => p.name !== voteWinner);
        const chosen = shuffle(others)[0];
        chosen.finalist = true;
        chosen.keys++;
        duelFinalists = others.filter(p => p.name !== chosen.name);
        log(`${voteWinner} won the vote and chose ${chosen.name} to join them. ${duelFinalists.map(p => p.name).join(" & ")} will duel.`);
      }

      showMatrix(`Phase 3 – Final Vote`, matrix);
      round = 2; // trigger duel in next round
    } else if (round === 2) {
      const duelWinner = shuffle(duelFinalists)[0];
      duelWinner.finalist = true;
      duelWinner.keys++;
      const loser = duelFinalists.find(p => p !== duelWinner);
      loser.eliminated = true;
      jury.push(loser);
      juryKeys[loser.name] = 4;
      log(`${duelFinalists.map(p => p.name).join(" & ")} competed in the final duel. ${duelWinner.name} advances. ${loser.name} is eliminated.`);
      phase = 4;
    }
  }
    else if (phase === 4) {
    const finalists = currentPlayers.filter(p => p.finalist);
    const vaultOptions = [3, 5, 7, 9, 11, 13, 15, 17, 19, 22];
    shuffle(vaultOptions);

    // Finalists choose vaults based on estimated support
    finalists.forEach((p, i) => {
      const estimate = 3 + Math.floor(Math.random() * 7); // expect 3–9 keys
      p.vault = vaultOptions.find(v => v >= estimate + 3 + i * 2) || vaultOptions[0];
    });

    // Jury key distribution
    let totalDistributed = 0;
    jury.forEach(juror => {
      const keysToGive = juryKeys[juror.name];
      totalDistributed += keysToGive;
      const allocation = [];
      let remaining = keysToGive;

      while (remaining > 0) {
        const giveTo = shuffle(finalists)[0];
        const amt = Math.min(remaining, 1 + Math.floor(Math.random() * remaining));
        allocation.push({ target: giveTo.name, count: amt });
        giveTo.keys += amt;
        remaining -= amt;
      }

      juryMatrix.push({ juror: juror.name, allocations: allocation });
    });

    log(`Vault Finale: ${finalists.map(f => `${f.name} chose a ${f.vault}-key vault`).join(", ")}`);
    finalists.forEach(f => log(`${f.name} has ${f.keys} keys`));

    let opener = finalists.filter(f => f.keys >= f.vault);
    if (opener.length > 0) {
      const winner = opener.reduce((a, b) => (a.vault > b.vault ? a : b));
      log(`🏆 ${winner.name} opens the ${winner.vault}-key vault and wins The Vault!`);
    } else {
      const fourthPlace = jury.find(j => juryKeys[j.name] === 4);
      log(`😱 No vaults opened. ${fourthPlace.name} wins as 4th place juror!`);
    }

    showFinalProgress();
    showJuryMatrix();
    document.getElementById("nextRoundBtn").textContent = "Simulate Again";
    document.getElementById("nextRoundBtn").onclick = () => location.reload();
  }
}