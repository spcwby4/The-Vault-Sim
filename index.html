<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Vault Simulator</title>
  <style>
    body { font-family: sans-serif; display: flex; flex-direction: row; padding: 20px; gap: 20px; }
    #left { flex: 3; }
    #right { flex: 1; }
    .hidden { display: none; }
    table { border-collapse: collapse; margin-top: 10px; }
    th, td { border: 1px solid #999; padding: 4px 8px; text-align: center; }
    .key { background-color: gold; font-weight: bold; }
    details { margin-top: 10px; }
  </style>
</head>
<body>
  <div id="left">
    <h1>The Vault Simulator</h1>
    <textarea id="playerInput" rows="12" cols="30" placeholder="Enter 12 player names, one per line"></textarea><br>
    <button onclick="startGame()">Start Game</button>
    <button id="nextBtn" class="hidden" onclick="runNextRound()">Next Round</button>
    <div id="eventLog"></div>
    <div id="voteMatrix"></div>
    <div id="votingChart"></div>
  </div>
  <div id="right">
    <h3>Alliances</h3>
    <select id="allianceDropdown" size="10" style="width: 100%;"></select>
    <h3>Progress</h3>
    <div id="progressTable"></div>
  </div>

  <script>
    let players = [], alliances = [], eliminated = [], finalists = [], juryMatrix = [];
    let round = 1, phase = 1, phase3Step = 0, lockpickHolder = null, lockpickUsed = false, phase3Duel = [];

    function startGame() {
      const input = document.getElementById("playerInput").value.trim().split("\n").filter(x => x);
      if (input.length !== 12) return alert("Please enter exactly 12 player names.");
      players = input.map(name => ({ name, key1: false, key2: false, key3: false, eliminated: false, totalFinalKeys: 0 }));
      eliminated = []; finalists = []; juryMatrix = [];
      round = 1; phase = 1; phase3Step = 0; lockpickHolder = null; lockpickUsed = false;
      generateAlliances();
      updateProgressTable();
      log(`Game started with players: ${players.map(p => p.name).join(", ")}`);
      document.getElementById("nextBtn").classList.remove("hidden");
    }

    function generateAlliances() {
      alliances = [];
      const shuffled = [...players]; shuffle(shuffled);
      for (let i = 0; i < 3; i++) {
        const group = shuffled.slice(i * 4, i * 4 + 4).map(p => p.name);
        alliances.push({ name: `Alliance ${i + 1}`, members: group });
      }
      updateAllianceDropdown();
    }

    function updateAllianceDropdown() {
      const dropdown = document.getElementById("allianceDropdown");
      dropdown.innerHTML = "";
      alliances.forEach(a => {
        const option = document.createElement("option");
        option.text = `${a.name}: ${a.members.join(", ")}`;
        dropdown.add(option);
      });
    }

    function getActivePlayers() {
      return players.filter(p => !p.eliminated);
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function log(html) {
      document.getElementById("eventLog").innerHTML = `<p>${html}</p>`;
    }

    function createVotingMatrix(title, votes) {
      const div = document.getElementById("voteMatrix");
      div.innerHTML = `<details open><summary>${title} Voting Matrix</summary><table><tr><th>Voter</th><th>Voted</th></tr>${
        votes.map(v => `<tr><td>${v.voter}</td><td>${v.voted}</td></tr>`).join("")
      }</table></details>`;
    }

    function updateProgressTable() {
      const div = document.getElementById("progressTable");
      const rows = players.map(p => {
        let status = p.eliminated ? "‚ùå" : "‚úÖ";
        const k1 = p.key1 ? "üîë" : "";
        const k2 = p.key2 ? "üîë" : "";
        const k3 = p.key3 ? "üîë" : "";
        return `<tr><td>${p.name}</td><td>${status}</td><td>${k1}</td><td>${k2}</td><td>${k3}</td></tr>`;
      });
      div.innerHTML = `<table><tr><th>Name</th><th>Active</th><th>Phase 1</th><th>Phase 2</th><th>Phase 3</th></tr>${rows.join("")}</table>`;
    }

    function runNextRound() {
      if (phase === 1) runPhase1();
      else if (phase === 2) runPhase2();
      else if (phase === 3) runPhase3();
      else if (phase === 4) runFinale();
    }

    // PHASE 1 ‚Äì KEY QUEST
function runPhase1() {
  const active = getActivePlayers();
  const eligible = active.filter(p => !p.key1);
  if (round > 4 || eligible.length === 0) {
    players.filter(p => !p.key1).forEach(p => { p.eliminated = true; eliminated.push(p); });
    round = 1; phase = 2;
    log("Phase 1 complete. Moving to Phase 2.");
    updateProgressTable();
    return;
  }
  let roundDraw = (round < 4) ? randomPick(eligible, 4) : eligible.map(p => p.name);
  let roundPlayers = players.filter(p => roundDraw.includes(p.name));
  const voters = players.map(p => p.name);
  const voteResults = simulateVotes(voters, roundDraw);
  const voteWinner = voteResults.winner;
  let lockpickUsedThisRound = false;

  if (lockpickHolder && roundPlayers.some(p => p.name === lockpickHolder)) {
    if (!players.find(p => p.name === lockpickHolder).key1) {
      voteResults.override = lockpickHolder;
      voteResults.winner = lockpickHolder;
      lockpickUsed = true;
      lockpickUsedThisRound = true;
    }
  }

  const challengeWinner = roundPlayers.find(p => p.name !== voteResults.winner);
  players.find(p => p.name === voteResults.winner).key1 = true;
  challengeWinner && (challengeWinner.key1 = true);
  updateProgressTable();
  createVotingMatrix(`Phase 1 ‚Äì Round ${round}`, voteResults.votes);
  log(`Drawn: ${roundDraw.join(", ")}<br>Voted Key: ${voteResults.winner}${lockpickUsedThisRound ? " (Lockpick)" : ""}<br>Challenge Key: ${challengeWinner?.name || "N/A"}`);
  round++;
}

// PHASE 2 ‚Äì KEY DUEL
function runPhase2() {
  const active = getActivePlayers();
  const noKey = active.filter(p => !p.key2);
  if (round > 4 || noKey.length === 0) {
    players.filter(p => !p.key2).forEach(p => { p.eliminated = true; eliminated.push(p); });
    round = 1; phase = 3;
    log("Phase 2 complete. Moving to Phase 3.");
    updateProgressTable();
    return;
  }
  const voters = active.map(p => p.name);
  const voteTargets = noKey.map(p => p.name);
  const voteResults = simulateVotes(voters, voteTargets);
  let [tied, max] = tallyVotes(voteResults.votes);
  let voteWinner = (tied.length === 1) ? tied[0] : null;
  let lockpickUsedThisRound = false;

  if (lockpickHolder && voteTargets.includes(lockpickHolder) && !lockpickUsed) {
    voteResults.override = lockpickHolder;
    voteWinner = lockpickHolder;
    lockpickUsed = true;
    lockpickUsedThisRound = true;
  }

  let duelists;
  if (!voteWinner) {
    duelists = tied;
    log(`Tie! Duel between ${duelists.join(" and ")}`);
  } else {
    const opponent = voteTargets.find(n => n !== voteWinner);
    duelists = [voteWinner, opponent || voteWinner];
  }

  const winner = duelists[Math.floor(Math.random() * duelists.length)];
  players.find(p => p.name === winner).key2 = true;
  updateProgressTable();
  createVotingMatrix(`Phase 2 ‚Äì Round ${round}`, voteResults.votes);
  log(`Vote ${round}: ${voteResults.override ? "Lockpick used" : voteWinner || "TIE"}<br>Duelists: ${duelists.join(" vs ")}<br>Key Winner: ${winner}`);
  round++;
}

// PHASE 3 ‚Äì FINAL CUT
function runPhase3() {
  const active = getActivePlayers();
  if (phase3Step === 0) {
    const voteResults = simulateVotes(active.map(p => p.name), active.map(p => p.name), true);
    let [tied, max] = tallyVotes(voteResults.votes);
    if (tied.length === 1) {
      const winner = tied[0];
      const winnerObj = players.find(p => p.name === winner);
      winnerObj.key3 = true;
      const other = active.find(p => p.name !== winner);
      const pick = active.find(p => p.name !== winner && p.name !== other.name);
      finalists.push(winner, pick.name);
      phase3Duel = active.filter(p => !finalists.includes(p.name)).map(p => p.name);
      log(`Phase 3 Vote Winner: ${winner} ‚Üí chose: ${pick.name}`);
    } else {
      finalists = active.filter(p => !tied.includes(p.name)).map(p => p.name);
      phase3Duel = tied;
      log(`Phase 3 Tied Vote! ${tied.join(" vs ")} must compete. Others advance.`);
    }
    updateProgressTable();
    createVotingMatrix(`Phase 3 Vote`, voteResults.votes);
    phase3Step = 1;
  } else {
    const winner = phase3Duel[Math.floor(Math.random() * phase3Duel.length)];
    finalists.push(winner);
    players.find(p => p.name === winner).key3 = true;
    players.forEach(p => {
      if (!finalists.includes(p.name) && !p.eliminated) {
        p.eliminated = true;
        eliminated.push(p);
      }
    });
    round = 1; phase = 4;
    log(`Final Duel Winner: ${winner} ‚Üí Finalists: ${finalists.join(", ")}`);
    updateProgressTable();
  }
}

// FINALE ‚Äì THE VAULT
function runFinale() {
  finalists.forEach(name => {
    const p = players.find(pl => pl.name === name);
    p.totalFinalKeys = (p.key1 + p.key2 + p.key3);
  });

  let remainingKeys = 16;
  juryMatrix = eliminated.map(juror => {
    let keysToGive = juror.key3 ? 4 : juror.key2 ? 2 : 1;
    if (remainingKeys < keysToGive) keysToGive = remainingKeys;
    remainingKeys -= keysToGive;

    const dist = {};
    while (keysToGive > 0) {
      const recipient = finalists[Math.floor(Math.random() * finalists.length)];
      dist[recipient] = (dist[recipient] || 0) + 1;
      keysToGive--;
    }
    Object.entries(dist).forEach(([name, count]) => {
      const p = players.find(pl => pl.name === name);
      p.totalFinalKeys += count;
    });
    return { juror: juror.name, keys: dist };
  });

  let resultTable = `<h3>Jury Key Distribution</h3><table><tr><th>Juror</th><th>Distribution</th></tr>`;
  juryMatrix.forEach(entry => {
    const keys = Object.entries(entry.keys).map(([name, count]) => `${name}: ${count}`).join(", ");
    resultTable += `<tr><td>${entry.juror}</td><td>${keys}</td></tr>`;
  });
  resultTable += `</table>`;

  const vaults = [3, 7, 11, 15, 22];
  let unlocked = finalists.map(p => {
    const keys = players.find(pl => pl.name === p).totalFinalKeys;
    const vault = vaults.reverse().find(v => keys >= v);
    return { name: p, vault, keys };
  });

  const winner = unlocked.reduce((a, b) => (a.vault > b.vault ? a : b));
  log(`Finalists: ${unlocked.map(u => `${u.name} (${u.keys} keys, opened ${u.vault}-key vault)`).join("<br>")}<br><b>üèÜ Winner: ${winner.name}</b>`);
  document.getElementById("nextBtn").innerText = "Simulate Again";
  document.getElementById("nextBtn").onclick = () => location.reload();
  document.getElementById("votingChart").innerHTML = resultTable;
}

// Helpers
function randomPick(arr, n) {
  const copy = [...arr];
  shuffle(copy);
  return copy.slice(0, n);
}

function simulateVotes(voters, targets, noSelfVote = false) {
  const votes = voters.map(voter => {
    const options = targets.filter(t => !(noSelfVote && t === voter));
    const vote = options[Math.floor(Math.random() * options.length)];
    return { voter, voted: vote };
  });
  const tally = {};
  votes.forEach(v => tally[v.voted] = (tally[v.voted] || 0) + 1);
  const max = Math.max(...Object.values(tally));
  const tied = Object.keys(tally).filter(k => tally[k] === max);
  return { votes, winner: tied[0], tied, override: null };
}

function tallyVotes(votes) {
  const counts = {};
  votes.forEach(v => counts[v.voted] = (counts[v.voted] || 0) + 1);
  const max = Math.max(...Object.values(counts));
  const tied = Object.keys(counts).filter(p => counts[p] === max);
  return [tied, max];
}
  </script>
</body>
</html>
