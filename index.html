<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>The Vault Simulator</title>
  <style>
    body { font-family: Arial; background: #f2f2f2; padding: 20px; }
    h1 { text-align: center; }
    textarea, button { width: 100%; padding: 10px; margin-top: 10px; font-size: 16px; }
    .box { background: white; padding: 15px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
    pre { background: #eee; padding: 10px; border-radius: 5px; height: 200px; overflow-y: scroll; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    .collapsible { background-color: #eee; cursor: pointer; padding: 10px; width: 100%; text-align: left; border: none; outline: none; font-size: 16px; margin-top: 5px; }
    .collapsible.active, .collapsible:hover { background-color: #ccc; }
    .content { display: none; overflow: hidden; padding: 0 10px 10px; }
  </style>
</head>
<body>

  <h1>The Vault Simulator</h1>

  <div class="box">
    <label for="playerInput"><strong>Enter 12 Players (one per line):</strong></label>
    <textarea id="playerInput" rows="12" placeholder="Player 1&#10;Player 2&#10;..."></textarea>
    <button onclick="startGame()">Start Game</button>
  </div>

  <div class="box" id="alliancesBox">
    <h2>Alliances</h2>
    <div id="alliancesList"></div>
  </div>

  <div class="box">
    <h2>Round Events</h2>
    <pre id="roundEvents"></pre>
  </div>

  <div class="box">
    <h2>Progress Chart</h2>
    <div id="progressChart"></div>
  </div>

  <div class="box">
    <h2>Voting Matrix</h2>
    <div id="votingMatrix"></div>
  </div>

  <div class="box">
    <h2>Jury Key Distribution</h2>
    <div id="juryMatrix"></div>
  </div>

  <script>
<script>
let players = [];
let phase = 1;
let round = 1;
let alliances = {};
let keys = {};
let votes = [];
let jury = [];
let finalists = [];
let eliminated = [];
let lockpickHolder = null;
let lockpickUsed = false;
let lockpickFound = false;
let currentDraw = [];
let votingMatrix = [];
let juryMatrix = {};
let vaults = [3, 7, 9, 11, 13, 15, 17, 19, 22];

function startGame() {
  const input = document.getElementById("playerInput").value.trim().split("\n");
  if (input.length !== 12) return alert("Enter exactly 12 players.");
  players = input.map(p => p.trim());
  players.forEach(p => keys[p] = []);
  generateAlliances();
  updateAlliances();
  log(`Phase 1: Key Quest begins!`);
  nextRound();
}

function nextRound() {
  if (phase === 1) phase1();
  else if (phase === 2) phase2();
  else if (phase === 3) phase3();
  else if (phase === 4) finale();
}

function phase1() {
  if (Object.values(keys).filter(k => k.includes("P1")).length >= 8 || round > 4) {
    endPhase1();
    return;
  }

  log(`Round ${round} — Drawing 4 players...`);
  currentDraw = players.filter(p => !keys[p].includes("P1"));
  currentDraw = shuffle(currentDraw).slice(0, 4);
  log(`Selected: ${currentDraw.join(", ")}`);

  let found = Math.random() < 0.33;
  if (!lockpickFound && found) {
    lockpickHolder = currentDraw[Math.floor(Math.random() * currentDraw.length)];
    lockpickFound = true;
    log(`${lockpickHolder} found the Lockpick!`);
  }

  let vote = simulateVote(players, currentDraw);
  displayVotingMatrix(vote);
  let [winner] = getWinnersFromVote(vote, currentDraw);
  if (lockpickHolder && !lockpickUsed && currentDraw.includes(lockpickHolder)) {
    winner = lockpickHolder;
    lockpickUsed = true;
    log(`${lockpickHolder} used the Lockpick to win the vote key!`);
  } else {
    log(`${winner} wins the vote key!`);
  }
  keys[winner].push("P1");

  let eligible = currentDraw.filter(p => p !== winner && !keys[p].includes("P1"));
  if (eligible.length > 0) {
    let challengeWinner = eligible[Math.floor(Math.random() * eligible.length)];
    keys[challengeWinner].push("P1");
    log(`${challengeWinner} wins the challenge key!`);
  }

  updateProgress();
  round++;
}

function endPhase1() {
  phase = 2;
  round = 1;
  let survivors = players.filter(p => keys[p].includes("P1"));
  eliminated = players.filter(p => !survivors.includes(p));
  eliminated.forEach(j => jury.push({ name: j, phase: 1 }));
  players = survivors;
  log(`Phase 1 complete. Eliminated: ${eliminated.join(", ")}`);
  nextRound();
}

function phase2() {
  if (round > 4 || Object.values(keys).filter(k => k.includes("P2")).length >= 4) {
    endPhase2();
    return;
  }

  log(`Phase 2 - Round ${round}`);
  let noKey = players.filter(p => !keys[p].includes("P2"));
  let vote = simulateVote(players, noKey);
  displayVotingMatrix(vote);

  let [winner, tied] = getWinnersFromVote(vote, noKey);
  if (lockpickHolder && !lockpickUsed) {
    winner = lockpickHolder;
    lockpickUsed = true;
    log(`${lockpickHolder} used the Lockpick to override the vote and choose their duel!`);
  }

  let opponent = noKey.filter(p => p !== winner)[Math.floor(Math.random() * (noKey.length - 1))];
  log(`${winner} faces ${opponent} in the duel.`);
  let duelWinner = Math.random() < 0.5 ? winner : opponent;
  keys[duelWinner].push("P2");
  log(`${duelWinner} wins the duel and earns a key!`);
  updateProgress();
  round++;
}

function endPhase2() {
  phase = 3;
  round = 1;
  let survivors = players.filter(p => keys[p].includes("P2"));
  eliminated = players.filter(p => !survivors.includes(p));
  eliminated.forEach(j => jury.push({ name: j, phase: 2 }));
  players = survivors;
  log(`Phase 2 complete. Eliminated: ${eliminated.join(", ")}`);
  nextRound();
}

function phase3() {
  log(`Phase 3: Final Cut`);
  let vote = simulateVote(players, players);
  displayVotingMatrix(vote);
  let [winner, tied] = getWinnersFromVote(vote, players);
  log(`${winner} wins the vote and becomes a finalist.`);
  let pick = players.filter(p => p !== winner)[0];
  finalists = [winner, pick];
  let remaining = players.filter(p => !finalists.includes(p));
  let duelWinner = Math.random() < 0.5 ? remaining[0] : remaining[1];
  finalists.push(duelWinner);
  let fourth = remaining.find(p => p !== duelWinner);
  jury.push({ name: fourth, phase: 3 });
  phase = 4;
  updateProgress();
  nextRound();
}

function finale() {
  log(`Vault Finale begins!`);
  let vaultChoices = shuffle(vaults).slice(0, 3);
  let finalistKeys = {};
  finalists.forEach(p => finalistKeys[p] = 3);

  jury.forEach(j => {
    let keysToGive = j.phase === 1 ? 1 : j.phase === 2 ? 2 : 4;
    let choices = shuffle(finalists).slice(0, Math.min(keysToGive, finalists.length));
    juryMatrix[j.name] = {};
    finalists.forEach(f => juryMatrix[j.name][f] = 0);
    for (let i = 0; i < keysToGive; i++) {
      let pick = choices[i % choices.length];
      juryMatrix[j.name][pick]++;
      finalistKeys[pick]++;
    }
  });

  displayJuryMatrix(juryMatrix);
  let results = finalists.map((f, i) => ({
    name: f,
    keys: finalistKeys[f],
    vault: vaultChoices[i]
  }));

  results.sort((a, b) => b.vault - a.vault);
  let winner = results.find(r => r.keys >= r.vault);
  if (!winner) winner = { name: jury.find(j => j.phase === 3).name, keys: 0, vault: 0 };
  log(`The winner is ${winner.name}, opening a vault needing ${winner.vault} with ${winner.keys} keys!`);
}

function generateAlliances() {
  alliances = { "Alliance A": [], "Alliance B": [], "Alliance C": [] };
  shuffle(players).forEach((p, i) => {
    if (i % 3 === 0) alliances["Alliance A"].push(p);
    if (i % 3 === 1) alliances["Alliance B"].push(p);
    if (i % 3 === 2) alliances["Alliance C"].push(p);
  });
}

function updateAlliances() {
  const box = document.getElementById("alliancesList");
  box.innerHTML = "";
  Object.entries(alliances).forEach(([name, members]) => {
    box.innerHTML += `<strong>${name}:</strong> ${members.join(", ")}<br/>`;
  });
}

function simulateVote(voters, eligible) {
  return voters.map(v => {
    let options = eligible.filter(p => p !== v);
    let pick = options[Math.floor(Math.random() * options.length)];
    return [v, pick];
  });
}

function getWinnersFromVote(votePairs, eligible) {
  let tally = {};
  eligible.forEach(p => tally[p] = 0);
  votePairs.forEach(([_, vote]) => tally[vote]++);
  let maxVotes = Math.max(...Object.values(tally));
  let tied = Object.keys(tally).filter(p => tally[p] === maxVotes);
  return [tied[0], tied];
}

function displayVotingMatrix(votes) {
  let matrix = `<table><tr><th>Voter</th><th>Vote</th></tr>`;
  votes.forEach(([voter, votee]) => {
    matrix += `<tr><td>${voter}</td><td>${votee}</td></tr>`;
  });
  matrix += `</table>`;
  document.getElementById("votingMatrix").innerHTML = matrix;
}

function displayJuryMatrix(matrix) {
  let header = `<table><tr><th>Juror</th>`;
  finalists.forEach(f => header += `<th>${f}</th>`);
  header += `<th>Total</th></tr>`;
  let rows = "";
  for (let juror in matrix) {
    let row = `<tr><td>${juror}</td>`;
    let total = 0;
    finalists.forEach(f => {
      let val = matrix[juror][f];
      total += val;
      row += `<td>${val}</td>`;
    });
    row += `<td>${total}</td></tr>`;
    rows += row;
  }
  document.getElementById("juryMatrix").innerHTML = header + rows + "</table>";
}

function updateProgress() {
  let html = "<table><tr><th>Player</th><th>Phase 1</th><th>Phase 2</th><th>Phase 3</th></tr>";
  Object.keys(keys).forEach(p => {
    html += `<tr><td>${p}</td>`;
    html += `<td>${keys[p].includes("P1") ? "✔️" : ""}</td>`;
    html += `<td>${keys[p].includes("P2") ? "✔️" : ""}</td>`;
    html += `<td>${finalists.includes(p) ? "✔️" : ""}</td></tr>`;
  });
  html += "</table>";
  document.getElementById("progressChart").innerHTML = html;
}

function log(msg) {
  const logBox = document.getElementById("roundEvents");
  logBox.textContent += `\n${msg}`;
  logBox.scrollTop = logBox.scrollHeight;
}

function shuffle(arr) {
  return arr.slice().sort(() => Math.random() - 0.5);
}
  </script>

</body>
</html>