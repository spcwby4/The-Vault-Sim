<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>The Vault Simulator</title>
  <style>
    body { font-family: Arial; background: #f2f2f2; padding: 20px; }
    h1 { text-align: center; }
    textarea, button { width: 100%; padding: 10px; margin-top: 10px; font-size: 16px; }
    .box { background: white; padding: 15px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
    pre { background: #eee; padding: 10px; border-radius: 5px; height: 200px; overflow-y: scroll; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    .collapsible { background-color: #eee; cursor: pointer; padding: 10px; width: 100%; text-align: left; border: none; outline: none; font-size: 16px; margin-top: 5px; }
    .collapsible.active, .collapsible:hover { background-color: #ccc; }
    .content { display: none; overflow: hidden; padding: 0 10px 10px; }
  </style>
</head>
<body>

  <h1>The Vault Simulator</h1>

  <div class="box">
    <label for="playerInput"><strong>Enter 12 Players (one per line):</strong></label>
    <textarea id="playerInput" rows="12" placeholder="Player 1&#10;Player 2&#10;..."></textarea>
<button id="startBtn" onclick="startGame()">Start Game</button>
<button id="nextBtn" onclick="nextRound()" style="display:none;">Next Round</button>
  </div>

  <div class="box" id="alliancesBox">
    <h2>Alliances</h2>
    <div id="alliancesList"></div>
  </div>

  <div class="box">
    <h2>Round Events</h2>
    <pre id="roundEvents"></pre>
  </div>

  <div class="box">
    <h2>Progress Chart</h2>
    <div id="progressChart"></div>
  </div>

  <div class="box">
    <h2>Voting Matrix</h2>
    <div id="votingMatrix"></div>
  </div>

  <div class="box">
    <h2>Jury Key Distribution</h2>
    <div id="juryMatrix"></div>
  </div>

<script>
let players = [];
let phase = 1;
let round = 1;
let alliances = {};
let keys = {};
let votes = [];
let jury = [];
let finalists = [];
let eliminated = [];
let lockpickHolder = null;
let lockpickUsed = false;
let lockpickFound = false;
let currentDraw = [];
let votingMatrix = [];
let juryMatrix = {};
let vaults = [3, 7, 9, 11, 13, 15, 17, 19, 22];
let gameStarted = false;

function startGame() {
  if (gameStarted) return;
  gameStarted = true;

  const input = document.getElementById("playerInput").value.trim().split("\n");
  if (input.length !== 12) {
    alert("Please enter exactly 12 players.");
    return;
  }

  players = input.map(p => p.trim());
  players.forEach(p => keys[p] = []);

  generateAlliances();
  updateAlliances();
  log(`Phase 1 begins: The Key Quest starts now.`);

  document.getElementById("startBtn").style.display = "none";
  document.getElementById("nextBtn").style.display = "inline-block";

  nextRound();
}

function nextRound() {
  clearLog();

  if (phase === 1) {
    runPhase1();
  } else if (phase === 2) {
    runPhase2();
  } else if (phase === 3) {
    runPhase3();
  } else if (phase === 4) {
    runFinale();
  }
}

function runPhase1() {
  if (round > 4 || Object.values(keys).filter(k => k.includes("P1")).length >= 8) {
    endPhase1();
    return;
  }

  let eligiblePlayers = players.filter(p => !keys[p].includes("P1"));
  let drawn = shuffle(eligiblePlayers).slice(0, 4);
  currentDraw = drawn;

  log(`Round ${round} – Drawn players: ${drawn.join(", ")}`);

  if (!lockpickFound && Math.random() < 0.33) {
    lockpickHolder = drawn[Math.floor(Math.random() * drawn.length)];
    lockpickFound = true;
    log(`${lockpickHolder} has found the Lockpick!`);
  }

  let vote = simulateVote(players, drawn);
  displayVotingMatrix(vote);

  let [winner, tied] = getWinnersFromVote(vote, drawn);

  if (lockpickHolder && !lockpickUsed && drawn.includes(lockpickHolder)) {
    winner = lockpickHolder;
    lockpickUsed = true;
    log(`${lockpickHolder} used the Lockpick to override the vote!`);
  }

  log(`${winner} wins the vote key!`);
  keys[winner].push("P1");

  let challengers = drawn.filter(p => p !== winner && !keys[p].includes("P1"));

  if (challengers.length > 0) {
    let challengeWinner = challengers[Math.floor(Math.random() * challengers.length)];
    keys[challengeWinner].push("P1");
    log(`${challengeWinner} wins the challenge key!`);
  }

  updateProgress();
  round++;
}

function endPhase1() {
  let advancing = players.filter(p => keys[p].includes("P1"));
  let phaseOut = players.filter(p => !advancing.includes(p));

  eliminated = phaseOut;
  phaseOut.forEach(p => jury.push({ name: p, phase: 1 }));

  players = advancing;
  round = 1;
  phase = 2;

  log(`Phase 1 complete. Eliminated: ${phaseOut.join(", ")}`);
  nextRound();
}

function runPhase2() {
  if (round > 4 || Object.values(keys).filter(k => k.includes("P2")).length >= 4) {
    endPhase2();
    return;
  }

  log(`Phase 2 – Round ${round}`);

  let noKey = players.filter(p => !keys[p].includes("P2"));
  if (noKey.length < 2) {
    log("Not enough players to run another round.");
    endPhase2();
    return;
  }

  let vote = simulateVote(players, noKey);
  displayVotingMatrix(vote);

  let [winner, tied] = getWinnersFromVote(vote, noKey);

  if (lockpickHolder && !lockpickUsed) {
    winner = lockpickHolder;
    lockpickUsed = true;
    log(`${lockpickHolder} used the Lockpick to override the vote!`);
  }

  let opponent = noKey.filter(p => p !== winner)[Math.floor(Math.random() * (noKey.length - 1))];
  log(`${winner} chooses to duel ${opponent}.`);

  let duelWinner = Math.random() < 0.5 ? winner : opponent;
  log(`${duelWinner} wins the duel and earns a Phase 2 key!`);
  keys[duelWinner].push("P2");

  updateProgress();
  round++;
}

function endPhase2() {
  let advancing = players.filter(p => keys[p].includes("P2"));
  let phaseOut = players.filter(p => !advancing.includes(p));

  eliminated = phaseOut;
  phaseOut.forEach(p => jury.push({ name: p, phase: 2 }));

  players = advancing;
  round = 1;
  phase = 3;

  log(`Phase 2 complete. Eliminated: ${phaseOut.join(", ")}`);
  nextRound();
}

function runPhase3() {
  log(`Phase 3 – Final Cut begins`);

  let vote = simulateVote(players, players);
  displayVotingMatrix(vote);

  let [voteWinner, tied] = getWinnersFromVote(vote, players);
  log(`${voteWinner} wins the final vote and becomes a finalist.`);

  let available = players.filter(p => p !== voteWinner);
  let chosenAlly = available[Math.floor(Math.random() * available.length)];

  finalists = [voteWinner, chosenAlly];
  log(`${voteWinner} selects ${chosenAlly} to join them.`);

  let remaining = players.filter(p => !finalists.includes(p));
  let duelWinner = Math.random() < 0.5 ? remaining[0] : remaining[1];
  let duelLoser = remaining.find(p => p !== duelWinner);

  finalists.push(duelWinner);
  jury.push({ name: duelLoser, phase: 3 });

  phase = 4;

  updateProgress();
  log(`${duelWinner} wins the final challenge. ${duelLoser} is eliminated.`);
  nextRound();
}

function runFinale() {
  log(`Vault Finale – Finalists: ${finalists.join(", ")}`);

  let vaultChoices = shuffle(vaults).slice(0, 3);
  let finalistKeys = {};
  finalists.forEach(p => finalistKeys[p] = 3);

  juryMatrix = {};
  jury.forEach(j => {
    let votesToGive = j.phase === 1 ? 1 : j.phase === 2 ? 2 : 4;
    juryMatrix[j.name] = {};

    let giveTo = shuffle(finalists).slice(0, votesToGive);
    finalists.forEach(f => juryMatrix[j.name][f] = 0);

    for (let i = 0; i < votesToGive; i++) {
      let recipient = giveTo[i % giveTo.length];
      finalistKeys[recipient]++;
      juryMatrix[j.name][recipient]++;
    }
  });

  displayJuryMatrix(juryMatrix);

  let result = finalists.map((name, i) => ({
    name,
    keys: finalistKeys[name],
    vault: vaultChoices[i]
  }));

  result.sort((a, b) => b.vault - a.vault);

  let winner = result.find(r => r.keys >= r.vault);
  if (!winner) {
    winner = { name: jury.find(j => j.phase === 3).name, keys: 0, vault: 0 };
    log(`None of the finalists opened a vault. ${winner.name} wins by default!`);
  } else {
    log(`${winner.name} opens the ${winner.vault}-key vault with ${winner.keys} keys and wins!`);
  }
}

function simulateVote(voters, eligible) {
  return voters.map(v => {
    let choices = eligible.filter(p => p !== v);
    let choice = choices[Math.floor(Math.random() * choices.length)];
    return [v, choice];
  });
}

function getWinnersFromVote(votePairs, eligible) {
  let counts = {};
  eligible.forEach(p => counts[p] = 0);
  votePairs.forEach(([_, votee]) => counts[votee]++);
  let max = Math.max(...Object.values(counts));
  let tied = Object.keys(counts).filter(p => counts[p] === max);
  return [tied[0], tied];
}

function generateAlliances() {
  alliances = { A: [], B: [], C: [] };
  let shuffled = shuffle(players);

  shuffled.forEach((p, i) => {
    if (i % 3 === 0) alliances.A.push(p);
    else if (i % 3 === 1) alliances.B.push(p);
    else alliances.C.push(p);
  });
}

function updateAlliances() {
  const box = document.getElementById("alliancesList");
  box.innerHTML = "";

  Object.entries(alliances).forEach(([name, members]) => {
    box.innerHTML += `<strong>Alliance ${name}</strong>: ${members.join(", ")}<br/>`;
  });
}

function updateProgress() {
  const chart = document.getElementById("progressChart");

  let html = `<table><tr><th>Player</th><th>P1</th><th>P2</th><th>Final</th></tr>`;
  players.concat(eliminated).forEach(p => {
    html += `<tr><td>${p}</td>`;
    html += `<td>${keys[p]?.includes("P1") ? "✔️" : ""}</td>`;
    html += `<td>${keys[p]?.includes("P2") ? "✔️" : ""}</td>`;
    html += `<td>${finalists.includes(p) ? "✔️" : ""}</td></tr>`;
  });
  html += `</table>`;
  chart.innerHTML = html;
}

function displayVotingMatrix(votes) {
  const matrix = document.getElementById("votingMatrix");
  let html = `<table><tr><th>Voter</th><th>Vote</th></tr>`;
  votes.forEach(([v, vote]) => {
    html += `<tr><td>${v}</td><td>${vote}</td></tr>`;
  });
  html += `</table>`;
  matrix.innerHTML = html;
}

function displayJuryMatrix(matrix) {
  const area = document.getElementById("juryMatrix");

  let html = `<table><tr><th>Juror</th>`;
  finalists.forEach(f => html += `<th>${f}</th>`);
  html += `<th>Total</th></tr>`;

  for (let juror in matrix) {
    html += `<tr><td>${juror}</td>`;
    let sum = 0;
    finalists.forEach(f => {
      html += `<td>${matrix[juror][f]}</td>`;
      sum += matrix[juror][f];
    });
    html += `<td>${sum}</td></tr>`;
  }

  html += `</table>`;
  area.innerHTML = html;
}

function log(msg) {
  const box = document.getElementById("roundEvents");
  box.textContent += `\n${msg}`;
  box.scrollTop = box.scrollHeight;
}

function clearLog() {
  const box = document.getElementById("roundEvents");
  box.textContent = "";
}

function shuffle(arr) {
  return arr.slice().sort(() => Math.random() - 0.5);
}

</script>

</body>
</html>