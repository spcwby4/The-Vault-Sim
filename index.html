<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>The Vault Simulator</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    .log { white-space: pre-wrap; background: #f8f8f8; padding: 10px; border: 1px solid #ccc; margin: 20px 0; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
    td, th { border: 1px solid #999; padding: 5px 10px; text-align: center; }
    .highlight { font-weight: bold; color: #d42; }
  </style>
</head>
<body>
  <h1>The Vault Simulator</h1>
  <p>Enter 12 player names, one per line:</p>
  <textarea id="playerInput" rows="12" cols="30" placeholder="Player 1&#10;Player 2&#10;..."></textarea><br>
  <button onclick="startGame()" id="startBtn">Start Game</button>
  <button onclick="runRound()" id="nextBtn" style="display:none;">Run Next Round</button>

  <div id="log" class="log"></div>
  <div id="votingTable"></div>
  <div id="progressTable"></div>

  <script>
    // --- Game Variables ---
    let players = [], phase = 1, round = 1, lockpickHolder = null, voteLog = [];

    function startGame() {
      const lines = document.getElementById("playerInput").value.trim().split("\\n").map(l => l.trim()).filter(l => l);
      if (lines.length !== 12) { alert("Please enter 12 players."); return; }
      players = lines.map(n => ({ name:n, alliances:[], hasKey:false,
          key1:false, key2:false, key3:false, finalist:false, eliminated:false,
          elimRound:null, juryKeyTotal:0, totalKeys:3, vaultPick:null }));
      assignAlliances();
      document.getElementById("startBtn").style.display = "none";
      document.getElementById("nextBtn").style.display = "inline-block";
      runRound();
    }

    function assignAlliances() {
      for (let i = 0; i < 3; i++) {
        const members = shuffle([...players]).slice(0, 4 + Math.floor(Math.random()*3));
        members.forEach(p => p.alliances.push(`Alliance ${i+1}`));
      }
    }

    function runRound() {
      clearLog();
      log(`--- Phase ${phase}, Round ${round} ---`);
      logAlliances();
      if (phase === 1) runPhase1();
      else if (phase === 2) runPhase2();
      else if (phase === 3) runPhase3();
      else runFinale();
    }

    function runPhase1() {
      const eligible = players.filter(p => !p.key1 && !p.eliminated);
      const drawn = shuffle(eligible).slice(0,4);
      log("Drawn: " + drawn.map(p => p.name).join(", "));

      if (!lockpickHolder && Math.random()<0.33) {
        lockpickHolder = drawn[Math.floor(Math.random()*4)];
        log(`${lockpickHolder.name} found the Lockpick!`);
      }

      voteLog = [];
      players.forEach(v => {
        const choices = drawn.filter(d=>d.name!==v.name);
        const vote = chooseAllyOrRandom(v, choices);
        voteLog.push({voter:v.name, votedFor:vote.name});
      });
      displayVoteTable();

      let voteWinner;
      if (lockpickHolder && drawn.includes(lockpickHolder)) {
        voteWinner = lockpickHolder;
        log(`${voteWinner.name} uses Lockpick to claim vote key.`);
        lockpickHolder = null;
      } else {
        const counts = tallyVotes();
        voteWinner = tieBreak(counts, drawn);
        log(`${voteWinner.name} wins the vote key.`);
      }
      voteWinner.key1 = true; voteWinner.hasKey = true;

      const remaining = drawn.filter(d => !d.key1);
      const chal = shuffle(remaining)[0];
      chal.key1 = true; chal.hasKey = true;
      log(`${chal.name} wins the challenge key.`);

      round++;
      if (round>4 || players.filter(p=>!p.key1 && !p.eliminated).length===0) {
        const out = players.filter(p=>!p.key1);
        out.forEach(p=>{p.eliminated=true; p.elimRound=round});
        phase=2; round=1;
      }
    }

    function runPhase2() {
      const eligible = players.filter(p=>!p.key2&& !p.eliminated);
      if (eligible.length<=4) { phase=3; round=1; return runRound(); }
      log("Phase 2: Vote to Duel");
      if (!lockpickHolder && Math.random()<0.33) {
        lockpickHolder=shuffle(eligible)[0];
        log(`${lockpickHolder.name} found the Lockpick!`);
      }

      voteLog=[];
      players.filter(p=>!p.eliminated).forEach(v => {
        const opts=eligible.filter(e=>e.name!==v.name);
        const vote=chooseAllyOrRandom(v,opts);
        voteLog.push({voter:v.name, votedFor:vote.name});
      });
      displayVoteTable();

      let voteWinner;
      if (lockpickHolder) {
        voteWinner=lockpickHolder; log(`${voteWinner.name} uses Lockpick to skip vote.`);
        lockpickHolder=null;
      } else {
        const counts = tallyVotes();
        voteWinner = tieBreak(counts, eligible);
        log(`${voteWinner.name} is selected to duel.`);
      }

      const opponent = shuffle(eligible.filter(e=>e.name!==voteWinner.name))[0];
      const champ = Math.random()<0.5 ? voteWinner : opponent;
      champ.key2 = true; champ.hasKey = true;
      log(`${champ.name} wins the duel and the key.`);
      round++;
      if (round>4 || players.filter(p=>!p.eliminated && !p.key2).length<=4) {
        phase=3; round=1;
      }
    }

    function runPhase3() {
      const remaining = players.filter(p=>!p.eliminated && !p.key3);
      voteLog=[];
      remaining.forEach(v => {
        const opts=remaining.filter(o=>o.name!==v.name);
        voteLog.push({voter:v.name, votedFor:chooseAllyOrRandom(v,opts).name});
      });
      displayVoteTable();
      const counts=tallyVotes();
      const winner=tieBreak(counts,remaining);
      winner.key3=true; winner.hasKey=true; winner.finalist=true;
      log(`${winner.name} wins vote and advances.`);

      const bring=chooseAllyOrRandom(winner,remaining.filter(o=>o!==winner));
      bring.key3=true; bring.hasKey=true; bring.finalist=true;
      log(`${winner.name} brings ${bring.name} as finalist.`);

      const left=remaining.filter(o=>!o.finalist);
      const champ=shuffle(left)[0]; champ.key3=true; champ.hasKey=true; champ.finalist=true;
      const out=left.find(o=>o!==champ); out.eliminated=true; out.elimRound="Phase 3";
      log(`${champ.name} wins final duel and advances.`);
      phase=4; round=1;
    }

    function runFinale() {
      const finalists=players.filter(p=>p.finalist);
      finalists.forEach(p=>p.totalKeys=3);
      const jury=players.filter(p=>!p.finalist && p.eliminated);
      jury.forEach(j=> {
        let amount=j.elimRound==="Phase 3"?4:(j.key2?2:1);
        let recipient = shuffle(finalists)[0];
        if (Math.random()<0.4 && j.alliances.length) {
          const ally=finalists.find(f=>sharesAlliance(j,f));
          if (ally) recipient=ally;
        }
        recipient.totalKeys+=amount;
        log(`${j.name} gives ${amount} keys to ${recipient.name}`);
      });
      finalists.forEach(p=>{
        p.vaultPick = p.totalKeys >=11? shuffle([15,17,19])[0] : p.totalKeys + 1;
        log(`${p.name} picks vault requiring ${p.vaultPick} keys`);
      });
      const openers=finalists.filter(f=>f.totalKeys>=f.vaultPick);
      let winner;
      if (openers.length) winner=openers.sort((a,b)=>b.vaultPick-a.vaultPick)[0];
      else {
        const fourth=players.find(p=>p.elimRound==="Phase 3");
        log(`No vault opens. ${fourth.name} wins by default!`);
        winner=fourth;
      }
      if (winner) log(`ðŸŽ‰ ${winner.name} opens vault and wins The Vault!`);
      showGameSummary(winner.name);
    }

    // --- Helper Functions ---
    function chooseAllyOrRandom(v,opts){ const a=opts.filter(o=>sharesAlliance(v,o)); return (a.length&&Math.random()<0.7)?shuffle(a)[0]:shuffle(opts)[0]; }
    function sharesAlliance(a,b){ return a.alliances.some(x=>b.alliances.includes(x)); }
    function tallyVotes(){ const m={}; voteLog.forEach(v=>m[v.votedFor]= (m[v.votedFor]||0)+1); return m; }
    function tieBreak(counts,options){ const max=Math.max(...Object.values(counts)); const tied = options.filter(o=>counts[o.name]===max); return shuffle(tied)[0]; }
    function giveKey(p,phaseKey){ p[phaseKey]=true; p.hasKey=true; }
    function log(msg){ document.getElementById("log").innerText += msg + "\\n"; }
    function clearLog(){ document.getElementById("log").innerText = ""; document.getElementById("votingTable").innerHTML=""; }
    function displayVoteTable() {
      let html="<table><tr><th>Voter</th><th>Voted For</th></tr>";
      voteLog.forEach(v=>{
        const p=players.find(x=>x.name===v.votedFor);
        html+=`<tr><td>${v.voter}</td><td class="${p.hasKey?'highlight':''}">${v.votedFor}</td></tr>`;
      });
      html+="</table>";
      document.getElementById("votingTable").innerHTML=html;
    }

    function showGameSummary(winner){
      let sorted = [...players].sort((a,b)=>{
        if(a.name===winner) return -1;
        if(b.name===winner) return 1;
        if(a.finalist&&b.finalist) return b.totalKeys - a.totalKeys;
        if(a.finalist) return -1;
        return (a.elimRound||Infinity) - (b.elimRound||Infinity);
      });
      let html = "<h2>Final Results</h2><table><tr><th>Name</th><th>Keys</th><th>Vault</th><th>Status</th></tr>";
      sorted.forEach(p=>html+=`<tr><td>${p.name}</td><td>${p.totalKeys}</td><td>${p.vaultPick||'-'}</td><td>${p.name===winner?'Winner':p.finalist?'Finalist':`Elim @ ${p.elimRound}`}</td></tr>`);
      html+="</table>";
      document.getElementById("progressTable").innerHTML=html;
    }

    function shuffle(arr){return arr.sort(()=>Math.random()-0.5);}
  </script>
</body>
</html>
'''

txt_path = Path("/mnt/data/vault_simulator_full.txt")
txt_path.write_text(full_html_code)

txt_path.name