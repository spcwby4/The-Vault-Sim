<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>The Vault Simulator</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#1a1d24;
      --muted:#2a2f3a;
      --text:#e5e7eb;
      --sub:#aeb4c0;
      --accent:#7aa2ff;
      --good:#6ee7b7;
      --warn:#fbbf24;
      --bad:#f87171;
      --border:#2b3340;
    }
    *{box-sizing:border-box}
    body{font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);padding:20px;margin:0}
    h1{margin:0 0 16px;text-align:center}
    h2{margin:0 0 10px;font-size:18px;color:var(--text)}
    textarea,button{width:100%;padding:10px;margin-top:10px;font-size:15px;border-radius:8px;border:1px solid var(--border);background:var(--panel);color:var(--text)}
    button{cursor:pointer}
    button:hover{background:var(--muted)}
    .box{background:var(--panel);padding:15px;border-radius:12px;box-shadow:0 0 0 1px var(--border);margin-bottom:18px}
    pre{background:var(--bg);padding:10px;border-radius:8px;height:220px;overflow-y:auto;border:1px solid var(--border);white-space:pre-wrap}
    table{width:100%;border-collapse:collapse;margin-top:10px}
    th,td{border:1px solid var(--border);padding:8px;text-align:center}
    th{background:var(--muted)}
    .pill{display:inline-block;min-width:20px;border-radius:6px;padding:2px 6px}
    .ok{background:rgba(110,231,183,.15);border:1px solid rgba(110,231,183,.35)}
    .no{background:rgba(248,113,113,.12);border:1px solid rgba(248,113,113,.3)}
    details{border:1px solid var(--border);border-radius:8px;margin-top:8px}
    summary{padding:8px 10px;cursor:pointer;background:var(--muted)}
    .flex{display:flex;gap:18px;flex-wrap:wrap}
    .half{flex:1 1 420px}
    .right{max-width:520px}
    .hint{color:var(--sub);font-size:13px;margin-top:6px}
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;background:var(--muted);font-size:12px;margin-left:6px}
  </style>
</head>
<body>

  <h1>The Vault Simulator <span class="badge">Dark</span></h1>

  <div class="box">
    <label for="playerInput"><strong>Enter 12 Players (one per line):</strong></label>
    <textarea id="playerInput" rows="12" placeholder="Player 1&#10;Player 2&#10;..."></textarea>
    <button id="startBtn">Start Game</button>
    <button id="nextBtn" style="display:none;">Next</button>
    <div class="hint">Flow: Phase 1 → Phase 2 → Phase 3 (vote step, then duel step) → Finale.</div>
  </div>

  <div class="flex">
    <div class="box half">
      <h2>Round Events</h2>
      <pre id="roundEvents"></pre>
    </div>

    <div class="box half right">
      <h2>Alliances</h2>
      <div id="alliancesList"></div>
    </div>
  </div>

  <div class="box">
    <h2>Progress Chart</h2>
    <div id="progressChart"></div>
  </div>

  <div class="box">
    <h2>Voting Matrix</h2>
    <div id="votingMatrix"></div>
  </div>

  <div class="box">
    <h2>Jury Key Distribution</h2>
    <div id="juryMatrix"></div>
  </div>

<script>
/* ====== State ====== */
let players = [];
let phase = 1;
let round = 1;
let alliances = {};     // {Name:[players]}
let keys = {};          // {player:[ "P1", "P2" ]}
let jury = [];          // [{name, phase}]
let finalists = [];     // [p1,p2,p3]
let eliminated = [];    // in elimination order
let votingHistory = []; // [{title, votePairs, roundNo, phase}]
let vaults = [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22];

let currentDraw = [];
let lockpickHolder = null;
let lockpickUsed = false;
let lockpickFound = false;

let gameStarted = false;
let phase3Step = 0; // 0 = vote+ally, 1 = duel

/* cache DOM */
const startBtn = document.getElementById('startBtn');
const nextBtn  = document.getElementById('nextBtn');
const roundsBox= document.getElementById('roundEvents');

startBtn.onclick = startGame;
nextBtn.onclick  = nextRound;

/* ====== Helpers ====== */
function log(msg){
  roundsBox.textContent += (roundsBox.textContent ? '\n' : '') + msg;
  roundsBox.scrollTop = roundsBox.scrollHeight;
}
function clearLog(){ roundsBox.textContent = '' }
function shuffle(arr){ return arr.slice().sort(()=>Math.random()-0.5) }

function inAlliance(a,b){
  return Object.values(alliances).some(list => list.includes(a) && list.includes(b));
}
function allianceNamesFor(p){
  return Object.entries(alliances).filter(([n,list])=>list.includes(p)).map(([n])=>n);
}

/* ====== Start / Next / Reset ====== */
function startGame(){
  if(gameStarted) return;
  const input = document.getElementById('playerInput').value.trim().split('\n').map(s=>s.trim()).filter(Boolean);
  if(input.length !== 12){ alert('Please enter exactly 12 players.'); return }
  gameStarted = true;

  players = input;
  players.forEach(p => keys[p] = []);

  generateAlliances();
  updateAlliances();
  updateProgress();

  log('Phase 1 begins: The Key Quest starts now.');
  startBtn.style.display = 'none';
  nextBtn.style.display = 'inline-block';
  nextBtn.textContent = 'Next';
  nextBtn.onclick = nextRound;

  nextRound();
}

function nextRound(){
  clearLog();
  if(phase === 1) runPhase1();
  else if(phase === 2) runPhase2();
  else if(phase === 3) runPhase3();
  else if(phase === 4) runFinale();
}

function endGameUI(){
  nextBtn.textContent = 'Simulate Again';
  nextBtn.onclick = ()=>location.reload();
}

/* ====== Voting ====== */
function simulateVote(voters, eligible, phaseTag){
  // Slight bias toward empowering allies when possible
  return voters.map(v=>{
    const choices = eligible.filter(p=>p!==v);
    const allyChoices = choices.filter(c=>inAlliance(v,c));
    const pick = allyChoices.length && Math.random()<0.6
      ? allyChoices[Math.floor(Math.random()*allyChoices.length)]
      : choices[Math.floor(Math.random()*choices.length)];
    return [v,pick];
  });
}

function tally(votePairs, eligible){
  const counts = {}; eligible.forEach(p => counts[p]=0);
  votePairs.forEach(([_,to]) => { if(counts.hasOwnProperty(to)) counts[to]++ });
  const max = Math.max(...Object.values(counts));
  const tied = Object.keys(counts).filter(p => counts[p]===max);
  return [tied[0], tied, counts];
}

function recordVotingMatrix(title, votePairs, roundNo, phaseTag){
  votingHistory.push({ title, votePairs, roundNo, phase: phaseTag });
  renderVotingMatrices();
}

/* Voting tables: per-round collapsibles + a full-season table (no arrows) */
function renderVotingMatrices(){
  const wrap = document.getElementById('votingMatrix');
  let html = '';
  votingHistory.forEach((blk, idx)=>{
    html += `<details ${idx===votingHistory.length-1?'open':''}>
      <summary>${blk.title}</summary>
      <table><tr><th>Voter</th><th>Vote</th></tr>${
        blk.votePairs.map(([v,to])=>`<tr><td>${v}</td><td>${to}</td></tr>`).join('')
      }</table>
    </details>`;
  });

  // Full-season table
  html += `<details>
    <summary>Full-Season Voting Table</summary>
    <table>
      <tr><th>Phase</th><th>Round</th><th>Voter</th><th>Vote</th></tr>
      ${
        votingHistory.map(blk =>
          blk.votePairs.map(([v,to])=> `<tr><td>${blk.phase}</td><td>${blk.roundNo??''}</td><td>${v}</td><td>${to}</td></tr>`).join('')
        ).join('')
      }
    </table>
  </details>`;

  wrap.innerHTML = html;
}

/* ====== Alliances (fluid) ====== */
function generateAlliances(){
  alliances = {};
  const count = Math.floor(Math.random()*3)+2; // 2..4 alliances
  const names = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').slice(0,count);
  const sh = shuffle(players);

  // seed evenly
  names.forEach((n,i)=> alliances[n] = []);
  sh.forEach((p,i)=> alliances[names[i%count]].push(p));

  // small chance of dual-membership at start
  players.forEach(p=>{
    if(Math.random()<0.15){
      const other = names[Math.floor(Math.random()*names.length)];
      if(!alliances[other].includes(p)) alliances[other].push(p);
    }
  });
}

function evolveAlliancesAfterVote(votePairs, phaseTag){
  // Kick untrustworthy: if you voted against a fellow member, 50% chance you get booted from that alliance
  const betrayals = [];
  votePairs.forEach(([v,to])=>{
    Object.entries(alliances).forEach(([name, list])=>{
      if(list.includes(v) && list.includes(to)){
        // voting "for" an ally is generally good power play, so betrayal is voting against an ally
        // but our matrix is "vote for", not "vote against". We will treat it as empowering that ally.
        // So betrayal: if voter DID NOT vote for any ally when one was eligible and instead voted a non-ally
      }
    });
  });
  // Identify when an ally was eligible but voter chose non-ally
  votePairs.forEach(([v,to])=>{
    const vAllies = Object.entries(alliances).filter(([_,list])=>list.includes(v)).map(([n])=>n);
    if(!vAllies.length) return;
    const elig = new Set(votePairs.map(([_,cand])=>cand)); // eligible targets this vote
    vAllies.forEach(name=>{
      const mates = alliances[name].filter(p=>p!==v && elig.has(p));
      if(mates.length && !mates.includes(to)){
        betrayals.push({voter:v, alliance:name});
      }
    });
  });

  const kicked = [];
  betrayals.forEach(b=>{
    if(Math.random()<0.5){
      const arr = alliances[b.alliance];
      const idx = arr.indexOf(b.voter);
      if(idx>-1){
        arr.splice(idx,1);
        kicked.push(`${b.voter} removed from Alliance ${b.alliance} for untrustworthy voting`);
      }
    }
  });
  if(kicked.length) log(kicked.join('; '));

  // Random chance to form a new micro-alliance midgame (2–4 members) from active players
  if(Math.random()<0.25 && players.length>=4){
    const cand = shuffle(players).slice(0, Math.floor(Math.random()*3)+2); // 2..4
    const newName = pickNewAllianceName();
    alliances[newName] = cand.slice();
    log(`New Alliance ${newName} forms: ${cand.join(', ')}`);
  }

  // Clean up empty alliances
  Object.keys(alliances).forEach(name=>{
    alliances[name] = alliances[name].filter(p=>players.includes(p)); // drop eliminated
    if(alliances[name].length===0) delete alliances[name];
  });

  updateAlliances();
}

function pickNewAllianceName(){
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
  for(const c of alphabet){
    if(!alliances[c]) return c;
  }
  return 'Z'+Math.floor(Math.random()*99);
}

function updateAlliances(){
  const box = document.getElementById("alliancesList");
  box.innerHTML = '';
  Object.entries(alliances).forEach(([name, members])=>{
    box.innerHTML += `<strong>Alliance ${name}</strong>: ${members.join(', ')}<br/>`;
  });
}

/* ====== Progress (keep eliminated at bottom) ====== */
function updateProgress(){
  const chart = document.getElementById('progressChart');
  const everyone = players.concat(eliminated.filter(p=>!players.includes(p)));
  let html = `<table>
    <tr><th>Player</th><th>P1</th><th>P2</th><th>Final</th></tr>`;
  everyone.forEach(p=>{
    const p1 = keys[p]?.includes('P1') ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    const p2 = keys[p]?.includes('P2') ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    const pf = finalists.includes(p)     ? `<span class="pill ok">✔</span>` : `<span class="pill no">—</span>`;
    html += `<tr><td>${p}</td><td>${p1}</td><td>${p2}</td><td>${pf}</td></tr>`;
  });
  html += `</table>`;
  chart.innerHTML = html;
}

/* ====== Phase 1 ====== */
function runPhase1(){
  if(round > 4 || Object.values(keys).filter(k=>k.includes('P1')).length >= 8){
    return endPhase1();
  }

  const eligible = players.filter(p=>!keys[p].includes('P1'));
  const drawn = shuffle(eligible).slice(0,4);
  currentDraw = drawn;

  log(`Phase 1 – Round ${round}`);
  log(`Drawn: ${drawn.join(', ')}`);

  // Lockpick discovery
  if(!lockpickFound && Math.random() < 0.33){
    lockpickHolder = drawn[Math.floor(Math.random()*drawn.length)];
    lockpickFound = true;
    log(`${lockpickHolder} discovers the Lockpick.`);
  }

  // House vote among drawn (but all 12 vote)
  const votePairs = simulateVote(players, drawn, 'P1');
  recordVotingMatrix(`P1 Round ${round} — House Vote`, votePairs, round, 'P1');

  let [voteWinner] = tally(votePairs, drawn);

  // Smart Lockpick use in P1: auto-use in Round 4 if holder lacks P1; otherwise small chance
  if(lockpickHolder && !lockpickUsed && drawn.includes(lockpickHolder)){
    const mustUse = (round===4 && !keys[lockpickHolder].includes('P1'));
    const willUse = mustUse || Math.random() < 0.2;
    if(willUse){
      voteWinner = lockpickHolder;
      lockpickUsed = true;
      log(`${lockpickHolder} uses the Lockpick to override the vote.`);
    }
  }

  // Award vote key
  keys[voteWinner].push('P1');
  log(`${voteWinner} wins the vote key.`);

  // Challenge among remaining drawn without P1
  const challengers = drawn.filter(p=>p!==voteWinner && !keys[p].includes('P1'));
  if(challengers.length>0){
    const challengeWinner = challengers[Math.floor(Math.random()*challengers.length)];
    keys[challengeWinner].push('P1');
    log(`${challengeWinner} wins the challenge key.`);
  }else{
    log(`No challenge key awarded.`);
  }

  evolveAlliancesAfterVote(votePairs, 'P1');
  updateProgress();
  round++;
}

function endPhase1(){
  const advancing = players.filter(p=>keys[p].includes('P1'));
  const phaseOut  = players.filter(p=>!advancing.includes(p));
  phaseOut.forEach(p=>{ if(!eliminated.includes(p)) eliminated.push(p) });
  phaseOut.forEach(p=>jury.push({name:p, phase:1}));

  players = advancing;
  log(`Phase 1 complete. Eliminated: ${phaseOut.join(', ')}`);
  round = 1; phase = 2;
  nextRound();
}

/* ====== Phase 2 ====== */
function runPhase2(){
  if(round > 4 || Object.values(keys).filter(k=>k.includes('P2')).length >= 4){
    return endPhase2();
  }

  log(`Phase 2 – Round ${round}`);
  const noKey = players.filter(p=>!keys[p].includes('P2'));
  if(noKey.length < 2){
    log('Not enough no‑key players for another duel.');
    return endPhase2();
  }

  // House vote among no‑key; all active players vote
  const votePairs = simulateVote(players, noKey, 'P2');
  recordVotingMatrix(`P2 Round ${round} — House Vote`, votePairs, round, 'P2');
  let [voteWinner] = tally(votePairs, noKey);

  // Lockpick in P2: if holder lacks P2, often used to seize control
  if(lockpickHolder && !lockpickUsed && noKey.includes(lockpickHolder) && !keys[lockpickHolder].includes('P2')){
    if(Math.random() < 0.6){
      voteWinner = lockpickHolder;
      lockpickUsed = true;
      log(`${lockpickHolder} uses the Lockpick to auto‑win the vote.`);
    }
  }

  // Strategy-aware opponent selection with reason
  const candidates = noKey.filter(p=>p!==voteWinner);
  const nonAllies = candidates.filter(p=>!inAlliance(p, voteWinner));
  const allies    = candidates.filter(p=> inAlliance(p, voteWinner));

  let opponent, reason;
  if(nonAllies.length && Math.random()<0.65){
    opponent = nonAllies[Math.floor(Math.random()*nonAllies.length)];
    reason = 'chooses someone they believe they can beat';
  }else if(allies.length){
    opponent = allies[Math.floor(Math.random()*allies.length)];
    reason = 'keeps the key within their alliance';
  }else{
    opponent = candidates[Math.floor(Math.random()*candidates.length)];
    reason = 'makes a neutral pick';
  }
  log(`${voteWinner} chooses to duel ${opponent} — ${reason}.`);

  const duelWinner = Math.random() < 0.5 ? voteWinner : opponent;
  keys[duelWinner].push('P2');
  log(`${duelWinner} wins the duel and earns a Phase 2 key.`);

  evolveAlliancesAfterVote(votePairs, 'P2');
  updateProgress();
  round++;
}

function endPhase2(){
  const advancing = players.filter(p=>keys[p].includes('P2'));
  const phaseOut  = players.filter(p=>!advancing.includes(p));
  phaseOut.forEach(p=>{ if(!eliminated.includes(p)) eliminated.push(p) });
  phaseOut.forEach(p=>jury.push({name:p, phase:2}));

  players = advancing;
  log(`Phase 2 complete. Eliminated: ${phaseOut.join(', ')}`);
  round = 1; phase = 3; phase3Step = 0;
  nextRound();
}

/* ====== Phase 3 (Two-step) ====== */
let p3_voteWinner = null;
let p3_chosenAlly = null;
let p3_duelists = [];

function runPhase3(){
  if(phase3Step === 0){
    log(`Phase 3 — Final Cut: Vote step`);
    // All remaining players vote; cannot vote for self
    const votePairsRaw = simulateVote(players, players, 'P3');
    const votePairs = votePairsRaw.map(([v,to])=>{
      if(v===to){
        const choices = players.filter(p=>p!==v);
        return [v, choices[Math.floor(Math.random()*choices.length)]];
      }
      return [v,to];
    });
    recordVotingMatrix(`P3 — Final Cut Vote`, votePairs, 1, 'P3');
    let [voteWinner] = tally(votePairs, players);
    p3_voteWinner = voteWinner;
    log(`${voteWinner} wins the vote and becomes a finalist.`);

    const available = players.filter(p=>p!==voteWinner);
    // Favor an ally as chosen finalist
    const allyOpts = available.filter(p=>inAlliance(p, voteWinner));
    p3_chosenAlly = (allyOpts.length ? allyOpts : available)[Math.floor(Math.random()* (allyOpts.length?allyOpts.length:available.length))];
    log(`${voteWinner} selects ${p3_chosenAlly} to join them in the finale.`);

    // Duelists are the remaining two
    p3_duelists = players.filter(p=>p!==voteWinner && p!==p3_chosenAlly);
    log(`Next: ${p3_duelists[0]} vs ${p3_duelists[1]} duel for the last spot. Click Next to resolve.`);
    finalists = [p3_voteWinner, p3_chosenAlly];
    updateProgress();
    phase3Step = 1;
    return;
  }

  if(phase3Step === 1){
    const duelWinner = Math.random() < 0.5 ? p3_duelists[0] : p3_duelists[1];
    const duelLoser  = p3_duelists.find(p=>p!==duelWinner);
    finalists.push(duelWinner);
    if(!eliminated.includes(duelLoser)) eliminated.push(duelLoser);
    jury.push({name:duelLoser, phase:3});
    log(`${duelWinner} wins the final duel. ${duelLoser} is eliminated and joins the jury.`);
    updateProgress();

    phase = 4;
    phase3Step = 0;
    log(`Click Next to proceed to the Vault Finale.`);
  }
}

/* ====== Finale ====== */
function runFinale(){
  log(`Vault Finale — Finalists: ${finalists.join(', ')}`);

  // Each finalist starts with 3 base keys
  const finalistKeys = {};
  finalists.forEach(p => finalistKeys[p] = 3);

  // Support score by alliance overlap to guide vault choices and jury tilt
  const supportScore = {};
  finalists.forEach(f=>{
    let score = 0;
    jury.forEach(j=>{
      const cap = j.phase===1?1:j.phase===2?2:4;
      if(inAlliance(j.name, f)) score += cap;
    });
    supportScore[f] = score;
  });

  // Expectation heuristic ~ 6..12 keys total
  const expect = {};
  const maxSupport = Math.max(1, ...Object.values(supportScore));
  finalists.forEach(f=>{
    const normalized = (supportScore[f]/maxSupport);
    expect[f] = Math.round(6 + normalized * 6); // 6..12
  });

  const chosenVaults = pickUniqueVaultsForFinalists(expect);

  // Distribute exactly 16 jury keys with per-juror caps and “mostly one finalist” behavior
  const jm = distributeJuryKeysExact16(finalists, jury, finalistKeys);
  displayJuryMatrix(jm);

  // Determine winner: highest vault they can open
  const result = finalists.map(name => ({
    name,
    keys: finalistKeys[name],
    vault: chosenVaults[name]
  })).sort((a,b)=>b.vault - a.vault);

  let winner = result.find(r => r.keys >= r.vault);
  if(!winner){
    const fourth = jury.find(j=>j.phase===3)?.name || 'Fourth Place';
    log(`No finalist opened a vault. ${fourth} wins by default.`);
  }else{
    log(`${winner.name} opens the ${winner.vault}-key vault with ${winner.keys} keys and wins.`);
  }

  // Swap to Simulate Again
  endGameUI();
}

/* Unique vaults closest to expectations, no duplicates */
function pickUniqueVaultsForFinalists(expect){
  const picked = {};
  const available = vaults.slice();
  const order = Object.keys(expect).sort((a,b)=>expect[b]-expect[a]);
  order.forEach(f=>{
    let best = available[0], bestDiff = Infinity, bestIdx = 0;
    available.forEach((v,i)=>{
      const d = Math.abs(v - expect[f]);
      if(d < bestDiff){ bestDiff = d; best = v; bestIdx = i; }
    });
    picked[f] = best;
    available.splice(bestIdx, 1);
  });
  log(`Vault choices based on expectations: ${order.map(f=>`${f} → ${picked[f]}`).join(', ')}`);
  return picked;
}

/* Jury distribution that totals EXACTLY 16 keys with per-juror caps.
   Jurors usually dump keys on one finalist unless they share alliances with two. */
function distributeJuryKeysExact16(finalists, jury, finalistKeys){
  const capPool = [];
  jury.forEach(j=>{
    const cap = j.phase===1?1:j.phase===2?2:4;
    for(let i=0;i<cap;i++) capPool.push(j.name);
  });

  shuffle(capPool);
  const draws = capPool.slice(0,16);

  const jm = {};
  jury.forEach(j=>{ jm[j.name] = Object.fromEntries(finalists.map(f=>[f,0])) });

  draws.forEach(jName=>{
    const j = jury.find(x=>x.name===jName);
    const shared = finalists.filter(f=>inAlliance(j.name, f));
    let target;
    if(shared.length === 1){
      target = shared[0]; // give to ally
    }else if(shared.length === 2){
      // small bias to perceived front-runner
      target = Math.random()<0.6 ? finalists.slice().sort((a,b)=>expectedSupport(b)-expectedSupport(a))[0]
                                 : finalists[Math.floor(Math.random()*finalists.length)];
    }else{
      target = Math.random()<0.65 ? finalists.slice().sort((a,b)=>expectedSupport(b)-expectedSupport(a))[0]
                                  : finalists[Math.floor(Math.random()*finalists.length)];
    }
    jm[jName][target] += 1;
    finalistKeys[target] += 1;
  });

  return jm;

  function expectedSupport(f){
    let s = 0;
    jury.forEach(j=>{
      const cap = j.phase===1?1:j.phase===2?2:4;
      if(inAlliance(j.name, f)) s += cap;
    });
    return s;
  }
}

/* ====== UI: Jury Matrix ====== */
function displayJuryMatrix(matrix){
  const area = document.getElementById('juryMatrix');
  if(!finalists.length){ area.innerHTML = ''; return }
  let html = `<table><tr><th>Juror</th>${finalists.map(f=>`<th>${f}</th>`).join('')}<th>Total</th></tr>`;
  let totalGiven = 0;
  for(const juror in matrix){
    let sum = 0;
    html += `<tr><td>${juror}</td>`;
    finalists.forEach(f=>{
      const v = matrix[juror][f]||0;
      sum += v; totalGiven += v;
      html += `<td>${v}</td>`;
    });
    html += `<td>${sum}</td></tr>`;
  }
  html += `</table>`;
  html += `<div class="hint">Total jury keys distributed: <strong>${totalGiven}</strong> (should be exactly 16)</div>`;
  area.innerHTML = html;
}

/* ====== Wire up ====== */
updateProgress();

</script>
</body>
</html>