<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>The Vault Simulator</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    .log { white-space: pre-wrap; background: #f8f8f8; padding: 10px; border: 1px solid #ccc; margin: 20px 0; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
    td, th { border: 1px solid #999; padding: 5px 10px; text-align: center; }
    .highlight { font-weight: bold; color: #d42; }
    .keyholder { background-color: #ffd; font-weight: bold; }
  </style>
</head>
<body>
  <h1>The Vault Simulator</h1>
  <p>Enter 12 player names (one per line):</p>
  <textarea id="playerInput" rows="12" cols="30" placeholder="Player 1&#10;Player 2&#10;..."></textarea><br>
  <button onclick="startGame()" id="startBtn">Start Game</button>
  <button onclick="runRound()" id="nextBtn" style="display:none;">Run Next Round</button>

  <div id="log" class="log"></div>
  <div id="votingTable"></div>
  <div id="progressTable"></div>

  <script>
let players = [];
let phase = 1;
let round = 1;
let lockpickHolder = null;
let alliances = {};
let usedLockpicks = [];
let jury = [];
let eliminated = [];
let finalists = [];
let vaults = [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22];
let phase2Rounds = 1;

function startGame() {
  const names = document.getElementById("playerInput").value.trim().split("\n").map(n => n.trim());
  if (names.length !== 12) {
    alert("Enter exactly 12 player names.");
    return;
  }
  players = names.map(name => ({
    name,
    key1: false,
    key2: false,
    key3: false,
    eliminated: false,
    alliance: [],
    votes: [],
    totalKeys: 0,
    bonusKeys: 0,
    vault: null
  }));
  createAlliances();
  document.getElementById("startBtn").style.display = "none";
  document.getElementById("nextBtn").style.display = "inline-block";
  logAlliances();
  runRound();
}

function createAlliances() {
  const names = ["Lockgirls", "Key Club", "Hidden Alliance"];
  for (let name of names) {
    let members = shuffle(players).slice(0, Math.floor(Math.random() * 4) + 2);
    for (let p of members) {
      if (!p.alliance.includes(name)) p.alliance.push(name);
    }
    alliances[name] = members.map(m => m.name);
  }
}

function logAlliances() {
  let text = "üîê Alliances:\n";
  for (let p of players) {
    if (p.alliance.length > 0) {
      text += `- ${p.name}: ${p.alliance.join(", ")}\n`;
    }
  }
  log(text);
}

function runRound() {
  clearLog();
  log(`üîÑ Phase ${phase} ‚Äì Round ${round}`);
  if (phase === 1) runPhase1Round();
  else if (phase === 2) runPhase2Round();
  else if (phase === 3) runPhase3();
  else if (phase === 4) runFinale();
}

function clearLog() {
  document.getElementById("log").innerText = "";
  document.getElementById("votingTable").innerHTML = "";
}

function log(text) {
  document.getElementById("log").innerText += text + "\n";
}

function shuffle(arr) {
  return [...arr].sort(() => Math.random() - 0.5);
}

function runPhase1Round() {
  const eligible = players.filter(p => !p.key1);
  const drawn = shuffle(eligible).slice(0, 4);
  log("üé≤ Drawn: " + drawn.map(p => p.name).join(", "));

  // Lockpick
  if (!lockpickHolder && Math.random() < 0.33) {
    lockpickHolder = drawn[Math.floor(Math.random() * drawn.length)];
    log("üóùÔ∏è Lockpick found by " + lockpickHolder.name);
  }

  let voteWinner = drawn[Math.floor(Math.random() * drawn.length)];
  if (lockpickHolder && drawn.includes(lockpickHolder)) {
    voteWinner = lockpickHolder;
    log(`üîê ${lockpickHolder.name} uses the Lockpick to override the vote.`);
    lockpickHolder = null;
  } else {
    log(`üó≥Ô∏è ${voteWinner.name} wins the vote key.`);
  }
  voteWinner.key1 = true;
  voteWinner.totalKeys++;

  const challengers = drawn.filter(p => p !== voteWinner);
  const challengeWinner = challengers[Math.floor(Math.random() * challengers.length)];
  challengeWinner.key1 = true;
  challengeWinner.totalKeys++;
  log(`üèÅ ${challengeWinner.name} wins the challenge key.`);

  updateVotingTable();

  round++;
  if (round > 4) {
    phase = 2;
    round = 1;
    lockpickHolder = null;
    log("‚û°Ô∏è Phase 2 begins.");
  }
}

function updateVotingTable() {
  let html = "<table><tr><th>Player</th><th>Key 1</th><th>Key 2</th><th>Total</th></tr>";
  for (let p of players) {
    html += `<tr${p.key1 || p.key2 ? ' class="keyholder"' : ''}>
      <td>${p.name}</td>
      <td>${p.key1 ? "‚úÖ" : ""}</td>
      <td>${p.key2 ? "‚úÖ" : ""}</td>
      <td>${p.totalKeys}</td>
    </tr>`;
  }
  html += "</table>";
  document.getElementById("votingTable").innerHTML = html;
}

function runPhase2Round() {
  const eligible = players.filter(p => !p.key2 && !p.eliminated);
  if (phase2Rounds > 4 || eligible.length <= 1) {
    log("‚úÖ Phase 2 complete. Moving to Phase 3.");
    phase = 3;
    round = 1;
    return;
  }

  // Voting
  const votes = {};
  for (let voter of players.filter(p => !voter.eliminated)) {
    const choices = eligible.filter(p => p.name !== voter.name);
    let voteTarget = pickAllianceTarget(voter, choices) || choices[Math.floor(Math.random() * choices.length)];
    votes[voteTarget.name] = (votes[voteTarget.name] || 0) + 1;
  }

  let [voteWinnerName] = Object.entries(votes).sort((a,b) => b[1] - a[1])[0];
  let voteWinner = eligible.find(p => p.name === voteWinnerName);
  log("üó≥Ô∏è Vote winner: " + voteWinner.name);

  if (lockpickHolder && !voteWinner.key2) {
    log("üîê Lockpick used by " + lockpickHolder.name + " to override vote.");
    voteWinner = lockpickHolder;
    lockpickHolder = null;
  }

  const duelOptions = eligible.filter(p => p !== voteWinner);
  const opponent = pickDuelOpponent(voteWinner, duelOptions);
  log(`‚öîÔ∏è ${voteWinner.name} chooses to duel ${opponent.name}`);

  const winner = Math.random() < 0.5 ? voteWinner : opponent;
  winner.key2 = true;
  winner.totalKeys++;
  log(`üèÖ ${winner.name} wins the duel and earns a key.`);

  updateVotingTable();
  phase2Rounds++;
  round++;
}

function pickAllianceTarget(voter, choices) {
  const allies = choices.filter(c =>
    voter.alliance.some(a => c.alliance.includes(a))
  );
  return allies.length ? allies[Math.floor(Math.random() * allies.length)] : null;
}

function pickDuelOpponent(chooser, options) {
  const allies = options.filter(p =>
    p.alliance.some(a => chooser.alliance.includes(a))
  );
  if (allies.length) return allies[Math.floor(Math.random() * allies.length)];
  return options[Math.floor(Math.random() * options.length)];
}

function runPhase3() {
  const final4 = players.filter(p => !p.eliminated && p.key1 && p.key2);
  if (final4.length !== 4) {
    log("‚ö†Ô∏è Error: Phase 3 requires 4 players.");
    return;
  }

  const votes = {};
  for (let voter of final4) {
    const choices = final4.filter(p => p.name !== voter.name);
    let voteTarget = pickAllianceTarget(voter, choices) || choices[Math.floor(Math.random() * choices.length)];
    votes[voteTarget.name] = (votes[voteTarget.name] || 0) + 1;
  }

  let sorted = Object.entries(votes).sort((a,b) => b[1] - a[1]);
  let [top1, top2] = sorted;

  let autoFinalist, finalist2, challengePlayers;

  if (!top2 || top1[1] > top2[1]) {
    autoFinalist = final4.find(p => p.name === top1[0]);
    const pickable = final4.filter(p => p !== autoFinalist);
    finalist2 = pickable[Math.floor(Math.random() * pickable.length)];
    challengePlayers = pickable.filter(p => p !== finalist2);
    log(`üèÜ ${autoFinalist.name} wins the vote and picks ${finalist2.name}`);
  } else {
    const tied = [top1[0], top2[0]];
    challengePlayers = final4.filter(p => tied.includes(p.name));
    const untied = final4.filter(p => !tied.includes(p.name));
    [autoFinalist, finalist2] = untied;
    log(`ü§ù Tie. ${autoFinalist.name} & ${finalist2.name} advance.`);
  }

  const challengeWinner = challengePlayers[Math.floor(Math.random() * challengePlayers.length)];
  log(`üèÅ ${challengePlayers.map(p=>p.name).join(" vs ")} ‚Äî ${challengeWinner.name} wins the challenge`);

  finalists = [autoFinalist, finalist2, challengeWinner];
  players.forEach(p => {
    if (!finalists.includes(p)) {
      p.eliminated = true;
      jury.push(p);
    }
  });

  phase = 4;
  round = 1;
  runRound();
}

function runFinale() {
  log("üîê Vault Finale begins.");
  for (let f of finalists) {
    const estimate = f.totalKeys + 3;
    const safeRange = vaults.filter(v => v <= estimate + 2 && v >= estimate - 1);
    f.vault = safeRange[Math.floor(Math.random() * safeRange.length)] || vaults[0];
    log(`${f.name} selects vault: ${f.vault}`);
  }

  for (let j of jury) {
    const keys = j.key2 ? 2 : 1;
    let target = finalists[Math.floor(Math.random() * finalists.length)];
    if (j.alliance.length && Math.random() < 0.6) {
      const aligned = finalists.filter(f => f.alliance.some(a => j.alliance.includes(a)));
      if (aligned.length) target = aligned[Math.floor(Math.random() * aligned.length)];
    }
    target.bonusKeys += keys;
    log(`${j.name} gives ${keys} keys to ${target.name}`);
  }

  for (let f of finalists) {
    f.totalFinalKeys = 3 + f.bonusKeys;
    log(`${f.name} ends with ${f.totalFinalKeys} keys (needs ${f.vault})`);
  }

  const unlocked = finalists.filter(f => f.totalFinalKeys >= f.vault);
  if (unlocked.length) {
    const winner = unlocked.sort((a,b) => b.vault - a.vault)[0];
    log(`üëë ${winner.name} wins by opening the highest vault.`);
  } else {
    log(`üí• No vaults open. 4th place wins by default.`);
  }

  showSummary();
}

function showSummary() {
  let html = "<h2>üìä Game Summary</h2><table><tr><th>Player</th><th>Key 1</th><th>Key 2</th><th>Vault</th><th>Total Keys</th></tr>";
  const order = [...players].sort((a,b) => (b.totalFinalKeys || b.totalKeys) - (a.totalFinalKeys || a.totalKeys));
  for (let p of order) {
    html += `<tr>
      <td>${p.name}</td>
      <td>${p.key1 ? "‚úÖ" : ""}</td>
      <td>${p.key2 ? "‚úÖ" : ""}</td>
      <td>${p.vault || ""}</td>
      <td>${p.totalFinalKeys || p.totalKeys}</td>
    </tr>`;
  }
  html += "</table>";
  document.getElementById("progressTable").innerHTML = html;
}
  </script>
</body>
</html>

