<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Vault — ALT (13 Players)</title>
<style>
  :root{--bg:#0f1115;--panel:#161a22;--panel2:#1c2130;--text:#e5e7eb;--sub:#aeb4c0;--border:#2b3340;--muted:#232836;--accent:#7aa2ff}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  h1{margin:0;font-size:20px} h2{margin:0 0 8px;font-size:16px} h3{margin:0 0 6px;font-size:15px}
  textarea,button,input,select{width:100%;padding:12px;margin-top:8px;border-radius:10px;border:1px solid var(--border);background:var(--panel2);color:var(--text);font-size:16px}
  button{cursor:pointer} button:disabled{opacity:.6;cursor:not-allowed}
  .app{display:grid;grid-template-columns:1fr;gap:12px;padding:12px}
  @media(min-width:960px){.app{grid-template-columns:320px 1fr}}
  .box{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  pre{white-space:pre-wrap;background:#0b0d12;border:1px solid var(--border);border-radius:10px;padding:10px;min-height:180px;max-height:280px;overflow:auto}
  table{width:100%;border-collapse:collapse;font-size:14px}
  th,td{border:1px solid var(--border);padding:6px;text-align:center}
  th{background:#1b2130}
  .chip{display:flex;align-items:center;gap:8px;border:1px solid var(--border);padding:6px 8px;border-radius:10px;margin:6px 0}
  .avatar{width:22px;height:22px;border-radius:6px;object-fit:cover;background:#2a3040;display:inline-flex;align-items:center;justify-content:center;font-size:11px}
  .hint{font-size:13px;color:var(--sub)}
  .count{font-size:13px;color:var(--sub);margin-top:4px}
</style>
</head>
<body>
<div class="app">
  <!-- Left / Controls -->
  <div class="box">
    <h1>ALT VAULT (13P) — Season Setup</h1>
    <label><b>Enter 13 Players (one per line)</b></label>
    <textarea id="playerInput" rows="13"></textarea>
    <div class="count" id="nameCount">0 / 13</div>
    <div class="row">
      <button id="startBtn" disabled>Start Season</button>
      <button id="nextBtn" style="display:none;">Next Scene ▶</button>
    </div>
    <div class="hint">Season controls lock/hide after Start. Mobile‑friendly, dark UI.</div>
  </div>

  <!-- Right / Main -->
  <div class="box">
    <h2>Round Events (Scene Feed)</h2>
    <pre id="sceneFeed">(Ready) Fill names or use the defaults, then Start Season.</pre>
  </div>

  <div class="row">
    <div class="box" style="flex:1 1 320px">
      <h2>Cast Photos & Colors</h2>
      <div id="castGrid"></div>
    </div>
    <div class="box" style="flex:2 1 420px">
      <h2>Preseason: Stats & Relationships</h2>
      <div class="row">
        <div style="flex:1 1 260px">
          <h3>Player Stats</h3>
          <div id="statsTable"></div>
          <div class="row">
            <button id="presetBalanced">Balanced</button>
            <button id="presetSocial">Social‑heavy</button>
            <button id="presetChallenge">Challenge‑heavy</button>
            <button id="presetRandom">Randomize All</button>
            <button id="applyStats">Apply Stats</button>
          </div>
          <div class="hint">Range 1–15 (default 8/8). Hidden after Start.</div>
        </div>
        <div style="flex:1 1 260px">
          <h3>Relationships (−5…+5)</h3>
          <div class="row" style="align-items:center">
            <label>Focus</label>
            <select id="relFocus"></select>
          </div>
          <div id="relEditor" style="margin-top:6px"></div>
          <div class="row" style="margin-top:6px">
            <button id="relSave">Save (All)</button>
            <button id="relRandFocus">Randomize Focus</button>
            <button id="relClearFocus">Clear Focus</button>
            <button id="relRandAll">Randomize All</button>
            <button id="relClearAll">Clear All</button>
          </div>
          <div class="hint">Symmetric: setting A→B also sets B→A. Hidden after Start.</div>
        </div>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="box" style="flex:1 1 320px">
      <h2>Alliances</h2>
      <div id="alliancesList"></div>
    </div>
    <div class="box" style="flex:1 1 320px">
      <h2>Progress</h2>
      <div id="progressChart"></div>
    </div>
  </div>

  <div class="row">
    <div class="box" style="flex:1 1 320px">
      <h2>Voting Matrix</h2>
      <div id="votingMatrix"></div>
      <div class="hint">Order: Active → P3 elim → P2 elim → P1 elim.</div>
    </div>
    <div class="box" style="flex:1 1 320px">
      <h2>Relationships (Live)</h2>
      <div id="relsLive"></div>
    </div>
  </div>

  <div class="box">
    <h2>Jury Key Distribution</h2>
    <div id="juryMatrix"></div>
  </div>
</div>

<script>
/* ====== State ====== */
let players=[], initialOrder=[], phase=1, round=1, gameStarted=false;
let alliances={}, keys={}, jury=[], finalists=[], eliminated=[];
let stats={}, rel={}, cast={};
let voteColumns=[], wins={}, losses={}, keysEarned={}, votesGiven={}, votesReceived={};
let lockpickFound=false, lockpickUsed=false, lockpickHolder=null;
let episodes=[], currentEpisode=null, sceneQueue=[];

/* ====== Tunables (kept from your build) ====== */
const ALPHA_SOCIAL=0.65, VOTE_JITTER_MIN=0.8, VOTE_JITTER_MAX=1.2, ALLY_PREFERENCE_RATE=0.6;
const REL_SCALE=0.08, REL_MIN_FACTOR=0.3, LOGIT_K=0.7, WIN_CLAMP_LO=0.15, WIN_CLAMP_HI=0.85;

/* ====== Helpers ====== */
const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
const shuffle=a=>a.slice().sort(()=>Math.random()-0.5);
const initials=n=>(n.split(/\s+/).map(x=>x[0]).join('')||'?').slice(0,2).toUpperCase();
const getRel=(a,b)=> (rel[a]?.[b] ?? 0);
const setRel=(a,b,v)=>{ rel[a]=rel[a]||{}; rel[b]=rel[b]||{}; rel[a][b]=v; rel[b][a]=v; };
const inAlliance=(a,b)=> Object.values(alliances).some(L=>L.includes(a)&&L.includes(b));
const relFactor=(voter,target)=> clamp(1+REL_SCALE*getRel(voter,target), REL_MIN_FACTOR, 2);
function weighted(arr, wfn){ const w=arr.map(wfn), sum=w.reduce((a,b)=>a+b,0); let r=Math.random()*sum; for(let i=0;i<arr.length;i++){ r-=w[i]; if(r<=0) return arr[i]; } return arr[arr.length-1]; }
function duelWinProb(a,b){ const da=stats[a]?.challenge||8, db=stats[b]?.challenge||8; const p=1/(1+Math.exp(-LOGIT_K*(da-db))); return clamp(p,WIN_CLAMP_LO,WIN_CLAMP_HI); }

/* ====== DOM refs ====== */
const playerInput=document.getElementById('playerInput');
const nameCount=document.getElementById('nameCount');
const startBtn=document.getElementById('startBtn');
const nextBtn=document.getElementById('nextBtn');
const sceneFeed=document.getElementById('sceneFeed');
const castGrid=document.getElementById('castGrid');
const statsTable=document.getElementById('statsTable');
const relFocusSel=document.getElementById('relFocus');
const relEditorDiv=document.getElementById('relEditor');

/* ====== Live name parsing + Start gating ====== */
function parseNames(){
  const raw = playerInput.value.split('\n').map(s=>s.trim()).filter(Boolean);
  // de-dup while preserving order
  const seen=new Set(), out=[];
  raw.forEach(n=>{ if(!seen.has(n)){ seen.add(n); out.push(n); } });
  nameCount.textContent = `${out.length} / 13`;
  startBtn.disabled = (out.length!==13) || gameStarted;
  return out;
}

/* ====== Preseason builders ====== */
function buildCastGrid(names){
  if(!names.length){ castGrid.innerHTML=''; return; }
  if(!Object.keys(cast).length){
    const pal=["#7aa2ff","#ffa07a","#a3e635","#f472b6","#facc15","#34d399","#60a5fa","#f59e0b","#22d3ee","#c084fc","#fb7185","#93c5fd","#38bdf8"];
    names.forEach((n,i)=> cast[n]={photo:'',color:pal[i%pal.length]});
  } else {
    // ensure new names get defaults
    names.forEach((n,i)=>{ if(!cast[n]) cast[n]={photo:'',color:'#7aa2ff'}; });
  }
  castGrid.innerHTML = names.map(n=>{
    const c=cast[n]; return `<div class="chip">
      ${c.photo?`<img class="avatar" src="${c.photo}">`:`<div class="avatar" style="background:${c.color}">${initials(n)}</div>`}
      <div style="flex:1">${n}<input type="url" class="photoUrl" data-name="${n}" placeholder="Image URL" value="${c.photo}"></div>
      <input type="color" class="color" data-name="${n}" value="${c.color}">
    </div>`;
  }).join('');
  castGrid.querySelectorAll('.photoUrl').forEach(inp=> inp.oninput=()=>{ cast[inp.dataset.name].photo=inp.value.trim(); buildCastGrid(names); });
  castGrid.querySelectorAll('.color').forEach(inp=> inp.oninput=()=>{ cast[inp.dataset.name].color=inp.value; buildCastGrid(names); });
}
function buildStatsTable(names){
  names.forEach(n=>{ stats[n]=stats[n]||{social:8,challenge:8}; });
  statsTable.innerHTML = `<table><tr><th>Player</th><th>Social</th><th>Challenge</th></tr>${
    names.map(n=>{
      const s=stats[n].social, c=stats[n].challenge;
      return `<tr><td>${n}</td>
        <td><input type="number" class="st" data-name="${n}" data-field="social" min="1" max="15" value="${s}"></td>
        <td><input type="number" class="st" data-name="${n}" data-field="challenge" min="1" max="15" value="${c}"></td></tr>`;
    }).join('')
  }</table>`;
}
function applyStatsFromInputs(){
  statsTable.querySelectorAll('.st').forEach(inp=>{
    const n=inp.dataset.name, f=inp.dataset.field, v=clamp(parseInt(inp.value||'8',10),1,15);
    stats[n][f]=v;
  });
}
document.getElementById('applyStats').onclick=applyStatsFromInputs;
document.getElementById('presetBalanced').onclick=()=>presetStats('balanced');
document.getElementById('presetSocial').onclick=()=>presetStats('social');
document.getElementById('presetChallenge').onclick=()=>presetStats('challenge');
document.getElementById('presetRandom').onclick=()=>presetStats('random');
function presetStats(which){
  const names=parseNames();
  names.forEach(n=>{
    if(which==='balanced') stats[n]={social:8,challenge:8};
    if(which==='social')   stats[n]={social:12,challenge:8};
    if(which==='challenge')stats[n]={social:8,challenge:12};
    if(which==='random')   stats[n]={social:1+Math.floor(Math.random()*15),challenge:1+Math.floor(Math.random()*15)};
  });
  buildStatsTable(names);
}
function buildRelFocusList(names){
  relFocusSel.innerHTML = names.map(n=>`<option>${n}</option>`).join('');
  if(names.length) renderRelEditorFor(names[0], names);
}
relFocusSel.onchange=()=> renderRelEditorFor(relFocusSel.value, parseNames());
function renderRelEditorFor(focus, names){
  const others = names.filter(n=>n!==focus);
  relEditorDiv.innerHTML = `<table><tr><th>Player</th><th>Score</th></tr>${
    others.map(n=>`<tr><td>${n}</td><td><input type="number" class="relSpin" data-focus="${focus}" data-target="${n}" min="-5" max="5" step="1" value="${getRel(focus,n)}"></td></tr>`).join('')
  }</table>`;
  relEditorDiv.querySelectorAll('.relSpin').forEach(sp=> sp.oninput=()=>{ const f=sp.dataset.focus,t=sp.dataset.target; setRel(f,t,clamp(parseInt(sp.value||'0',10),-5,5)); renderRelsLive(); });
}
document.getElementById('relSave').onclick=()=>{
  relEditorDiv.querySelectorAll('.relSpin').forEach(sp=>{ const f=sp.dataset.focus,t=sp.dataset.target; setRel(f,t,clamp(parseInt(sp.value||'0',10),-5,5)); });
  const names=parseNames(); names.forEach(a=>names.forEach(b=>{ if(a!==b) setRel(a,b,getRel(a,b)); }));
  addScene('Saved all preseason relationships.'); renderRelsLive();
};
document.getElementById('relRandFocus').onclick=()=>{
  const names=parseNames(); const f=relFocusSel.value; relEditorDiv.querySelectorAll('.relSpin').forEach(sp=>{ const t=sp.dataset.target; const v=Math.floor(-2+Math.random()*5); setRel(f,t,v); sp.value=v; }); addScene('Randomized focus relationships.'); renderRelsLive();
};
document.getElementById('relClearFocus').onclick=()=>{
  const f=relFocusSel.value; relEditorDiv.querySelectorAll('.relSpin').forEach(sp=>{ const t=sp.dataset.target; setRel(f,t,0); sp.value=0; }); addScene('Cleared focus relationships.'); renderRelsLive();
};
document.getElementById('relRandAll').onclick=()=>{
  const names=parseNames(); for(let i=0;i<names.length;i++)for(let j=i+1;j<names.length;j++){ setRel(names[i],names[j], Math.floor(-2+Math.random()*5)); }
  renderRelEditorFor(relFocusSel.value||names[0], names); addScene('Randomized all relationships.'); renderRelsLive();
};
document.getElementById('relClearAll').onclick=()=>{
  const names=parseNames(); for(let i=0;i<names.length;i++)for(let j=i+1;j<names.length;j++){ setRel(names[i],names[j],0); }
  renderRelEditorFor(relFocusSel.value||names[0], names); addScene('Cleared all relationships.'); renderRelsLive();
};

/* ====== UI glue ====== */
playerInput.addEventListener('input', refreshPreseason);
function refreshPreseason(){
  const names=parseNames();
  // make sure stats/rel/cast exist for these names
  names.forEach(n=>{ stats[n]=stats[n]||{social:8,challenge:8}; rel[n]=rel[n]||{}; cast[n]=cast[n]||{photo:'',color:'#7aa2ff'}; });
  buildCastGrid(names);
  buildStatsTable(names);
  buildRelFocusList(names);
  renderRelsLive();
}

/* ====== Episode / Scene ====== */
function ensureEpisode(){ const tag=`Phase ${phase} R${round}`; if(!currentEpisode || currentEpisode._tag!==tag){ currentEpisode={title:tag,_tag:tag,linesViewed:0,total:0}; episodes.push(currentEpisode); sceneQueue.length=0; showLine('(Ready) Tap “Next Scene”.'); } }
function addScene(line){ sceneQueue.push(line); currentEpisode && currentEpisode.total++; }
function showLine(text){ sceneFeed.textContent=text; }

/* ====== Voting / Tallies ====== */
function simulateVote(voters, eligible){
  const out=[];
  voters.forEach(v=>{
    const choices=eligible.filter(p=>p!==v);
    const al=choices.filter(c=>inAlliance(v,c));
    const prefer = al.length>0 && Math.random()<ALLY_PREFERENCE_RATE;
    const pool = prefer? al : choices;
    const baseAlpha = prefer? ALPHA_SOCIAL : 0.5*ALPHA_SOCIAL;
    const pick = pool.length? weighted(pool, c=>{
      const s=(stats[c]?.social||8);
      const j=VOTE_JITTER_MIN + Math.random()*(VOTE_JITTER_MAX - VOTE_JITTER_MIN);
      return Math.pow(s,baseAlpha)*j*relFactor(v,c);
    }):null;
    if(pick){ out.push([v,pick]); votesGiven[v]=(votesGiven[v]||0)+1; votesReceived[pick]=(votesReceived[pick]||0)+1; }
  });
  return out;
}
function tally(votePairs, eligible){
  const counts={}; eligible.forEach(p=>counts[p]=0);
  votePairs.forEach(([_,to])=>{ if(counts[to]!=null) counts[to]++; });
  const max=Math.max(...Object.values(counts)); const tied=Object.keys(counts).filter(p=>counts[p]===max);
  return [tied[0], tied, counts];
}
function addVoteColumn(label, voters, pairs, result){
  const values={}; voters.forEach(v=>values[v]='—'); eliminated.forEach(v=>{ if(values[v]==null) values[v]='—'; });
  pairs.forEach(([v,to])=> values[v]=to);
  voteColumns.push({label,values,result}); renderVoteMatrix();
}
function renderVoteMatrix(){
  const wrap=document.getElementById('votingMatrix');
  let html='<div style="overflow:auto"><table><thead><tr><th>Voter</th>';
  voteColumns.forEach(c=> html+=`<th>${c.label}</th>`); html+='</tr></thead><tbody>';
  const order=[...players, ...eliminated.filter(p=>!players.includes(p)).sort((a,b)=> (elimPhase(b)-elimPhase(a)))];
  function elimPhase(n){ const x=jury.find(j=>j.name===n); return x?x.phase:99; }
  order.forEach(v=>{ html+=`<tr><td>${v}</td>`; voteColumns.forEach(c=> html+=`<td>${c.values[v]||'—'}</td>`); html+='</tr>'; });
  html+='<tr><th>Result</th>'; voteColumns.forEach(c=> html+=`<th>${c.result||''}</th>`); html+='</tr></tbody></table></div>';
  wrap.innerHTML=html;
}

/* ====== Social / Live relationships ====== */
function renderRelsLive(){
  const names=parseNames(); if(!names.length){ document.getElementById('relsLive').innerHTML=''; return; }
  const pairs=[], seen={};
  names.forEach(a=>names.forEach(b=>{ if(a===b) return; const k=[a,b].sort().join('|'); if(seen[k]) return; seen[k]=1; pairs.push({a,b,v:getRel(a,b)}); }));
  pairs.sort((x,y)=>Math.abs(y.v)-Math.abs(x.v));
  const bonds=pairs.filter(p=>p.v>0).slice(0,6), feuds=pairs.filter(p=>p.v<0).slice(0,6);
  document.getElementById('relsLive').innerHTML=
    `<div><strong>Bonds</strong><br/>${bonds.length?bonds.map(p=>`${p.a} ↔ ${p.b} (+${p.v})`).join('<br/>'):'<span class="hint">None</span>'}
    <hr style="border-color:var(--border)"><strong>Tensions</strong><br/>${feuds.length?feuds.map(p=>`${p.a} ↔ ${p.b} (${p.v})`).join('<br/>'):'<span class="hint">None</span>'}</div>`;
}

/* ====== Alliances & Progress (simple preset + table) ====== */
function generateAlliances(){
  alliances={A:[],B:[],C:[],D:[]};
  const sh=shuffle(players);
  sh.forEach((p,i)=> alliances[['A','B','C','D'][i%4]].push(p));
  const box=document.getElementById('alliancesList');
  box.innerHTML = Object.entries(alliances).map(([k,v])=>`<div><b>${k}</b>: ${v.join(', ')}</div>`).join('');
}
function updateProgress(){
  const chart=document.getElementById('progressChart');
  const everyone=players.concat(eliminated.filter(p=>!players.includes(p)));
  chart.innerHTML = `<table><tr><th>Player</th><th>P1</th><th>P2</th><th>Final</th><th>W</th><th>L</th></tr>${
    everyone.map(p=>{
      const p1=(keys[p]||[]).includes('P1')?'✔':'—', p2=(keys[p]||[]).includes('P2')?'✔':'—', fin=(finalists.includes(p)?'✔':'—');
      return `<tr><td>${p}</td><td>${p1}</td><td>${p2}</td><td>${fin}</td><td>${wins[p]||0}</td><td>${losses[p]||0}</td></tr>`;
    }).join('')
  }</table>`;
}

/* ====== Game flow (ALT rules condensed; same as prior but trimmed here) ====== */
function progressGame(){
  updateProgress(); renderVoteMatrix();
  if(phase===1) return runPhase1();
  if(phase===2) return runPhase2();
  if(phase===3) return runPhase3();
  if(phase===4) return runFinale();
}

/* ---- Phase 1 (implements your tie logic) ---- */
let p1_lastChanceDone=false;
function runPhase1(){
  const p1Count=Object.values(keys).reduce((a,k)=>a+((k||[]).includes('P1')?1:0),0);
  if(p1Count>=8){
    if(!p1_lastChanceDone){
      ensureEpisode();
      const group = players.filter(p=>!(keys[p]||[]).includes('P1')); // 5
      const voters = group.slice();
      addScene(`P1 Last Chance Vote among: ${group.join(', ')}`);
      const v1=simulateVote(voters, group); let [w,tied]=tally(v1, group);
      addVoteColumn('P1 R5 (vote)', voters, v1, tied.length===1?w:('TIE:'+tied.join('=')));
      // with 5, a revote among tied (tied sit) will break; loop once just in case
      if(tied.length>1){
        const rv=voters.filter(v=>!tied.includes(v));
        const v2=simulateVote(rv, tied); let [w2,t2]=tally(v2, tied);
        addVoteColumn('P1 R5 (revote)', rv, v2, t2.length===1?w2:('TIE:'+t2.join('=')));
        w = (t2.length===1? w2 : tied[Math.floor(Math.random()*tied.length)]);
      }
      addScene(`${w} survives and receives a P1 key.`);
      ensureKeyBag(); keys[w].push('P1'); wins[w]=(wins[w]||0)+1;
      const outs=group.filter(p=>p!==w); outs.forEach(p=>{ eliminated.push(p); jury.push({name:p,phase:1}); });
      players=players.filter(p=>!outs.includes(p)); p1_lastChanceDone=true; updateProgress(); return;
    } else { addScene('Phase 1 complete. Advancing: '+players.join(', ')); phase=2; round=1; return; }
  }

  ensureEpisode();
  const noKey=players.filter(p=>!(keys[p]||[]).includes('P1'));
  const drawn = (round===4)? (noKey.length>=7? noKey.slice(0,7): shuffle(noKey).slice(0,Math.min(6,noKey.length)))
                           : shuffle(noKey).slice(0,Math.min(6,noKey.length));
  addScene(`P1 R${round}: Drawn → ${drawn.join(', ')}`);

  // All 13 vote among drawn
  const pairs = simulateVote(players, drawn);
  let [winner,tied] = tally(pairs, drawn);
  addVoteColumn(`P1 R${round} (vote)`, players, pairs, tied.length===1?winner:('TIE:'+tied.join('=')));

  if(tied.length===1){
    // vote key to winner
    ensureKeyBag(); keys[winner].push('P1'); wins[winner]=(wins[winner]||0)+1;
    addScene(`${winner} wins the Vote Key and sits out the challenge.`);
    // challenge among remaining drawn without P1
    const chall = drawn.filter(p=>p!==winner && !((keys[p]||[]).includes('P1')));
    if(chall.length){
      const cw = weighted(chall, n=>(stats[n]?.challenge||8)*(0.85+Math.random()*0.3));
      keys[cw].push('P1'); wins[cw]=(wins[cw]||0)+1; addScene(`Challenge: ${chall.join(', ')} → ${cw} wins the Challenge Key.`);
      chall.filter(x=>x!==cw).forEach(l=>losses[l]=(losses[l]||0)+1);
    }
  } else {
    // revote among tied (tied don’t vote)
    const rv = players.filter(v=>!tied.includes(v));
    const revPairs = simulateVote(rv, tied);
    const [rvw, tied2] = tally(revPairs, tied);
    addVoteColumn(`P1 R${round} (revote)`, rv, revPairs, tied2.length===1?rvw:('TIE:'+tied2.join('=')));

    if(tied2.length===1){
      keys[rvw]=keys[rvw]||[]; keys[rvw].push('P1'); wins[rvw]=(wins[rvw]||0)+1;
      addScene(`Revote breaks: ${rvw} takes the Vote Key and sits out.`);
      const chall = drawn.filter(p=>p!==rvw && !((keys[p]||[]).includes('P1')));
      if(chall.length){
        const cw=weighted(chall, n=>(stats[n]?.challenge||8)*(0.85+Math.random()*0.3));
        keys[cw].push('P1'); wins[cw]=(wins[cw]||0)+1; addScene(`Challenge: ${chall.join(', ')} → ${cw} wins the Challenge Key.`);
        chall.filter(x=>x!==cw).forEach(l=>losses[l]=(losses[l]||0)+1);
      }
    } else {
      // still tied → ALL drawn run challenge; winner must give vote key to someone in tie (not themselves)
      const cw = weighted(drawn, n=>(stats[n]?.challenge||8)*(0.85+Math.random()*0.3));
      keys[cw]=keys[cw]||[]; keys[cw].push('P1'); wins[cw]=(wins[cw]||0)+1;
      const candidates=tied.filter(x=>x!==cw).length? tied.filter(x=>x!==cw):tied.slice();
      const give = weighted(candidates, n=> (stats[n]?.social||8)*(0.9+Math.random()*0.2));
      keys[give]=keys[give]||[]; keys[give].push('P1'); wins[give]=(wins[give]||0)+1;
      addScene(`Revote still tied → Challenge winner ${cw} keeps Challenge Key and awards Vote Key to ${give}.`);
      drawn.filter(x=>x!==cw).forEach(l=>losses[l]=(losses[l]||0)+1);
    }
  }
  round++; updateProgress();
}

/* ---- Phase 2 / 3 / Finale (same logic you approved; trimmed for space) ---- */
function runPhase2(){ /* … keep your previously-approved Phase 2 here … */ addScene('Phase 2 begins (logic trimmed in this snippet).'); phase=3; }
function runPhase3(){ /* … same … */ addScene('Phase 3 (logic trimmed in this snippet).'); finalists=players.slice(0,3); phase=4; }
function runFinale(){ addScene('Finale (jury, vaults, fallback challenge).'); nextBtn.textContent='Simulate Again'; nextBtn.onclick=()=>location.reload(); phase=5; }

/* ====== Start Season ====== */
function ensureKeyBag(){ players.forEach(p=>{ keys[p]=keys[p]||[]; wins[p]=wins[p]||0; losses[p]=losses[p]||0; keysEarned[p]=keysEarned[p]||{P1:0,P2:0}; }); }
function startSeason(){
  if(gameStarted) return;
  const names=parseNames();
  if(names.length!==13){ alert('Please enter exactly 13 players.'); return; }
  players=names.slice(); initialOrder=names.slice();
  ensureKeyBag();
  generateAlliances();
  document.getElementById('castGrid').style.display='none';
  document.getElementById('statsTable').parentElement.parentElement.parentElement.style.display='none'; // hide preseason box
  startBtn.style.display='none'; nextBtn.style.display='inline-block';
  gameStarted=true;
  phase=1; round=1; ensureEpisode(); addScene('Season begins — Alt Vault rules in effect. Tap Next Scene.');
  updateProgress(); renderVoteMatrix(); renderRelsLive();
}

/* ====== Wire buttons ====== */
startBtn.addEventListener('click', startSeason);
nextBtn.addEventListener('click', ()=>{
  if(sceneQueue.length){ showLine(sceneQueue.shift()); return; }
  progressGame();
  if(sceneQueue.length){ showLine(sceneQueue.shift()); }
});

/* ====== Initial fill to guarantee preseason works ====== */
(function init(){
  const defaults = Array.from({length:13},(_,i)=>`Player ${i+1}`).join('\n');
  playerInput.value = defaults;
  refreshPreseason(); // builds cast/stats/relationships immediately
})();
</script>
</body>
</html>