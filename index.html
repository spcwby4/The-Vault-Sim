<!DOCTYPE html>
<html>
<head>
  <title>The Vault Simulator</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    .log { white-space: pre-wrap; background: #f8f8f8; padding: 10px; border: 1px solid #ccc; margin-top: 20px; }
    table { border-collapse: collapse; margin-top: 20px; }
    td, th { border: 1px solid #999; padding: 5px 10px; text-align: center; }
    .highlight { font-weight: bold; color: #d42; }
  </style>
</head>
<body>
  <h1>The Vault Simulator</h1>

  <p>Enter 12 player names, one per line:</p>
  <textarea id="playerInput" rows="12" cols="30" placeholder="Player 1&#10;Player 2&#10;..."></textarea><br>
  <button onclick="startGame()">Start Game</button>
  <button onclick="runRound()" id="nextRoundBtn" style="display:none;">Run Next Round</button>

  <div id="log" class="log"></div>
  <div id="votingTable"></div>
  <div id="progressTableContainer"></div>

  <script>
  let players = [];
let phase = 1;
let round = 1;
let lockpickHolder = null;
let lockpickUsed = false;
let voteTable = [];

function startGame() {
  const input = document.getElementById('playerInput').value.trim().split('\n').map(p => p.trim()).filter(p => p);
  if (input.length !== 12) return alert("You must enter exactly 12 names.");
  players = input.map(name => ({
    name,
    eliminated: false,
    keyPhase1: false,
    keyPhase2: false,
    keyPhase3: false,
    finalist: false,
    vault: null,
    votesReceived: 0,
    alliances: [],
    hasLockpick: false,
    elimRound: null,
    totalKeys: 0,
  }));
  assignAlliances();
  hide("playerInput");
  hide("startGame");
  show("nextRoundBtn");
  runRound();
}

function assignAlliances() {
  const possible = [...players];
  const allianceCount = 3 + Math.floor(Math.random() * 3); // 3–5 alliances
  for (let i = 0; i < allianceCount; i++) {
    const size = 3 + Math.floor(Math.random() * 3); // 3–5 players per alliance
    const members = shuffle([...possible]).slice(0, size);
    members.forEach(p => {
      if (!p.alliances.includes(i)) p.alliances.push(i);
    });
  }
}
function runRound() {
  clearLogs();
  log(`--- Phase ${phase}, Round ${round} ---`);
  if (phase === 1) runPhase1();
  else if (phase === 2) runPhase2();
  else if (phase === 3) runPhase3();
  else runFinale();
}

function runPhase1() {
  const eligible = players.filter(p => !p.keyPhase1 && !p.eliminated);
  const drawn = shuffle(eligible).slice(0, 4);
  log(`Drawn for Key Quest: ${drawn.map(p => p.name).join(', ')}`);
  logAlliances();

  // Lockpick
  if (!lockpickHolder && Math.random() < 0.33) {
    const finder = drawn[Math.floor(Math.random() * drawn.length)];
    lockpickHolder = finder;
    finder.hasLockpick = true;
    log(`${finder.name} has found the LOCKPICK!`);
  }

  // Voting
  voteTable = [];
  players.forEach(voter => {
    const voteOptions = drawn.filter(p => p.name !== voter.name);
    let voteFor = chooseAllyOrRandom(voter, voteOptions);
    voteTable.push({ voter: voter.name, votedFor: voteFor.name });
  });

  displayVotingTable(drawn);

  // Lockpick use
  if (lockpickHolder && drawn.includes(lockpickHolder)) {
    log(`${lockpickHolder.name} uses the LOCKPICK to guarantee the vote key.`);
    giveKey(lockpickHolder, "keyPhase1");
    lockpickHolder.hasLockpick = false;
    lockpickHolder = null;
  } else {
    const counts = countVotes(voteTable);
    const winner = tiebreak(counts, drawn);
    giveKey(winner, "keyPhase1");
    log(`${winner.name} wins the vote key.`);
  }

  // Challenge key
  const nonWinners = drawn.filter(p => !p.keyPhase1);
  const challengeWinner = nonWinners[Math.floor(Math.random() * nonWinners.length)];
  giveKey(challengeWinner, "keyPhase1");
  log(`${challengeWinner.name} wins the challenge key.`);

  // Eliminate if 4 rounds done
  if (round === 4) {
    const eliminated = players.filter(p => !p.keyPhase1);
    eliminated.forEach(p => {
      p.eliminated = true;
      p.elimRound = round;
      log(`${p.name} is eliminated.`);
    });
    phase = 2;
    round = 0;
  }

  round++;
}
function runPhase2() {
  const eligible = players.filter(p => !p.eliminated && !p.keyPhase2);
  if (eligible.length <= 4) {
    phase = 3;
    round = 1;
    return runRound();
  }

  logAlliances();

  // Lockpick chance
  if (!lockpickHolder && Math.random() < 0.33) {
    const finder = eligible[Math.floor(Math.random() * eligible.length)];
    lockpickHolder = finder;
    finder.hasLockpick = true;
    log(`${finder.name} has found the LOCKPICK!`);
  }

  // Voting
  voteTable = [];
  players.filter(p => !p.eliminated).forEach(voter => {
    const voteOptions = eligible.filter(p => p.name !== voter.name);
    let voteFor = chooseAllyOrRandom(voter, voteOptions);
    voteTable.push({ voter: voter.name, votedFor: voteFor.name });
  });

  displayVotingTable(eligible);

  // Lockpick use
  if (lockpickHolder && !lockpickUsed) {
    log(`${lockpickHolder.name} uses the LOCKPICK to win the vote.`);
    let opponent = eligible.find(p => p.name !== lockpickHolder.name);
    duel(lockpickHolder, opponent);
    lockpickHolder.hasLockpick = false;
    lockpickHolder = null;
    lockpickUsed = true;
  } else {
    const counts = countVotes(voteTable);
    const winner = tiebreak(counts, eligible);
    const opponent = eligible.find(p => p.name !== winner.name);
    duel(winner, opponent);
  }

  if (players.filter(p => !p.eliminated && !p.keyPhase2).length <= 4) {
    phase = 3;
    round = 1;
  } else {
    round++;
  }
}

function runPhase3() {
  log(`Final 4 players:`);
  const final4 = players.filter(p => !p.eliminated && !p.finalist);
  final4.forEach(p => log(p.name));

  voteTable = [];
  final4.forEach(voter => {
    const voteOptions = final4.filter(p => p.name !== voter.name);
    let voteFor = chooseAllyOrRandom(voter, voteOptions);
    voteTable.push({ voter: voter.name, votedFor: voteFor.name });
  });

  displayVotingTable(final4);

  const counts = countVotes(voteTable);
  const winner = tiebreak(counts, final4);
  winner.keyPhase3 = true;
  winner.finalist = true;
  log(`${winner.name} wins the vote and advances to the finale.`);

  const pick = chooseAllyOrRandom(winner, final4.filter(p => p !== winner));
  pick.keyPhase3 = true;
  pick.finalist = true;
  log(`${winner.name} brings ${pick.name} to the finale.`);

  const rest = final4.filter(p => !p.finalist);
  const duelWinner = rest[Math.floor(Math.random() * rest.length)];
  duelWinner.keyPhase3 = true;
  duelWinner.finalist = true;
  rest.forEach(p => {
    p.eliminated = true;
    p.elimRound = "Phase 3";
    log(`${p.name} is eliminated in Phase 3.`);
  });

  phase = 4;
  round = 1;
}
function runFinale() {
  const finalists = players.filter(p => p.finalist);
  finalists.forEach(p => p.totalKeys = 3); // Base keys

  const jury = players.filter(p => !p.finalist && p.eliminated);

  jury.forEach(j => {
    let amount = j.elimRound === "Phase 3" ? 4 : j.keyPhase2 ? 2 : 1;
    const targets = shuffle([...finalists]);
    if (Math.random() < 0.4 && j.alliances.length) {
      const ally = targets.find(f => sharesAlliance(j, f));
      if (ally) {
        ally.totalKeys += amount;
        log(`${j.name} gives ${amount} key(s) to ally ${ally.name}`);
        return;
      }
    }
    const pick = targets[0];
    pick.totalKeys += amount;
    log(`${j.name} gives ${amount} key(s) to ${pick.name}`);
  });

  // Vault selections
  finalists.forEach(p => {
    const expected = p.totalKeys;
    if (expected >= 11) p.vault = 17 + Math.floor(Math.random() * 4); // go big
    else p.vault = expected + Math.floor(Math.random() * 2); // play safe
    log(`${p.name} selects vault requiring ${p.vault} keys`);
  });

  // Determine winner
  const openers = finalists.filter(p => p.totalKeys >= p.vault);
  if (openers.length === 0) {
    const fourth = players.find(p => p.elimRound === "Phase 3");
    log(`No vault opened. ${fourth.name} wins!`);
    showSummary(fourth.name);
    return;
  }
  const winner = openers.reduce((a, b) => (a.vault > b.vault ? a : b));
  log(`${winner.name} opens the highest vault and wins!`);
  showSummary(winner.name);
}

function duel(p1, p2) {
  const winner = Math.random() < 0.5 ? p1 : p2;
  giveKey(winner, "keyPhase2");
  log(`${winner.name} wins the duel over ${p1 === winner ? p2.name : p1.name}`);
}

function chooseAllyOrRandom(voter, options) {
  const allies = options.filter(o => sharesAlliance(voter, o));
  return allies.length && Math.random() < 0.75
    ? allies[Math.floor(Math.random() * allies.length)]
    : options[Math.floor(Math.random() * options.length)];
}

function sharesAlliance(p1, p2) {
  return p1.alliances.some(a => p2.alliances.includes(a));
}

function countVotes(votes) {
  const map = {};
  votes.forEach(v => map[v.votedFor] = (map[v.votedFor] || 0) + 1);
  return map;
}

function tiebreak(map, options) {
  let max = Math.max(...Object.values(map));
  let tied = options.filter(o => map[o.name] === max);
  return tied[Math.floor(Math.random() * tied.length)];
}

function giveKey(player, keyType) {
  player[keyType] = true;
}

function log(msg) {
  document.getElementById("log").innerText += msg + '\n';
}

function clearLogs() {
  document.getElementById("log").innerText = '';
  document.getElementById("votingTable").innerHTML = '';
}

function displayVotingTable(drawn) {
  let html = "<table><tr><th>Voter</th><th>Voted For</th></tr>";
  voteTable.forEach(v => {
    let keyPlayer = players.find(p => p.name === v.votedFor);
    let nameClass = keyPlayer && (keyPlayer.keyPhase1 || keyPlayer.keyPhase2 || keyPlayer.keyPhase3) ? "highlight" : "";
    html += `<tr><td>${v.voter}</td><td class="${nameClass}">${v.votedFor}</td></tr>`;
  });
  html += "</table>";
  document.getElementById("votingTable").innerHTML = html;
}

function showSummary(winnerName) {
  const sorted = [...players].sort((a, b) => {
    if (a.name === winnerName) return -1;
    if (b.name === winnerName) return 1;
    if (a.finalist && b.finalist) return b.vault - a.vault;
    if (a.finalist) return -1;
    if (b.finalist) return 1;
    return a.elimRound - b.elimRound;
  });
  let html = "<h2>Game Summary</h2><table><tr><th>Player</th><th>Final Keys</th><th>Vault</th><th>Status</th></tr>";
  sorted.forEach(p => {
    html += `<tr><td>${p.name}</td><td>${p.totalKeys || "-"}</td><td>${p.vault || "-"}</td><td>${p.name === winnerName ? "WINNER" : p.finalist ? "Finalist" : `Eliminated in ${p.elimRound}`}</td></tr>`;
  });
  html += "</table>";
  document.getElementById("progressTableContainer").innerHTML = html;
}

function shuffle(array) {
  return array.sort(() => Math.random() - 0.5);
}

function hide(id) {
  document.getElementById(id).style.display = "none";
}

function show(id) {
  document.getElementById(id).style.display = "inline-block";
}
</script>
</body>
</html>